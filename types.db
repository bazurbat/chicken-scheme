;;;; types.db - Type-information for core library functions -*- Scheme -*-
;
; Copyright (c) 2009-2014, The CHICKEN Team
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following
; conditions are met:
;
;   Redistributions of source code must retain the above copyright notice, this list of conditions and the following
;     disclaimer. 
;   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
;     disclaimer in the documentation and/or other materials provided with the distribution. 
;   Neither the name of the author nor the names of its contributors may be used to endorse or promote
;     products derived from this software without specific prior written permission. 
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
; OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
; AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
; CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY
; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
; OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.


;;; Notes:
;
; - numeric types are disjoint, "fixnum" or "float" will not match "number" in the
;   rewrite rules
; - for a description of the type-specifier syntax, see "scrutinizer.scm" (top of file)
; - in templates, "#(INTEGER)" refers to the INTEGERth argument (starting from 1)
; - in templates, "#(INTEGER ...)" refers to the INTEGERth argument (starting from 1) and
;   all remaining arguments
; - in templates "#(SYMBOL)" binds X to a temporary gensym'd variable, further references
;   to "#(SYMBOL)" allow backreferences to this generated identifier
; - "#(procedure PROPERTY ...)" may be used in place of "procedure", properties are:
;     #:clean - procedure does not modify state that might be used locally
;     #:enforce - when procedure returns, arguments are of correct type
;     #:foldable - procedure may be constant-folded
;     #:predicate TYPE - procedure is a predicate on TYPE (implies #:foldable)
;     #:pure - procedure has no side effects
; - "#:clean" means: will not invoke procedures that modify local variables and
;   will not modify list or vector data held locally (note that I/O may invoke
;   port handlers)
; - "#:pure" means: will not have side-effects; this is a bit of a lie,
;   since arity-mismatch will for example always have a side effect.
; - "#:enforce" means: after return from this procedure, the argument is of
;   the correct type (it would have signalled an error otherwise)
; - "#:foldable" means: when applied to constant arguments, direct calls
;   to this procedure may be evaluated at compile time.


;; scheme

(not (#(procedure #:pure #:foldable) not (*) boolean)
     (((not boolean)) (let ((#(tmp) #(1))) '#f)))

(boolean? (#(procedure #:pure #:predicate boolean) boolean? (*) boolean))

(eq? (#(procedure #:pure #:foldable) eq? (* *) boolean))

(eqv? (#(procedure #:pure #:foldable) eqv? (* *) boolean)
      (((or immediate symbol) *) (eq? #(1) #(2)))
      ((* (or immediate symbol)) (eq? #(1) #(2)))
      ((* *) (##core#inline "C_i_eqvp" #(1) #(2))))

(equal? (#(procedure #:pure #:foldable) equal? (* *) boolean)
	(((or immediate symbol) *) (eq? #(1) #(2)))
	((* (or immediate symbol)) (eq? #(1) #(2)))
	((number number) (##core#inline "C_i_eqvp" #(1) #(2))))

(pair? (#(procedure #:pure #:predicate pair) pair? (*) boolean))

(cons (forall (a b) (#(procedure #:pure) cons (a b) (pair a b))))

(##sys#cons (forall (a b) (#(procedure #:pure) ##sys#cons (a b) (pair a b))))

(car (forall (a) (#(procedure #:clean #:enforce #:foldable) car ((pair a *)) a)) ((pair) (##core#inline "C_u_i_car" #(1))))
(cdr (forall (a) (#(procedure #:clean #:enforce #:foldable) cdr ((pair * a)) a)) ((pair) (##core#inline "C_u_i_cdr" #(1))))

(caar (forall (a) (#(procedure #:clean #:enforce #:foldable) caar ((pair (pair a *) *)) a))
      (((pair (pair * *) *)) (##core#inline "C_u_i_car" (##core#inline "C_u_i_car" #(1)))))
(cadr (forall (a) (#(procedure #:clean #:enforce #:foldable) cadr ((pair * (pair a *))) a))
      (((pair * (pair * *))) (##core#inline "C_u_i_car" (##core#inline "C_u_i_cdr" #(1)))))
(cdar (forall (a) (#(procedure #:clean #:enforce #:foldable) cdar ((pair (pair * a) *)) a))
      (((pair (pair * *) *)) (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_car" #(1)))))
(cddr (forall (a) (#(procedure #:clean #:enforce #:foldable) cddr ((pair * (pair * a))) a))
      (((pair * (pair * *))) (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_cdr" #(1)))))

(caaar (forall (a) (#(procedure #:clean #:enforce #:foldable) caaar ((pair (pair (pair a *) *) *)) a))
       (((pair (pair (pair * *) *) *))
	(##core#inline "C_u_i_car"
		       (##core#inline "C_u_i_car" (##core#inline "C_u_i_car" #(1))))))

(caadr (forall (a) (#(procedure #:clean #:enforce #:foldable) caadr ((pair * (pair (pair a *) *))) a))
       (((pair * (pair (pair * *) *)))
	(##core#inline "C_u_i_car"
		       (##core#inline "C_u_i_car" (##core#inline "C_u_i_cdr" #(1))))))

(cadar (forall (a) (#(procedure #:clean #:enforce #:foldable) cadar ((pair (pair * (pair a *)) *)) a))
       (((pair (pair * (pair * *)) *))
	(##core#inline "C_u_i_car"
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_car" #(1))))))

(caddr (forall (a) (#(procedure #:clean #:enforce #:foldable) caddr ((pair * (pair * (pair a *)))) a))
       (((pair * (pair * (pair * *))))
	(##core#inline "C_u_i_car"
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_cdr" #(1))))))

(cdaar (forall (a) (#(procedure #:clean #:enforce #:foldable) cdaar ((pair (pair (pair * a) *) *)) a))
       (((pair (pair (pair * *) *) *))
	(##core#inline "C_u_i_cdr"
		       (##core#inline "C_u_i_car" (##core#inline "C_u_i_car" #(1))))))

(cdadr (forall (a) (#(procedure #:clean #:enforce #:foldable) cdadr ((pair * (pair (pair * a) *))) a))
       (((pair * (pair (pair * *) *)))
	(##core#inline "C_u_i_cdr"
		       (##core#inline "C_u_i_car" (##core#inline "C_u_i_cdr" #(1))))))

(cddar (forall (a) (#(procedure #:clean #:enforce #:foldable) cddar ((pair (pair * (pair * a)) *)) a))
       (((pair (pair * (pair * *)) *))
	(##core#inline "C_u_i_cdr"
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_car" #(1))))))

(cdddr (forall (a) (#(procedure #:clean #:enforce #:foldable) cdddr ((pair * (pair * (pair * a)))) a))
       (((pair * (pair * (pair * *))))
	(##core#inline "C_u_i_cdr"
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_cdr" #(1))))))

(caaaar (forall (a) (#(procedure #:clean #:enforce #:foldable) caaaar ((pair (pair (pair (pair a *) *) *) *)) a)))
(caaadr (forall (a) (#(procedure #:clean #:enforce #:foldable) caaadr ((pair * (pair (pair (pair a *) *) *))) a)))
(caadar (forall (a) (#(procedure #:clean #:enforce #:foldable) caadar ((pair (pair * (pair (pair a *) *)) *)) a)))
(caaddr (forall (a) (#(procedure #:clean #:enforce #:foldable) caaddr ((pair * (pair * (pair (pair a *) *)))) a)))
(cadaar (forall (a) (#(procedure #:clean #:enforce #:foldable) cadaar ((pair (pair (pair * (pair a *)) *) *)) a)))
(cadadr (forall (a) (#(procedure #:clean #:enforce #:foldable) cadadr ((pair * (pair (pair * (pair a *)) *))) a)))
(caddar (forall (a) (#(procedure #:clean #:enforce #:foldable) caddar ((pair (pair * (pair * (pair a *))) *)) a)))
(cadddr (forall (a) (#(procedure #:clean #:enforce #:foldable) cadddr ((pair * (pair * (pair * (pair a *))))) a)))
(cdaaar (forall (a) (#(procedure #:clean #:enforce #:foldable) cdaaar ((pair (pair (pair (pair * a) *) *) *)) a)))
(cdaadr (forall (a) (#(procedure #:clean #:enforce #:foldable) cdaadr ((pair * (pair (pair (pair * a) *) *))) a)))
(cdadar (forall (a) (#(procedure #:clean #:enforce #:foldable) cdadar ((pair (pair * (pair (pair * a) *)) *)) a)))
(cdaddr (forall (a) (#(procedure #:clean #:enforce #:foldable) cdaddr ((pair * (pair * (pair (pair * a) *)))) a)))
(cddaar (forall (a) (#(procedure #:clean #:enforce #:foldable) cddaar ((pair (pair (pair * (pair * a)) *) *)) a)))
(cddadr (forall (a) (#(procedure #:clean #:enforce #:foldable) cddadr ((pair * (pair (pair * (pair * a)) *))) a)))
(cdddar (forall (a) (#(procedure #:clean #:enforce #:foldable) cdddar ((pair (pair * (pair * (pair * a))) *)) a)))
(cddddr (forall (a) (#(procedure #:clean #:enforce #:foldable) cddddr ((pair * (pair * (pair * (pair * a))))) a)))

(set-car! (#(procedure #:enforce) set-car! (pair *) undefined) 
	  ((pair (or fixnum char boolean eof null undefined)) (##sys#setislot #(1) '0 #(2)))
	  ((pair *) (##sys#setslot #(1) '0 #(2))))

(set-cdr! (#(procedure #:enforce) set-cdr! (pair *) undefined)
	  ((pair (or fixnum char boolean eof null undefined)) (##sys#setislot #(1) '1 #(2)))
	  ((pair *) (##sys#setslot #(1) '1 #(2))))

(null? (#(procedure #:pure #:predicate null) null? (*) boolean))
(list? (#(procedure #:pure #:predicate list) list? (*) boolean))

;; special cased (see scrutinizer.scm)
(list (#(procedure #:pure) list (#!rest) list))
(##sys#list (#(procedure #:pure) ##sys#list (#!rest) list))

(length (#(procedure #:clean #:enforce #:foldable) length (list) fixnum) ; may loop
	((null) (let ((#(tmp) #(1))) '0))
	((list) (##core#inline "C_u_i_length" #(1))))

(##sys#length (#(procedure #:clean #:enforce #:foldable) ##sys#length (list) fixnum)
	      ((null) (let ((#(tmp) #(1))) '0))
	      ((list) (##core#inline "C_u_i_length" #(1))))

;; these are special cased (see scrutinizer.scm)
(list-tail (forall (a) (#(procedure #:clean #:enforce #:foldable) list-tail ((list-of a) fixnum) (list-of a))))
(list-ref (forall (a) (#(procedure #:clean #:enforce #:foldable) list-ref ((list-of a) fixnum) a)))

(append (#(procedure #:clean) append (#!rest *) *)) ; sic
(##sys#append (#(procedure #:clean) ##sys#append (#!rest *) *))

;; special cased (see scrutinizer.scm)
(reverse (forall (a) (#(procedure #:clean #:enforce) reverse ((list-of a)) (list-of a)))
         ((null) (null) (let ((#(tmp) #(1))) '())))

(memq (forall (a b) (#(procedure #:clean #:foldable) memq
                    (a (list-of b))
                    (or false (list-of b))))
      ((* null) (let ((#(tmp) #(1))) '#f))
      ((* list) (##core#inline "C_u_i_memq" #(1) #(2))))

(memv (forall (a b) (#(procedure #:clean #:foldable) memv
                    (a (list-of b))
                    (or false (list-of b))))
      ((* null) (let ((#(tmp) #(1))) '#f))
      (((or symbol procedure immediate) list)
       (##core#inline "C_u_i_memq" #(1) #(2))))

(member (forall (a b) (#(procedure #:clean #:foldable) member
		       (a (list-of b) #!optional (procedure (b a) *)) ; sic
		       (or false (list-of b))))
	((* null) (let ((#(tmp) #(1))) '#f))
	(((or symbol procedure immediate) list)
	 (##core#inline "C_u_i_memq" #(1) #(2)))
	((* (list-of (or symbol procedure immediate)))
	 (##core#inline "C_u_i_memq" #(1) #(2))))

(assq (forall (a b) (#(procedure #:clean #:foldable) assq
		     (* (list-of (pair a b)))
		     (or false (pair a b))))
      ((* null) (let ((#(tmp) #(1))) '#f))
      ((* (list-of pair)) (##core#inline "C_u_i_assq" #(1) #(2))))

(assv (forall (a b) (#(procedure #:clean #:foldable) assv
		     (* (list-of (pair a b)))
		     (or false (pair a b))))
      ((* null) (let ((#(tmp) #(1))) '#f))
      (((or symbol immediate procedure) (list-of pair))
       (##core#inline "C_u_i_assq" #(1) #(2)))
      ((* (list-of (pair (or symbol procedure immediate) *)))
       (##core#inline "C_u_i_assq" #(1) #(2))))

(assoc (forall (a b c) (#(procedure #:clean #:foldable) assoc
                       (a (list-of (pair b c)) #!optional (procedure (b a) *)) ; sic
                       (or false (pair b c))))
       ((* null) (let ((#(tmp) #(1))) '#f))
       (((or symbol procedure immediate) (list-of pair))
	(##core#inline "C_u_i_assq" #(1) #(2)))
       ((* (list-of (pair (or symbol procedure immediate) *)))
	(##core#inline "C_u_i_assq" #(1) #(2))))

(symbol? (#(procedure #:pure #:predicate symbol) symbol? (*) boolean))

(symbol-append (#(procedure #:clean #:enforce #:foldable) symbol-append (#!rest symbol) symbol))
(symbol->string (#(procedure #:clean #:enforce) symbol->string (symbol) string))
(string->symbol (#(procedure #:clean #:enforce #:foldable) string->symbol (string) symbol))

(number? (#(procedure #:pure #:predicate number) number? (*) boolean))

;;XXX predicate?
(integer? (#(procedure #:pure #:foldable) integer? (*) boolean)
	  ((integer) (let ((#(tmp) #(1))) '#t))
	  ((float) (##core#inline "C_u_i_fpintegerp" #(1)))
	  ((*) (##core#inline "C_i_integerp" #(1))))
(exact-integer? (#(procedure #:pure #:foldable) exact-integer? (*) boolean)
		((integer) (let ((#(tmp) #(1))) '#t))
		(((not integer)) (let ((#(tmp) #(1))) '#f))
		((*) (##core#inline "C_i_exact_integerp" #(1))))

(real? (#(procedure #:pure #:foldable) real? (*) boolean)
       (((or fixnum float bignum ratnum)) (let ((#(tmp) #(1))) '#t))
       ((cplxnum) (let ((#(tmp) #(1))) '#f))
       ((*) (##core#inline "C_i_realp" #(1))))
(complex? (#(procedure #:pure #:predicate number) complex? (*) boolean))
(exact? (#(procedure #:clean #:enforce #:foldable) exact? (number) boolean)
        (((or integer ratnum)) (let ((#(tmp) #(1))) '#t))
        ((float) (let ((#(tmp) #(1))) '#f)))
(inexact? (#(procedure #:clean #:enforce #:foldable) inexact? (number) boolean)
          (((or integer ratnum)) (let ((#(tmp) #(1))) '#f))
          ((float) (let ((#(tmp) #(1))) '#t)))

;;XXX predicate?
(rational? (#(procedure #:pure #:foldable) rational? (*) boolean)
	   (((or fixnum bignum ratnum)) (let ((#(tmp) #(1))) '#t))
	   ((cplxnum) (let ((#(tmp) #(1))) '#f))
	   ((float) (##core#inline "C_u_i_flonum_finitep" #(1)))
	   ((*) (##core#inline "C_i_rationalp" #(1))))

(zero? (#(procedure #:clean #:enforce #:foldable) zero? (number) boolean)
       ((integer) (eq? #(1) '0))
       (((or cplxnum ratnum)) '#f)
       ((number) (##core#inline "C_u_i_zerop" #(1)))
       ((*) (##core#inline "C_i_zerop" #(1))))

(odd? (#(procedure #:clean #:enforce #:foldable) odd? (number) boolean)
	       ((fixnum) (##core#inline "C_i_fixnumoddp" #(1)))
               ((integer) (##core#inline "C_i_integer_oddp" #(1)))
               ((*) (##core#inline "C_i_oddp" #(1))))
(even? (#(procedure #:clean #:enforce #:foldable) even? (number) boolean)
	       ((fixnum) (##core#inline "C_i_fixnumevenp" #(1)))
               ((integer) (##core#inline "C_i_integer_evenp" #(1)))
               ((*) (##core#inline "C_i_evenp" #(1))))

(positive? (#(procedure #:clean #:enforce #:foldable) positive? (number) boolean)
	   ((fixnum) (##core#inline "C_i_fixnum_positivep" #(1)))
	   ((integer) (##core#inline "C_i_integer_positivep" #(1)))
	   ((*) (##core#inline "C_i_positivep" #(1))))

(negative? (#(procedure #:clean #:enforce #:foldable) negative? (number) boolean)
	   ((fixnum) (##core#inline "C_i_fixnum_negativep" #(1)))
	   ((integer) (##core#inline "C_i_integer_negativep" #(1)))
	   ((*) (##core#inline "C_i_negativep" #(1))))

(max (#(procedure #:clean #:enforce #:foldable) max (#!rest number) number)
     ((fixnum fixnum) (fxmax #(1) #(2)))
     ((float float) (##core#inline "C_i_flonum_max" #(1) #(2))))

(min (#(procedure #:clean #:enforce #:foldable) min (#!rest number) number)
     ((fixnum fixnum) (fxmin #(1) #(2)))
     ((float float) (##core#inline "C_i_flonum_min" #(1) #(2))))

(+ (#(procedure #:clean #:enforce #:foldable) + (#!rest number) number)
   (() (fixnum) '0)
   ((fixnum) (fixnum) #(1))
   ((float) (float) #(1))
   ((integer) (integer) #(1))
   ((ratnum) (ratnum) #(1))
   ((cplxnum) (cplxnum) #(1))
   ((number) (number) #(1))
   ((float fixnum) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_plus" 4) 
     #(1) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float)
    (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_plus" 4) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
     #(2)))
   ((float float) (float)
    (##core#inline_allocate ("C_a_i_flonum_plus" 4) #(1) #(2)))
   ((fixnum fixnum) (integer)
    (##core#inline_allocate ("C_a_i_fixnum_plus" 6) #(1) #(2)))
   ((integer integer) (integer)
    (##sys#integer-plus #(1) #(2)))
   ((* *) (number)
    (##sys#+-2 #(1) #(2))))

(- (#(procedure #:clean #:enforce #:foldable) - (number #!rest number) number)
   ((fixnum) (integer) (##core#inline_allocate ("C_a_i_fixnum_negate" 6) #(1)))
   ((integer) (integer)
    (##core#inline_allocate ("C_s_a_u_i_integer_negate" 6) #(1)))
   ((float) (float) (##core#inline_allocate ("C_a_i_flonum_negate" 4) #(1)))
   ((*) (*) (##core#inline_allocate ("C_s_a_i_negate" 36) #(1)))
   ((float fixnum) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_difference" 4) 
     #(1) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_difference" 4) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
     #(2)))
   ((float float) (float)
    (##core#inline_allocate ("C_a_i_flonum_difference" 4) #(1) #(2)))
   ((fixnum fixnum) (integer)
    (##core#inline_allocate ("C_a_i_fixnum_difference" 6) #(1) #(2)))
   ((integer integer) (integer)
    (##sys#integer-minus #(1) #(2)))
   ((* *) (number)
    (##sys#--2 #(1) #(2))))

(* (#(procedure #:clean #:enforce #:foldable) * (#!rest number) number)
   (() (fixnum) '1)
   ((fixnum) (fixnum) #(1))
   ((float) (float) #(1))
   ((bignum) (bignum) #(1))
   ((integer) (integer) #(1))
   ((ratnum) (ratnum) #(1))
   ((cplxnum) (cplxnum) #(1))
   ((number) (number) #(1))
   ((float fixnum) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_times" 4) 
     #(1) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_times" 4) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
     #(2)))
   ((float float) (float)
    (##core#inline_allocate ("C_a_i_flonum_times" 4) #(1) #(2)))
   ((fixnum fixnum) (integer)
    (##core#inline_allocate ("C_a_i_fixnum_times" 7) #(1) #(2)))
   ((integer integer) (integer)
    (##sys#integer-times #(1) #(2)))
   ((* *) (number)
    (##sys#*-2 #(1) #(2))))

(/ (#(procedure #:clean #:enforce #:foldable) / (number #!rest number) number)
   ((float fixnum) (float)
    ;; This is the only checked one because the divisor is an exact value
    (##core#inline_allocate
     ("C_a_i_flonum_quotient_checked" 4)
     #(1)
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float) (float)
    (##core#inline_allocate
     ("C_a_i_flonum_quotient" 4)
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
     #(2)))
   ((float float) (float)
    (##core#inline_allocate ("C_a_i_flonum_quotient" 4) #(1) #(2)))
   ((integer integer) ((or integer ratnum))
    (##sys#/-2 #(1) #(2)))
   ((* *) (number)
    (##sys#/-2 #(1) #(2))))

(= (#(procedure #:clean #:enforce #:foldable) = (#!rest number) boolean)
   (() '#t)
   ((number) (let ((#(tmp) #(1))) '#t))
   ((fixnum fixnum) (eq? #(1) #(2)))
   ((float float) (##core#inline "C_flonum_equalp" #(1) #(2)))
   ((integer integer) (##core#inline "C_i_integer_equalp" #(1) #(2)))
   ((* *) (##core#inline "C_i_nequalp" #(1) #(2))))

(> (#(procedure #:clean #:enforce #:foldable) > (#!rest number) boolean)
   (() '#t)
   ((number) (let ((#(tmp) #(1))) '#t))
   ((fixnum fixnum) (fx> #(1) #(2)))
   ((float float) (##core#inline "C_flonum_greaterp" #(1) #(2)))
   ((integer integer) (##core#inline "C_i_integer_greaterp" #(1) #(2)))
   ((* *) (##core#inline "C_i_greaterp" #(1) #(2))))

(< (#(procedure #:clean #:enforce #:foldable) < (#!rest number) boolean)
   (() '#t)
   ((number) (let ((#(tmp) #(1))) '#t))
   ((fixnum fixnum) (fx< #(1) #(2)))
   ((integer integer) (##core#inline "C_i_integer_lessp" #(1) #(2)))
   ((float float) (##core#inline "C_flonum_lessp" #(1) #(2)))
   ((* *) (##core#inline "C_i_lessp" #(1) #(2))))

(>= (#(procedure #:clean #:enforce #:foldable) >= (#!rest number) boolean)
    (() '#t)
    ((number) (let ((#(tmp) #(1))) '#t))
    ((fixnum fixnum) (fx>= #(1) #(2)))
    ((integer integer) (##core#inline "C_i_integer_greater_or_equalp" #(1) #(2)))
    ((float float) (##core#inline "C_flonum_greater_or_equal_p" #(1) #(2)))
    ((* *) (##core#inline "C_i_greater_or_equalp" #(1) #(2))))

(<= (#(procedure #:clean #:enforce #:foldable) <= (#!rest number) boolean)
    (() '#t)
    ((number) (let ((#(tmp) #(1))) '#t))
    ((fixnum fixnum) (fx<= #(1) #(2)))
    ((integer integer) (##core#inline "C_i_integer_less_or_equalp" #(1) #(2)))
    ((float float) (##core#inline "C_flonum_less_or_equal_p" #(1) #(2)))
    ((* *) (##core#inline "C_i_less_or_equalp" #(1) #(2))))

(quotient (#(procedure #:clean #:enforce #:foldable) quotient ((or integer float) (or integer float)) (or integer float))
	  ;;XXX flonum/mixed case
	  ((float float) (float)
	   (##core#inline_allocate
	    ("C_a_i_flonum_actual_quotient_checked" 4) #(1) #(2)))
	  ((fixnum fixnum) (integer)
	   (##core#inline_allocate ("C_a_i_fixnum_quotient_checked" 6)
				   #(1) #(2)))
	  ((integer integer) (integer)
	   (##sys#integer-quotient #(1) #(2))))

(remainder (#(procedure #:clean #:enforce #:foldable) remainder ((or integer float) (or integer float)) (or integer float))
	  ((float float) (float)
	   (##core#inline_allocate
	    ("C_a_i_flonum_remainder_checked" 4) #(1) #(2)))
	   ;;XXX flonum/mixed case
	   ((fixnum fixnum) (fixnum)
	    (##core#inline "C_i_fixnum_remainder_checked" #(1) #(2)))
	   ((integer integer) (integer)
	    (##sys#integer-remainder #(1) #(2))))

(quotient&remainder (#(procedure #:clean #:enforce #:foldable) quotient&remainder ((or integer float) (or integer float)) (or integer float) (or integer float))
	  ((float float) (float float)
	   (let ((#(tmp1) #(1)))
	     (let ((#(tmp2) #(2)))
	       (##sys#values
		(##core#inline_allocate
		 ("C_a_i_flonum_actual_quotient_checked" 4) #(tmp1) #(tmp2))
		(##core#inline_allocate
		 ("C_a_i_flonum_remainder_checked" 4) #(tmp1) #(tmp2))))))
	   ;;XXX flonum/mixed case
	   ((fixnum fixnum) (integer fixnum)
	    (let ((#(tmp1) #(1)))
	      (let ((#(tmp2) #(2)))
		(##sys#values
		 (##core#inline_allocate ("C_a_i_fixnum_quotient_checked" 6)
					 #(tmp1) #(tmp2))
		 (##core#inline
		  "C_i_fixnum_remainder_checked" #(tmp1) #(tmp2))))))
	   ((integer integer) (integer integer)
	    (##sys#integer-quotient&remainder #(1) #(2))))

;; TODO: Add nonspecializing type specific entries, to help flow analysis?
(quotient&modulo (#(procedure #:clean #:enforce #:foldable) quotient&modulo ((or integer float) (or integer float)) (or integer float) (or integer float)))

(modulo (#(procedure #:clean #:enforce #:foldable) modulo ((or integer float) (or integer float)) (or integer float)))

(gcd (#(procedure #:clean #:enforce #:foldable) gcd (#!rest (or integer float)) (or integer float))
     (() '0)
     ((fixnum fixnum) (fixnum) (fxgcd #(1) #(2)))
     ((float float) (float) (fpgcd #(1) #(2)))
     ((integer integer) (integer) (##sys#integer-gcd #(1) #(2)))
     ((* *) (##sys#gcd #(1) #(2))))

(##sys#gcd (#(procedure #:clean #:enforce #:foldable) ##sys#gcd (number number) number))

(lcm (#(procedure #:clean #:enforce #:foldable) lcm (#!rest number) number)
     (() '1)
     ((* *) (##sys#lcm #(1) #(2))))

(##sys#lcm (#(procedure #:clean #:enforce #:foldable) ##sys#lcm (number number) number))

(abs (#(procedure #:clean #:enforce #:foldable) abs (number) number)
     ((fixnum) (integer) (##core#inline_allocate ("C_a_i_fixnum_abs" 6) #(1)))
     ((float) (float) (##core#inline_allocate ("C_a_i_flonum_abs" 4) #(1)))
     ((integer) (integer)
      (##core#inline_allocate ("C_s_a_u_i_integer_abs" 6) #(1)))
     ((*) (*)
      (##core#inline_allocate ("C_s_a_i_abs" 10) #(1))))

(floor (#(procedure #:clean #:enforce #:foldable) floor ((or integer ratnum float)) (or integer ratnum float))
       ((fixnum) (fixnum) #(1))
       ((integer) (integer) #(1))
       ((float) (float)
	(##core#inline_allocate ("C_a_i_flonum_floor" 4) #(1))))

(ceiling (#(procedure #:clean #:enforce #:foldable) ceiling ((or integer ratnum float)) (or integer ratnum float))
	 ((fixnum) (fixnum) #(1))
	 ((integer) (integer) #(1))
	 ((float) (float)
	  (##core#inline_allocate ("C_a_i_flonum_ceiling" 4) #(1))))

(truncate (#(procedure #:clean #:enforce #:foldable) truncate ((or integer ratnum float)) (or integer ratnum float))
	  ((fixnum) (fixnum) #(1))
	  ((integer) (integer) #(1))
	  ((float) (float)
	   (##core#inline_allocate ("C_a_i_flonum_truncate" 4) #(1))))

(round (#(procedure #:clean #:enforce #:foldable) round ((or integer ratnum float)) (or integer ratnum float))
       ((fixnum) (fixnum) #(1))
       ((integer) (integer) #(1))
       ((float) (float)
	(##core#inline_allocate ("C_a_i_flonum_round_proper" 4) #(1))))

(exact->inexact (#(procedure #:clean #:enforce #:foldable) exact->inexact (number) (or float cplxnum))
		((float) (float) #(1))
		((fixnum) (float) (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))))

(inexact->exact (#(procedure #:clean #:enforce #:foldable) inexact->exact (number) (or integer ratnum))
		((fixnum) (fixnum) #(1))
		((integer) (integer) #(1))
		((ratnum) (ratnum) #(1))
		(((or integer ratnum)) #(1)))

(exp (#(procedure #:clean #:enforce #:foldable) exp (number) (or float cplxnum))
     ((float) (float) (##core#inline_allocate ("C_a_i_flonum_exp" 4) #(1))))

(log (#(procedure #:clean #:enforce #:foldable) log (number) (or float cplxnum))
     ;; Unfortunately this doesn't work when the argument is negative
     ;;((float) (float) (##core#inline_allocate ("C_a_i_flonum_log" 4) #(1)))
     ((*) (##sys#log-1 #(1))))

(expt (#(procedure #:clean #:enforce #:foldable) expt (number number) number)
      ;; This breaks in some extreme edge cases... Worth disabling?
      #;((float float) (float)
      (##core#inline_allocate ("C_a_i_flonum_expt" 4) #(1) #(2)))
      #;((float fixnum) (float)
       (##core#inline_allocate ("C_a_i_flonum_expt" 4) 
			       #(1)
			       (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
      #;((fixnum float) (float)
       (##core#inline_allocate ("C_a_i_flonum_expt" 4)
			       (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
			       #(2))))

(sqrt (#(procedure #:clean #:enforce #:foldable) sqrt (number) number)
      ;; Unfortunately this doesn't work when the argument is negative
      #;((float) (float) (##core#inline_allocate ("C_a_i_flonum_sqrt" 4) #(1))))

(sin (#(procedure #:clean #:enforce #:foldable) sin (number) (or float cplxnum))
     ((float) (float) (##core#inline_allocate ("C_a_i_flonum_sin" 4) #(1))))

(cos (#(procedure #:clean #:enforce #:foldable) cos (number) (or float cplxnum))
     ((float) (float) (##core#inline_allocate ("C_a_i_flonum_cos" 4) #(1))))

(tan (#(procedure #:clean #:enforce #:foldable) tan (number) (or float cplxnum))
     ((float) (float) (##core#inline_allocate ("C_a_i_flonum_tan" 4) #(1))))

(asin (#(procedure #:clean #:enforce #:foldable) asin (number) (or float cplxnum))
      ;; Unfortunately this doesn't work when the number is > 1.0 (returns compnum)
      #;((float) (float) (##core#inline_allocate ("C_a_i_flonum_acos" 4) #(1))))

(acos (#(procedure #:clean #:enforce #:foldable) acos (number) (or float cplxnum))
      ;; Unfortunately this doesn't work when the number is > 1.0 (returns compnum)
      #;((float) (float) (##core#inline_allocate ("C_a_i_flonum_acos" 4) #(1))))

(atan (#(procedure #:clean #:enforce #:foldable) atan (number #!optional number) (or float cplxnum))
      ((float) (float) (##core#inline_allocate ("C_a_i_flonum_atan" 4) #(1)))
      ((float float) (float)
       (##core#inline_allocate ("C_a_i_flonum_atan2" 4) #(1) #(2))))

(number->string (#(procedure #:clean #:enforce) number->string (number #!optional fixnum) string)
		((fixnum fixnum) (##sys#fixnum->string #(1) #(2)))
		((fixnum) (##sys#fixnum->string #(1) '10))
		((integer fixnum) (##sys#integer->string #(1) #(2)))
		((integer) (##sys#integer->string #(1) '10))
		((float fixnum) (##sys#flonum->string #(1) #(2)))
		((float) (##sys#flonum->string #(1) '10))
		((* *) (##sys#number->string #(1) #(2)))
		((*) (##sys#number->string #(1) '10)))

(##sys#fixnum->string (#(procedure #:clean #:enforce) ##sys#fixnum->string (fixnum fixnum) string))
(##sys#integer->string (#(procedure #:clean #:enforce) ##sys#integer->string (integer fixnum) string))
(##sys#flonum->string (#(procedure #:clean #:enforce) ##sys#flonum->string (float fixnum) string))

(string->number (#(procedure #:clean #:enforce #:foldable) string->number (string #!optional fixnum)
		 (or number false)))

(char? (#(procedure #:pure #:predicate char) char? (*) boolean))

;; we could rewrite these, but this is done by the optimizer anyway (safe)
(char=? (#(procedure #:clean #:enforce #:foldable) char=? (char char) boolean))
(char>? (#(procedure #:clean #:enforce #:foldable) char>? (char char) boolean))
(char<? (#(procedure #:clean #:enforce #:foldable) char<? (char char) boolean))
(char>=? (#(procedure #:clean #:enforce #:foldable) char>=? (char char) boolean))
(char<=? (#(procedure #:clean #:enforce #:foldable) char<=? (char char) boolean))

(char-ci=? (#(procedure #:clean #:enforce #:foldable) char-ci=? (char char) boolean))
(char-ci<? (#(procedure #:clean #:enforce #:foldable) char-ci<? (char char) boolean))
(char-ci>? (#(procedure #:clean #:enforce #:foldable) char-ci>? (char char) boolean))
(char-ci>=? (#(procedure #:clean #:enforce #:foldable) char-ci>=? (char char) boolean))
(char-ci<=? (#(procedure #:clean #:enforce #:foldable) char-ci<=? (char char) boolean))
(char-alphabetic? (#(procedure #:clean #:enforce #:foldable) char-alphabetic? (char) boolean))
(char-whitespace? (#(procedure #:clean #:enforce #:foldable) char-whitespace? (char) boolean))
(char-numeric? (#(procedure #:clean #:enforce #:foldable) char-numeric? (char) boolean))
(char-upper-case? (#(procedure #:clean #:enforce #:foldable) char-upper-case? (char) boolean))
(char-lower-case? (#(procedure #:clean #:enforce #:foldable) char-lower-case? (char) boolean))
(char-upcase (#(procedure #:clean #:enforce #:foldable) char-upcase (char) char))
(char-downcase (#(procedure #:clean #:enforce #:foldable) char-downcase (char) char))

(char->integer (#(procedure #:clean #:enforce #:foldable) char->integer (char) fixnum))
(integer->char (#(procedure #:clean #:enforce #:foldable) integer->char (fixnum) char))

(string? (#(procedure #:pure #:predicate string) string? (*) boolean))

(string=? (#(procedure #:clean #:enforce #:foldable) string=? (string string) boolean)
	  ((string string) (##core#inline "C_u_i_string_equal_p" #(1) #(2))))

(string>? (#(procedure #:clean #:enforce #:foldable) string>? (string string) boolean))
(string<? (#(procedure #:clean #:enforce #:foldable) string<? (string string) boolean))
(string>=? (#(procedure #:clean #:enforce #:foldable) string>=? (string string) boolean))
(string<=? (#(procedure #:clean #:enforce #:foldable) string<=? (string string) boolean))
(string-ci=? (#(procedure #:clean #:enforce #:foldable) string-ci=? (string string) boolean))
(string-ci<? (#(procedure #:clean #:enforce #:foldable) string-ci<? (string string) boolean))
(string-ci>? (#(procedure #:clean #:enforce #:foldable) string-ci>? (string string) boolean))
(string-ci>=? (#(procedure #:clean #:enforce #:foldable) string-ci>=? (string string) boolean))
(string-ci<=? (#(procedure #:clean #:enforce #:foldable) string-ci<=? (string string) boolean))

(make-string (#(procedure #:clean #:enforce) make-string (fixnum #!optional char) string)
	     ((fixnum char) (##sys#make-string #(1) #(2)))
	     ((fixnum) (##sys#make-string #(1) '#\space)))

(string-length (#(procedure #:clean #:enforce #:foldable) string-length (string) fixnum)
	       ((string) (##sys#size #(1))))

(string-ref (#(procedure #:clean #:enforce #:foldable) string-ref (string fixnum) char)
	    ((string fixnum) (##core#inline "C_subchar" #(1) #(2))))

(string-set! (#(procedure #:enforce) string-set! (string fixnum char) undefined)
	     ((string fixnum char) (##core#inline "C_setsubchar" #(1) #(2) #(3))))

(string-append (#(procedure #:clean #:enforce) string-append (#!rest string) string)
	       ((string string) (##sys#string-append #(1) #(2))))

(string-copy (#(procedure #:clean #:enforce) string-copy (string) string))

(string->list (#(procedure #:clean #:enforce) string->list (string) (list-of char)))
(list->string (#(procedure #:clean #:enforce) list->string ((list-of char)) string))
(substring (#(procedure #:clean #:enforce) substring (string fixnum #!optional fixnum) string))
;(string-fill! (#(procedure #:clean #:enforce) string-fill! (string char) string)) - s.a.
(string (#(procedure #:clean #:enforce) string (#!rest char) string))

(vector? (#(procedure #:pure #:predicate vector) vector? (*) boolean))

;; special-cased (see scrutinizer.scm)
(make-vector (forall (a) (#(procedure #:clean #:enforce) make-vector (fixnum #!optional a) 
			  (vector-of a))))

;; these are special cased (see scrutinizer.scm)
(vector-ref (forall (a) (#(procedure #:clean #:enforce #:foldable) vector-ref ((vector-of a) fixnum) a)))
(##sys#vector-ref (forall (a) (#(procedure #:clean #:enforce #:foldable) ##sys#vector-ref ((vector-of a) fixnum) a)))

(vector-set! (#(procedure #:enforce) vector-set! (vector fixnum *) undefined))

;; special cased (see scrutinizer.scm)
(vector (#(procedure #:pure) vector (#!rest) vector))
(##sys#vector (#(procedure #:pure) ##sys#vector (#!rest) vector))

(vector-length (#(procedure #:clean #:enforce #:foldable) vector-length (vector) fixnum)
	       ((vector) (##sys#size #(1))))
(##sys#vector-length (#(procedure #:clean #:enforce #:foldable) ##sys#vector-length (vector) fixnum)
		     ((vector) (##sys#size #(1))))

(vector->list (forall (a) (#(procedure #:clean #:enforce) vector->list ((vector-of a)) (list-of a))))
(##sys#vector->list (forall (a) (#(procedure #:clean #:enforce) ##sys#vector->list ((vector-of a)) (list-of a))))
(list->vector (forall (a) (#(procedure #:clean #:enforce) list->vector ((list-of a)) (vector-of a))))
(##sys#list->vector (forall (a) (#(procedure #:clean #:enforce) ##sys#list->vector ((list-of a)) (vector-of a))))
(vector-fill! (#(procedure #:enforce) vector-fill! (vector *) undefined))

(procedure? (#(procedure #:pure #:predicate procedure) procedure? (*) boolean))

(vector-copy! (#(procedure #:enforce) vector-copy! (vector vector #!optional fixnum) undefined))

(map (forall (a b) (#(procedure #:enforce) map ((procedure (a #!rest) b) (list-of a) #!rest list) (list-of b))))

(for-each
 (forall (a) (#(procedure #:enforce) for-each ((procedure (a #!rest) . *) (list-of a) #!rest list) undefined)))

(apply (#(procedure #:enforce) apply (procedure #!rest) . *))
(##sys#apply (#(procedure #:enforce) ##sys#apply (procedure #!rest) . *))

(force (procedure force (*) . *)
       (((not (struct promise))) #(1)))

(call-with-current-continuation
 (#(procedure #:enforce) call-with-current-continuation ((procedure (procedure) . *)) . *))

(input-port? (#(procedure #:pure #:predicate input-port) input-port? (*) boolean))
(output-port? (#(procedure #:pure #:predicate output-port) output-port? (*) boolean))

(current-input-port
 (#(procedure #:clean #:enforce) current-input-port (#!optional input-port) input-port)
 ((input-port) (let ((#(tmp1) #(1))) 
		 (let ((#(tmp2) (set! ##sys#standard-input #(tmp1))))
		   #(tmp1))))
 (() ##sys#standard-input))

(current-output-port
 (#(procedure #:clean #:enforce) current-output-port (#!optional output-port) output-port)
 ((output-port) (let ((#(tmp1) #(1)))
		  (let ((#(tmp2) (set! ##sys#standard-output #(tmp1))))
		    #(tmp1))))
 (() ##sys#standard-output))

(call-with-input-file
    (procedure call-with-input-file (string (procedure (input-port) . *) #!rest) . *))

(call-with-output-file
    (procedure call-with-output-file (string (procedure (output-port) . *) #!rest) . *))

(open-input-file (#(procedure #:clean #:enforce) open-input-file (string #!rest symbol) input-port))
(open-output-file (#(procedure #:clean #:enforce) open-output-file (string #!rest symbol) output-port))
(close-input-port (#(procedure #:enforce) close-input-port (input-port) undefined))
(close-output-port (#(procedure #:enforce) close-output-port (output-port) undefined))
(load (procedure load (string #!optional (procedure (*) . *)) undefined))
(read (#(procedure #:enforce) read (#!optional input-port) *))

(eof-object? (#(procedure #:pure #:predicate eof) eof-object? (*) boolean))

(read-char (#(procedure #:enforce) read-char (#!optional input-port) (or eof char)))
(peek-char (#(procedure #:enforce) peek-char (#!optional input-port) (or eof char)))

(write (#(procedure #:enforce) write (* #!optional output-port) undefined))
(display (#(procedure #:enforce) display (* #!optional output-port) undefined))
(write-char (#(procedure #:enforce) write-char (char #!optional output-port) undefined))

;;XXX Yes, that would be nice, but the output-port may be closed
#;(##sys#write-char-0
 (#(procedure #:enforce) ##sys#write-char-0 (char output-port) undefined)
 ((char output-port)
   (let ((#(tmp) #(1)))
     ((##sys#slot (##sys#slot #(tmp) '2) '2) #(tmp) #(2)))))

(newline (#(procedure #:enforce) newline (#!optional output-port) undefined))

(with-input-from-file
    (#(procedure #:enforce) with-input-from-file (string (procedure () . *) #!rest symbol) . *))

(with-output-to-file
    (#(procedure #:enforce) with-output-to-file (string (procedure () . *) #!rest symbol) . *))

(dynamic-wind
    (#(procedure #:enforce) dynamic-wind ((procedure () . *) (procedure () . *) (procedure () . *)) . *))

(values (#(procedure #:clean) values (#!rest values) . *))
(##sys#values (#(procedure #:clean) ##sys#values (#!rest values) . *))

(call-with-values (#(procedure #:enforce) call-with-values ((procedure () . *) procedure) . *)
  (((procedure () *) *) (let ((#(tmp1) #(1)))
			  (let ((#(tmp2) #(2)))
			    (#(tmp2) (#(tmp1)))))))

(##sys#call-with-values
 (#(procedure #:enforce) ##sys#call-with-values ((procedure () . *) procedure) . *)
 (((procedure () *) *) (let ((#(tmp1) #(1)))
			 (let ((#(tmp2) #(2)))
			   (#(tmp2) (#(tmp1)))))))

(eval (procedure eval (* #!optional (struct environment)) . *))
(char-ready? (#(procedure #:enforce) char-ready? (#!optional input-port) boolean))

(real-part (#(procedure #:clean #:enforce #:foldable) real-part (number) (or integer float ratnum))
	   (((or fixnum float bignum ratnum)) #(1))
	   ((cplxnum) (##sys#slot #(1) '1)))

(imag-part (#(procedure #:clean #:enforce #:foldable) imag-part (number) (or integer float ratnum))
	   (((or fixnum bignum ratnum)) (let ((#(tmp) #(1))) '0))
	   ((float) (let ((#(tmp) #(1))) '0.0))
	   ((cplxnum) (##sys#slot #(1) '2)))

(magnitude (#(procedure #:clean #:enforce #:foldable) magnitude (number) number)
	   ((fixnum) (integer) (##core#inline_allocate ("C_a_i_fixnum_abs" 6) #(1)))
	   ((integer) (##core#inline_allocate ("C_s_a_u_i_integer_abs" 6) #(1)))
	   ((float) (float) (##core#inline_allocate ("C_a_i_flonum_abs" 4) #(1)))
	   (((or fixnum float bignum ratnum))
	    (##core#inline_allocate ("C_s_a_i_abs" 10) #(1))))

(angle (#(procedure #:clean #:enforce #:foldable) angle (number) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_atan2" 4) '0.0 #(1)))
       ((fixnum) (##core#inline_allocate
                          ("C_a_i_flonum_atan2" 4)
                          '0.0
                          (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))))
       ((cplxnum) (##core#inline_allocate
		   ("C_a_i_flonum_atan2" 4)
		   (##sys#exact->inexact (##sys#slot #(1) '2))
		   (##sys#exact->inexact (##sys#slot #(1) '1)))))

(numerator (#(procedure #:clean #:enforce #:foldable) numerator ((or float integer ratnum)) (or float integer))
	   ((fixnum) (fixnum) #(1))
	   ((bignum) (bignum) #(1))
	   ((integer) (integer) #(1))
	   ((ratnum) (integer) (##sys#slot #(1) '1)))

(denominator (#(procedure #:clean #:enforce #:foldable) denominator ((or float integer ratnum)) (or float integer))
	     ((integer) (fixnum) (let ((#(tmp) #(1))) '1))
	     ((ratnum) (integer) (##sys#slot #(1) '2)))

(scheme-report-environment 
 (#(procedure #:clean #:enforce) scheme-report-environment (#!optional fixnum) (struct environment)))

(null-environment
 (#(procedure #:clean #:enforce) null-environment (#!optional fixnum) (struct environment)))

(interaction-environment
 (#(procedure #:clean) interaction-environment () (struct environment)))

(port-closed? (#(procedure #:clean #:enforce) port-closed? (port) boolean)
	      ((port) (##sys#slot #(1) '8)))


;; chicken

(abort (procedure abort (*) noreturn))
(##sys#abort (procedure abort (*) noreturn))

(add1 (#(procedure #:clean #:enforce #:foldable) add1 (number) number)
      ((integer) (integer) (##sys#integer-plus #(1) '1))
      ((float) (float) 
       (##core#inline_allocate ("C_a_i_flonum_plus" 4) #(1) '1.0)))

(argc+argv (#(procedure #:clean) argc+argv () fixnum (list-of string) fixnum))
(argv (#(procedure #:clean) argv () (list-of string)))
(integer-length (#(procedure #:clean #:enforce #:foldable) integer-length (integer) fixnum)
		((fixnum) (##core#inline "C_i_fixnum_length" #(1)))
		((*) (##core#inline "C_i_integer_length" #(1))))

(arithmetic-shift (#(procedure #:clean #:enforce #:foldable) arithmetic-shift (integer fixnum) integer)
		  ((integer fixnum) (##sys#integer-shift #(1) #(2))))

(exact-integer-nth-root (#(procedure #:clean #:enforce #:foldable) exact-integer-nth-root (integer integer) integer integer)
		    ((integer integer) (##sys#exact-integer-nth-root/loc 'exact-integer-nth-root #(1) #(2))))

(exact-integer-sqrt (#(procedure #:clean #:enforce #:foldable) exact-integer-sqrt (integer) integer integer)
		    ((integer) (##sys#exact-integer-sqrt #(1))))

(bignum? (#(procedure #:pure #:predicate bignum) bignum? (*) boolean))

(bit-set? (#(procedure #:clean #:enforce #:foldable) bit-set? (integer integer) boolean)
	  ((fixnum fixnum) (##core#inline "C_i_fixnum_bit_setp" #(1) #(2)))
	  ((* *) (##core#inline "C_i_bit_setp" #(1) #(2))))

(bitwise-and (#(procedure #:clean #:enforce #:foldable) bitwise-and (#!rest integer) integer)
           (() '-1)
           ((fixnum) (fixnum) #(1))
           ((integer) #(1))
           ((fixnum fixnum) (fixnum) (##core#inline "C_u_fixnum_and" #(1) #(2)))
           ((integer integer) (##sys#integer-bitwise-and #(1) #(2))))

(bitwise-ior (#(procedure #:clean #:enforce #:foldable) bitwise-ior (#!rest integer) integer)
           (() '0)
           ((fixnum) (fixnum) #(1))
           ((integer) #(1))
           ((fixnum fixnum) (fixnum) (##core#inline "C_u_fixnum_or" #(1) #(2)))
           ((integer integer) (##sys#integer-bitwise-ior #(1) #(2))))

(bitwise-xor (#(procedure #:clean #:enforce #:foldable) bitwise-xor (#!rest integer) integer)
           (() '0)
           ((fixnum) (fixnum) #(1))
           ((integer) #(1))
           ((fixnum fixnum) (fixnum) (##core#inline "C_fixnum_xor" #(1) #(2)))
           ((integer integer) (##sys#integer-bitwise-xor #(1) #(2))))

(bitwise-not (#(procedure #:clean #:enforce #:foldable) bitwise-not (integer) integer)
	     ((integer) (##sys#integer-minus '-1 #(1))))

(blob->string (#(procedure #:clean #:enforce) blob->string (blob) string))

(blob-size (#(procedure #:clean #:enforce #:foldable) blob-size (blob) fixnum)
	   ((blob) (##sys#size #(1))))

(blob? (#(procedure #:pure #:predicate blob) blob? (*) boolean))

(blob=? (#(procedure #:clean #:enforce #:foldable) blob=? (blob blob) boolean))
(build-platform (#(procedure #:pure) build-platform () symbol))
(call/cc (#(procedure #:enforce) call/cc ((procedure (*) . *)) . *))
(case-sensitive (#(procedure #:clean) case-sensitive (#!optional *) *))
(char-name (#(procedure #:clean #:enforce) char-name ((or char symbol) #!optional char) *)) ;XXX -> (or char symbol) ?
(chicken-home (#(procedure #:clean) chicken-home () string))
(chicken-version (#(procedure #:pure) chicken-version (#!optional *) string))
(command-line-arguments (#(procedure #:clean) command-line-arguments (#!optional (list-of string)) (list-of string)))
(condition-predicate (#(procedure #:clean #:enforce) condition-predicate (symbol) (procedure ((struct condition)) boolean)))
(condition-property-accessor (#(procedure #:clean #:enforce) condition-property-accessor (symbol symbol #!optional *) (procedure ((struct condition)) *)))

(condition? (#(procedure #:pure #:predicate (struct condition)) condition? (*) boolean))

(condition->list (#(procedure #:clean #:enforce) condition->list ((struct condition)) (list-of (pair symbol *))))
(continuation-capture (#(procedure #:enforce) continuation-capture ((procedure ((struct continuation)) . *)) *))
(continuation-graft (#(procedure #:clean #:enforce) continuation-graft ((struct continuation) (procedure () . *)) *))
(continuation-return (#(procedure #:enforce) continuation-return (procedure #!rest) . *)) ;XXX make return type more specific?

(continuation? (#(procedure #:pure #:predicate (struct continuation)) continuation? (*) boolean))

(copy-read-table (#(procedure #:clean #:enforce) copy-read-table ((struct read-table)) (struct read-table)))

(cplxnum? (#(procedure #:pure #:predicate cplxnum) cplxnum? (*) boolean))

(cpu-time (#(procedure #:clean) cpu-time () fixnum fixnum))

(current-error-port
 (#(procedure #:clean #:enforce) current-error-port (#!optional output-port) output-port)
 ((output-port) (let ((#(tmp1) #(1))) 
		  (let ((#(tmp2) (set! ##sys#standard-error #(tmp1))))
		    #(tmp1))))
 (() ##sys#standard-error))

(current-exception-handler
 (#(procedure #:clean #:enforce) current-exception-handler (#!optional (procedure (*) noreturn)) procedure)
 ((procedure) (let ((#(tmp1) #(1))) 
		(let ((#(tmp2) (set! ##sys#current-exception-handler #(tmp1))))
		  #(tmp1))))
 (() ##sys#current-exception-handler))

(current-gc-milliseconds (#(procedure #:clean) current-gc-milliseconds () integer))
(current-milliseconds (#(procedure #:clean) current-milliseconds () integer))

(current-read-table
 (#(procedure #:clean) current-read-table (#!optional (struct read-table)) (struct read-table)))

(current-seconds (#(procedure #:clean) current-seconds () integer))
(define-reader-ctor (#(procedure #:clean #:enforce) define-reader-ctor (symbol procedure) undefined))
(delete-file (#(procedure #:clean #:enforce) delete-file (string) string))
(enable-warnings (#(procedure #:clean) enable-warnings (#!optional *) *))

(equal=? (#(procedure #:clean #:foldable) equal=? (* *) boolean)
	 ((fixnum fixnum) (eq? #(1) #(2)))
	 (((or symbol char eof null undefined) *) (eq? #(1) #(2)))
	 ((* (or symbol char eof null undefined)) (eq? #(1) #(2)))
	 ((number number) (= #(1) #(2))))

(er-macro-transformer
 (#(procedure #:clean #:enforce) 
  er-macro-transformer
  ((procedure (* (procedure (*) *) (procedure (* *) *)) *))
  (struct transformer)))

(errno (#(procedure #:clean) errno () fixnum))
(error (procedure error (* #!rest) noreturn))
(##sys#error (procedure ##sys#error (* #!rest) noreturn))
(##sys#signal-hook (procedure ##sys#signal-hook (* #!rest) noreturn))
(exit (procedure exit (#!optional fixnum) noreturn))
(exit-handler (#(procedure #:clean #:enforce) exit-handler (#!optional (procedure (fixnum) . *)) procedure))
(expand (procedure expand (* #!optional list) *))
(extension-information (#(procedure #:clean) extension-information (symbol) *))
(feature? (#(procedure #:clean) feature? (#!rest symbol) boolean))
(features (#(procedure #:clean) features () (list-of symbol)))
(file-exists? (#(procedure #:clean #:enforce) file-exists? (string) (or false string)))
(directory-exists? (#(procedure #:clean #:enforce) directory-exists? (string) (or false string)))

(nan? (#(procedure #:clean #:enforce #:foldable) nan? (number) boolean)
      (((or integer ratnum)) (let ((#(tmp) #(1))) '#f))
      ((float) (##core#inline "C_u_i_flonum_nanp" #(1)))
      ((*) (##core#inline "C_i_nanp" #(1))))

(infinite? (#(procedure #:clean #:enforce #:foldable) infinite? (number) boolean)
	   (((or integer ratnum)) (let ((#(tmp) #(1))) '#f))
	   ((float) (##core#inline "C_u_i_flonum_infinitep" #(1)))
	   ((*) (##core#inline "C_i_infinitep" #(1))))

(finite? (#(procedure #:clean #:enforce #:foldable) finite? (number) boolean)
	 (((or integer ratnum)) (let ((#(tmp) #(1))) '#t))
	 ((float) (##core#inline "C_u_i_flonum_finitep" #(1)))
	 ((*) (##core#inline "C_i_finitep" #(1))))

(fixnum-bits fixnum)
(fixnum-precision fixnum)

(fixnum? (#(procedure #:pure #:predicate fixnum) fixnum? (*) boolean))

(flonum-decimal-precision fixnum)
(flonum-epsilon float)
(flonum-maximum-decimal-exponent fixnum)
(flonum-maximum-exponent fixnum)
(flonum-minimum-decimal-exponent fixnum)
(flonum-minimum-exponent fixnum)
(flonum-precision fixnum)
(flonum-print-precision (#(procedure #:clean #:enforce) (#!optional fixnum) fixnum))
(flonum-radix fixnum)

(flonum? (#(procedure #:pure #:predicate float) flonum? (*) boolean))

(flush-output (#(procedure #:enforce) flush-output (#!optional output-port) undefined))

(foldl (forall (a b) (#(procedure #:enforce) foldl ((procedure (a b) a) a (list-of b)) a)))
(foldr (forall (a b) (#(procedure #:enforce) foldr ((procedure (a b) b) b (list-of a)) b)))

(force-finalizers (procedure force-finalizers () undefined))

(fp- (#(procedure #:clean #:enforce #:foldable) fp- (float float) float)
     ((float float) (##core#inline_allocate ("C_a_i_flonum_difference" 4) #(1) #(2)) ))

(fp* (#(procedure #:clean #:enforce #:foldable) fp* (float float) float)
     ((float float) (##core#inline_allocate ("C_a_i_flonum_times" 4) #(1) #(2)) ))

(fp/ (#(procedure #:clean #:enforce #:foldable) fp/ (float float) float)
     ((float float) (##core#inline_allocate ("C_a_i_flonum_quotient" 4) #(1) #(2)) ))

(fpgcd (#(procedure #:clean #:enforce #:foldable) fpgcd (float float) float)
       ((float float) (##core#inline_allocate ("C_a_i_flonum_gcd" 4) #(1) #(2)) ))

(fp+ (#(procedure #:clean #:enforce #:foldable) fp+ (float float) float)
     ((float float) (##core#inline_allocate ("C_a_i_flonum_plus" 4) #(1) #(2)) ))

(fp< (#(procedure #:clean #:enforce #:foldable) fp< (float float) boolean)
     ((float float) (##core#inline "C_flonum_lessp" #(1) #(2)) ))

(fp<= (#(procedure #:clean #:enforce #:foldable) fp<= (float float) boolean)
      ((float float) (##core#inline "C_flonum_less_or_equal_p" #(1) #(2)) ))

(fp= (#(procedure #:clean #:enforce #:foldable) fp= (float float) boolean)
     ((float float) (##core#inline "C_flonum_equalp" #(1) #(2)) ))

(fp> (#(procedure #:clean #:enforce #:foldable) fp> (float float) boolean)
     ((float float) (##core#inline "C_flonum_greaterp" #(1) #(2)) ))

(fp>= (#(procedure #:clean #:enforce #:foldable) fp>= (float float) boolean)
      ((float float) (##core#inline "C_flonum_greater_or_equal_p" #(1) #(2)) ))

(fpabs (#(procedure #:clean #:enforce #:foldable) fpabs (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_abs" 4) #(1) )))

(fpacos (#(procedure #:clean #:enforce #:foldable) fpacos (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_acos" 4) #(1) )))

(fpasin (#(procedure #:clean #:enforce #:foldable) fpasin (float) float)
	((float) (##core#inline_allocate ("C_a_i_flonum_asin" 4) #(1) )))

(fpatan (#(procedure #:clean #:enforce #:foldable) fpatan (float) float)
	((float) (##core#inline_allocate ("C_a_i_flonum_atan" 4) #(1) )))

(fpatan2 (#(procedure #:clean #:enforce #:foldable) fpatan2 (float float) float)
	 ((float float) (##core#inline_allocate ("C_a_i_flonum_atan2" 4)
						#(1) #(2))))
(fpceiling (#(procedure #:clean #:enforce #:foldable) fpceiling (float) float)
	   ((float) (##core#inline_allocate ("C_a_i_flonum_ceiling" 4) #(1) )))

(fpcos (#(procedure #:clean #:enforce #:foldable) fpcos (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_cos" 4) #(1) )))

(fpexp (#(procedure #:clean #:enforce #:foldable) fpexp (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_exp" 4) #(1) )))

(fpexpt (#(procedure #:clean #:enforce #:foldable) fpexpt (float float) float)
	((float float) (##core#inline_allocate ("C_a_i_flonum_expt" 4)
					       #(1) #(2))))

(fpfloor (#(procedure #:clean #:enforce #:foldable) fpfloor (float) float)
	 ((float) (##core#inline_allocate ("C_a_i_flonum_floor" 4) #(1) )))

(fpinteger? (#(procedure #:clean #:enforce #:foldable) fpinteger? (float) boolean)
	    ((float) (##core#inline "C_u_i_fpintegerp" #(1) )))

(fplog (#(procedure #:clean #:enforce #:foldable) fplog (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_log" 4) #(1) )))

(fpmax (#(procedure #:clean #:enforce #:foldable) fpmax (float float) float)
       ((float float) (##core#inline "C_i_flonum_max" #(1) #(2))))

(fpmin (#(procedure #:clean #:enforce #:foldable) fpmin (float float) float)
       ((float float) (##core#inline "C_i_flonum_min" #(1) #(2))))

(fpneg (#(procedure #:clean #:enforce #:foldable) fpneg (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_negate" 4) #(1) )))

(fpround (#(procedure #:clean #:enforce #:foldable) fpround (float) float)
	 ((float) (##core#inline_allocate ("C_a_i_flonum_round" 4) #(1) )))

(fpsin (#(procedure #:clean #:enforce #:foldable) fpsin (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_sin" 4) #(1) )))

(fpsqrt (#(procedure #:clean #:enforce #:foldable) fpsqrt (float) float)
	((float) (##core#inline_allocate ("C_a_i_flonum_sqrt" 4) #(1) )))

(fptan (#(procedure #:clean #:enforce #:foldable) fptan (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_tan" 4) #(1) )))

(fptruncate (#(procedure #:clean #:enforce #:foldable) fptruncate (float) float)
	    ((float) (##core#inline_allocate ("C_a_i_flonum_truncate" 4) #(1) )))

;;XXX should these be enforcing?
(fx- (#(procedure #:clean #:foldable) fx- (fixnum fixnum) fixnum))
(fx* (#(procedure #:clean #:foldable) fx* (fixnum fixnum) fixnum))
(fx/ (#(procedure #:clean #:foldable) fx/ (fixnum fixnum) fixnum))
(fxgcd (#(procedure #:clean #:foldable) fxgcd (fixnum fixnum) fixnum))
(fx+ (#(procedure #:clean #:foldable) fx+ (fixnum fixnum) fixnum))
(fx< (#(procedure #:clean #:foldable) fx< (fixnum fixnum) boolean))
(fx<= (#(procedure #:clean #:foldable) fx<= (fixnum fixnum) boolean))
(fx= (#(procedure #:clean #:foldable) fx= (fixnum fixnum) boolean))
(fx> (#(procedure #:clean #:foldable) fx> (fixnum fixnum) boolean))
(fx>= (#(procedure #:clean #:foldable) fx>= (fixnum fixnum) boolean))
(fxand (#(procedure #:clean #:foldable) fxand (fixnum fixnum) fixnum))
(fxeven? (#(procedure #:clean #:foldable) fxeven? (fixnum) boolean))
(fxior (#(procedure #:clean #:foldable) fxior (fixnum fixnum) fixnum))
(fxmax (#(procedure #:clean #:foldable) fxmax (fixnum fixnum) fixnum))
(fxmin (#(procedure #:clean #:foldable) fxmin (fixnum fixnum) fixnum))
(fxmod (#(procedure #:clean #:foldable) fxmod (fixnum fixnum) fixnum))
(fxrem (#(procedure #:clean #:foldable) fxrem (fixnum fixnum) fixnum))
(fxneg (#(procedure #:clean #:foldable) fxneg (fixnum) fixnum))
(fxnot (#(procedure #:clean #:foldable) fxnot (fixnum) fixnum))
(fxodd? (#(procedure #:clean #:foldable) fxodd? (fixnum) boolean))
(fxshl (#(procedure #:clean #:foldable) fxshl (fixnum fixnum) fixnum))
(fxshr (#(procedure #:clean #:foldable) fxshr (fixnum fixnum) fixnum))
(fxxor (#(procedure #:clean #:foldable) fxxor (fixnum fixnum) fixnum))
(fxlen (#(procedure #:clean #:foldable) fxlen (fixnum) fixnum))
(gc (#(procedure #:clean) gc (#!optional *) fixnum))
(gensym (#(procedure #:clean) gensym (#!optional (or string symbol)) symbol))

(get (#(procedure #:clean #:enforce) get (symbol symbol #!optional *) *)
     ((symbol symbol *) (##core#inline "C_i_getprop" #(1) #(2) #(3))))

(get-call-chain (#(procedure #:clean #:enforce) get-call-chain (#!optional fixnum (struct thread)) (list-of vector)))
(get-condition-property (#(procedure #:clean #:enforce) get-condition-property ((struct condition) symbol symbol #!optional *) *))
(get-environment-variable (#(procedure #:clean #:enforce) get-environment-variable (string) *))
(get-keyword (#(procedure #:clean #:enforce) get-keyword (symbol list #!optional *) *))
(get-output-string (#(procedure #:clean #:enforce) get-output-string (output-port) string))
(get-properties (#(procedure #:clean #:enforce) get-properties (symbol list) symbol * list))

(getter-with-setter
 (#(procedure #:clean #:enforce)
  getter-with-setter
  ((procedure (#!rest) *) (procedure (* #!rest) . *) #!optional string)
  procedure))

(implicit-exit-handler
 (#(procedure #:clean #:enforce) implicit-exit-handler (#!optional (procedure () . *)) procedure))

(ir-macro-transformer
 (#(procedure #:clean #:enforce)
  ir-macro-transformer
  ((procedure (* (procedure (*) *) (procedure (* *) *)) *))
  (struct transformer)))

(keyword->string (#(procedure #:clean #:enforce) keyword->string (symbol) string))
(keyword-style (#(procedure #:clean) keyword-style (#!optional symbol) symbol))
(keyword? (#(procedure #:pure) keyword? (*) boolean))
(load-library (#(procedure #:enforce) load-library (symbol #!optional string) undefined))
(load-relative (#(procedure #:enforce) load-relative (string #!optional (procedure (*) . *)) undefined))
(load-verbose (#(procedure #:clean) load-verbose (#!optional *) *))
(machine-byte-order (#(procedure #:pure) machine-byte-order () symbol))
(machine-type (#(procedure #:pure) machine-type () symbol))

(make-blob (#(procedure #:clean #:enforce) make-blob (fixnum) blob)
	   ((fixnum) (##sys#make-blob #(1))))

(make-composite-condition (#(procedure #:clean #:enforce) make-composite-condition (#!rest (struct condition)) (struct condition)))
(make-parameter (#(procedure #:clean #:enforce) make-parameter (* #!optional procedure) procedure))
(make-property-condition (#(procedure #:clean #:enforce) make-property-condition (symbol #!rest *) (struct condition)))
(maximum-flonum float)
(memory-statistics (#(procedure #:clean) memory-statistics () (vector-of fixnum)))
(minimum-flonum float)
(module-environment (#(procedure #:clean #:enforce) module-environment (symbol #!optional symbol) (struct environment)))
(most-negative-fixnum fixnum)
(most-positive-fixnum fixnum)
(on-exit (#(procedure #:clean #:enforce) on-exit ((procedure () . *)) undefined))
(open-input-string (#(procedure #:clean #:enforce) open-input-string (string #!rest) input-port))
(open-output-string (#(procedure #:clean) open-output-string (#!rest) output-port))
(parentheses-synonyms (#(procedure #:clean) parentheses-synonyms (#!optional *) *))

(port-name (#(procedure #:clean #:enforce) port-name (#!optional port) *)
	   ((port) (##sys#slot #(1) '3)))

(port-position (#(procedure #:clean #:enforce) port-position (#!optional port) fixnum fixnum))

(port? (#(procedure #:pure #:predicate (or input-port output-port)) port? (*) boolean))

(print (procedure print (#!rest *) undefined))
(print-call-chain (#(procedure #:clean #:enforce) print-call-chain (#!optional output-port fixnum * string) undefined))
(print-error-message (#(procedure #:clean #:enforce) print-error-message (* #!optional output-port string) undefined))
(print* (procedure print* (#!rest) undefined))
(procedure-information (#(procedure #:clean #:enforce) procedure-information (procedure) *))
(program-name (#(procedure #:clean #:enforce) program-name (#!optional string) string))
(promise? (#(procedure #:pure #:predicate (struct promise)) promise? (*) boolean))

(make-promise (#(procedure #:enforce) make-promise (*) (struct promise))
              (((struct promise)) #(1)))

(put! (#(procedure #:clean #:enforce) put! (symbol symbol *) undefined)
      ((symbol symbol *)
       (##core#inline_allocate ("C_a_i_putprop" 8) #(1) #(2) #(3))))

(quit (procedure quit (#!optional *) noreturn))

(ratnum? (#(procedure #:pure #:predicate ratnum) ratnum? (*) boolean))

(register-feature! (#(procedure #:clean #:enforce) register-feature! (#!rest symbol) undefined))
(remprop! (#(procedure #:clean #:enforce) remprop! (symbol symbol) undefined))
(rename-file (#(procedure #:clean #:enforce) rename-file (string string) string))
(repl (#(procedure #:enforce) repl (#!optional (procedure (*) . *)) undefined))
(repl-prompt (#(procedure #:clean #:enforce) repl-prompt (#!optional (procedure () string)) procedure))
(repository-path (#(procedure #:clean) repository-path (#!optional *) *))
(require (#(procedure #:clean) require (#!rest (or string symbol)) undefined))
(reset (procedure reset () noreturn))
(reset-handler (#(procedure #:clean #:enforce) reset-handler (#!optional (procedure () . *)) procedure))
(return-to-host (procedure return-to-host () . *))
(reverse-list->string (#(procedure #:clean #:enforce) reverse-list->string ((list-of char)) string))
(set-finalizer! (#(procedure #:clean #:enforce) set-finalizer! (* (procedure (*) . *)) *))
(set-gc-report! (#(procedure #:clean) set-gc-report! (*) undefined))

(set-parameterized-read-syntax!
 (#(procedure #:clean #:enforce) set-parameterized-read-syntax!
  (char (or false (procedure (input-port fixnum) . *)))
  undefined))

(set-port-name! (#(procedure #:clean #:enforce) set-port-name! (port string) undefined)
		((port string) (##sys#setslot #(1) '3 #(2))))

(set-read-syntax!
 (#(procedure #:clean #:enforce) set-read-syntax!
  (char (or false (procedure (input-port) . *)))
  undefined))

(set-sharp-read-syntax!
 (#(procedure #:clean #:enforce) set-sharp-read-syntax!
  (char (or false (procedure (input-port) . *))) undefined))

(setter (#(procedure #:clean #:enforce) setter (procedure) procedure))
(signal (procedure signal (*) . *))

(signum (#(procedure #:clean #:enforce) signum (number) (or fixnum float cplxnum))
	((fixnum) (fixnum) (##core#inline "C_i_fixnum_signum" #(1)))
	((integer) (fixnum) (##core#inline "C_u_i_integer_signum" #(1)))
	((float) (float)
	 (##core#inline_allocate ("C_a_u_i_flonum_signum" 4) #(1)))
	((ratnum) (fixnum)
	 (##core#inline "C_u_i_integer_signum" (##sys#slot #(1) '1)))
	((cplxnum) ((or float cplxnum)) (##sys#extended-signum #(1))))

(software-type (#(procedure #:pure) software-type () symbol))
(software-version (#(procedure #:pure) software-version () symbol))
(string->blob (#(procedure #:clean #:enforce) string->blob (string) blob))
(string->keyword (#(procedure #:clean #:enforce) string->keyword (string) symbol))
(string->uninterned-symbol (#(procedure #:clean #:enforce) string->uninterned-symbol (string) symbol))
(strip-syntax (#(procedure #:clean) strip-syntax (*) *))

(sub1 (#(procedure #:clean #:enforce #:foldable) sub1 (number) number)
      ((integer) (integer) (##sys#integer-minus #(1) '1))
      ((float) (float)
       (##core#inline_allocate ("C_a_i_flonum_difference" 4) #(1) '1.0)))

(subvector (forall (a) (#(procedure #:clean #:enforce) subvector ((vector-of a) fixnum #!optional fixnum) (vector-of a))))
(symbol-escape (#(procedure #:clean) symbol-escape (#!optional *) *))

(symbol-plist (#(procedure #:clean #:enforce) symbol-plist (symbol) list)
	      ((symbol) (##sys#slot #(1) '2)))

(syntax-error (procedure syntax-error (* #!rest) noreturn))
(system (#(procedure #:clean #:enforce) system (string) fixnum))
(unregister-feature! (#(procedure #:clean #:enforce) unregister-feature! (#!rest symbol) undefined))
(vector-resize
 (forall (a b) (#(procedure #:clean #:enforce) vector-resize ((vector-of a) fixnum #!optional b)
	       (vector-of (or a b)))))
(void (#(procedure #:pure) void (#!rest) undefined))
(##sys#void (#(procedure #:pure) void (#!rest) undefined))
(warning (procedure warning (* #!rest) undefined))

(with-exception-handler
 (#(procedure #:enforce) with-exception-handler ((procedure (*) . *) (procedure () . *)) . *))

;; chicken (internal)

(##sys#foreign-char-argument (#(procedure #:clean #:enforce) ##sys#foreign-char-argument (char) char)
			     ((char) #(1)))
(##sys#foreign-fixnum-argument (#(procedure #:clean #:enforce) ##sys#foreign-fixnum-argument (fixnum) fixnum)
			       ((fixnum) #(1)))
(##sys#foreign-flonum-argument (#(procedure #:clean #:enforce) ##sys#foreign-flonum-argument (number) number)
			       ((float) #(1)))
(##sys#foreign-string-argument (#(procedure #:clean #:enforce) ##sys#foreign-string-argument (string) string)
			       ((string) #(1)))
(##sys#foreign-symbol-argument (#(procedure #:clean #:enforce) ##sys#foreign-symbol-argument (symbol) symbol)
			       ((symbol) #(1)))
(##sys#foreign-pointer-argument (#(procedure #:clean #:enforce) ##sys#foreign-pointer-argument ((or pointer false)) pointer)
				((pointer) #(1)))

(##sys#check-blob (#(procedure #:clean #:enforce) ##sys#check-blob (blob #!optional *) *)
		  ((blob) (let ((#(tmp) #(1))) '#t))
		  ((blob *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-pair (#(procedure #:clean #:enforce) ##sys#check-pair (pair #!optional *) *)
		  ((pair) (let ((#(tmp) #(1))) '#t))
		  ((pair *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-list (#(procedure #:clean #:enforce) ##sys#check-list (list #!optional *) *)
		  (((or null pair list)) (let ((#(tmp) #(1))) '#t))
		  (((or null pair list) *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-string (#(procedure #:clean #:enforce) ##sys#check-string (string #!optional *) *)
		    ((string) (let ((#(tmp) #(1))) '#t))
		    ((string) * (let ((#(tmp) #(1))) '#t)))
(##sys#check-number (#(procedure #:clean #:enforce) ##sys#check-number (number #!optional *) *)
		    ((number) (let ((#(tmp) #(1))) '#t))
		    ((number *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-exact (#(procedure #:clean #:enforce) ##sys#check-exact (fixnum #!optional *) *)
		   ((fixnum) (let ((#(tmp) #(1))) '#t))
		   ((fixnum *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-inexact (#(procedure #:clean #:enforce) ##sys#check-inexact (float #!optional *) *)
		     ((float) (let ((#(tmp) #(1))) '#t))
		     ((float *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-symbol (#(procedure #:clean #:enforce) ##sys#check-symbol (symbol #!optional *) *)
		    ((symbol) (let ((#(tmp) #(1))) '#t))
		    ((symbol *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-vector (#(procedure #:clean #:enforce) ##sys#check-vector (vector #!optional *) *)
		    ((vector) (let ((#(tmp) #(1))) '#t))
		    ((vector *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-char (#(procedure #:clean #:enforce) ##sys#check-char (char #!optional *) *)
		  ((char) (let ((#(tmp) #(1))) '#t))
		  ((char *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-boolean (#(procedure #:clean #:enforce) ##sys#check-boolean (boolean #!optional *) *)
		     ((boolean) (let ((#(tmp) #(1))) '#t))
		     ((boolean *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-locative (#(procedure #:clean #:enforce) ##sys#check-locative (locative #!optional *) *)
		      ((locative) (let ((#(tmp) #(1))) '#t))
		      ((locative *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-closure (#(procedure #:clean #:enforce) ##sys#check-closure (procedure #!optional *) *)
		     ((procedure) (let ((#(tmp) #(1))) '#t))
		     ((procedure *) (let ((#(tmp) #(1))) '#t)))

(##sys#check-port 
 (#(procedure #:clean #:enforce) ##sys#check-port ((or input-port output-port) #!optional *)
  *)
 (((or input-port output-port)) (let ((#(tmp) #(1))) '#t))
 (((or input-port output-port) *) (let ((#(tmp) #(1))) '#t)))

(##sys#check-input-port
 (#(procedure #:clean #:enforce) ##sys#check-input-port (input-port * #!optional *) *)
 ((* *) (##core#inline "C_i_check_port" #(1) '#t #(2)))
 ((* * *) (##core#inline "C_i_check_port_2" #(1) '#t #(2) #(3))))

(##sys#check-output-port
 (#(procedure #:clean #:enforce) ##sys#check-output-port (output-port * #!optional *) *)
 ((* *) (##core#inline "C_i_check_port" #(1) '#f #(2)))
 ((* * *) (##core#inline "C_i_check_port_2" #(1) '#f #(2) #(3))))

(##sys#check-open-port
 (#(procedure #:clean #:enforce) ##sys#check-open-port ((or input-port output-port) #!optional *) *)
 ((*) (##core#inline "C_i_check_port" #(1) '0 '#t))
 ((* *) (##core#inline "C_i_check_port_2" #(1) '0 '#t #(2))))

(##sys#slot (#(procedure #:enforce) ##sys#slot (* fixnum) *))

(##sys#setslot (#(procedure #:enforce) ##sys#setslot (* fixnum *) *)
	       #;((* fixnum immediate) (##sys#setislot #(1) #(2) #(3)))) ; too dangerous

(##sys#size (#(procedure #:pure #:foldable) ##sys#size (*) fixnum))

(##sys#standard-input input-port)
(##sys#standard-output output-port)
(##sys#standard-error output-port)


;; data-structures

(->string (procedure ->string (*) string)
	  ((string) #(1)))

(alist-ref (#(procedure #:clean #:enforce #:foldable) alist-ref (* (list-of pair) #!optional (procedure (* *) *) *) *))
(alist-update! (#(procedure #:enforce) alist-update! (* * (list-of pair) #!optional (procedure (* *) *)) *))
(alist-update (#(procedure #:clean #:enforce #:foldable) alist-update (* * (list-of pair) #!optional (procedure (* *) *) *) *))

(any? (#(procedure #:pure #:foldable) any? (*) boolean)
      ((*) (let ((#(tmp) #(1))) '#t)))

(atom? (#(procedure #:pure #:foldable) atom? (*) boolean)
       ((pair) (let ((#(tmp) #(1))) '#f))
       (((not (or pair list))) (let ((#(tmp) #(1))) '#t)))

(butlast (forall (a) (#(procedure #:clean #:enforce) butlast ((pair a *)) (list-of a))))
(chop (forall (a) (#(procedure #:clean #:enforce) chop ((list-of a) fixnum) (list-of a))))
(complement (#(procedure #:clean #:enforce) complement ((procedure (#!rest) *)) (procedure (#!rest) boolean)))
(compose (#(procedure #:clean #:enforce) compose (#!rest procedure) procedure))
(compress (forall (a) (#(procedure #:clean #:enforce) compress (list (list-of a)) (list-of a))))
(conc (procedure conc (#!rest) string))
(conjoin (#(procedure #:clean #:enforce) conjoin (#!rest (procedure (*) *)) (procedure (*) *)))
(constantly (forall (a) (#(procedure #:pure) constantly (a) (procedure (#!rest) a))))
(disjoin (#(procedure #:clean #:enforce) disjoin (#!rest (procedure (*) *)) (procedure (*) *)))
(each (#(procedure #:clean #:enforce) each (#!rest procedure) procedure))
(flatten (#(procedure #:clean #:enforce) flatten (#!rest *) list))
(flip (#(procedure #:clean #:enforce) flip ((procedure (* *) . *)) (procedure (* *) . *)))
(identity (forall (a) (#(procedure #:pure #:foldable) identity (a) a)))
(intersperse (#(procedure #:clean #:enforce) intersperse (list *) list))
(join (#(procedure #:clean #:enforce) join ((list-of list) #!optional list) list))
(list-of? (#(procedure #:clean #:enforce) list-of? ((procedure (*) *)) (procedure (list) boolean)))

(merge 
 (forall (e)
	 (#(procedure #:enforce) merge ((list-of e) (list-of e) (procedure (e e) *)) (list-of e))))

(merge!
 (forall (e)
	 (#(procedure #:enforce) merge! ((list-of e) (list-of e) (procedure (e e) *)) (list-of e))))

(o (#(procedure #:clean #:enforce) o (#!rest (procedure (*) *)) (procedure (*) *)))

(rassoc (#(procedure #:clean #:enforce #:foldable) rassoc (* (list-of pair) #!optional (procedure (* *) *)) *))
(reverse-string-append (#(procedure #:clean #:enforce) reverse-string-append ((list-of string)) string))

(sort
 (forall (e (s (or (vector-of e) (list-of e))))
	 (#(procedure #:enforce) 
	  sort
	  (s (procedure (e e) *)) 
	  s)))

(sort!
 (forall (e (s (or (vector-of e) (list-of e))))
	 (#(procedure #:enforce) 
	  sort
	  (s (procedure (e e) *)) 
	  s)))

(sorted? (#(procedure #:enforce) sorted? ((or list vector) (procedure (* *) *)) boolean))
(topological-sort (#(procedure #:enforce) topological-sort ((list-of list) (procedure (* *) *)) list))
(string-chomp (#(procedure #:clean #:enforce) string-chomp (string #!optional string) string))
(string-chop (#(procedure #:clean #:enforce) string-chop (string fixnum) (list-of string)))
(string-compare3 (#(procedure #:clean #:enforce) string-compare3 (string string) fixnum))
(string-compare3-ci (#(procedure #:clean #:enforce) string-compare3-ci (string string) fixnum))
(string-intersperse (#(procedure #:clean #:enforce) string-intersperse ((list-of string) #!optional string) string))
(string-split (#(procedure #:clean #:enforce) string-split (string #!optional string *) (list-of string)))
(string-translate (#(procedure #:clean #:enforce) string-translate (string * #!optional *) string))
(string-translate* (#(procedure #:clean #:enforce) string-translate* (string (list-of (pair string string))) string))
(substring-ci=? (#(procedure #:clean #:enforce #:foldable) substring-ci=? (string string #!optional fixnum fixnum fixnum) boolean))

(substring-index (#(procedure #:clean #:enforce #:foldable) substring-index (string string #!optional fixnum) (or false fixnum))
		 ((* *) (##sys#substring-index #(1) #(2) '0))
		 ((* * *) (##sys#substring-index #(1) #(2) #(3))))

(##sys#substring-index
 (#(procedure #:clean #:enforce #:foldable) ##sys#substring-index
  (string string fixnum)
  (or false fixnum)))

(substring-index-ci (#(procedure #:clean #:enforce #:foldable) substring-index-ci (string string #!optional fixnum) (or false fixnum))
		    ((* *) (##sys#substring-index-ci #(1) #(2) '0))
		    ((* * *) (##sys#substring-index-ci #(1) #(2) #(3))))

(##sys#substring-index-ci
 (#(procedure #:clean #:enforce #:foldable) ##sys#substring-index-ci
  (string string fixnum)
  (or false fixnum)))

(substring=? (#(procedure #:clean #:enforce #:foldable) substring=? (string string #!optional fixnum fixnum fixnum) boolean))
(tail? (#(procedure #:clean) tail? (* *) boolean))


;; extras

(format (procedure format (#!rest) *))
(fprintf (#(procedure #:enforce) fprintf (output-port string #!rest) undefined))
(pp (#(procedure #:enforce) pp (* #!optional output-port) undefined))
(pretty-print (#(procedure #:enforce) pretty-print (* #!optional output-port) undefined))
(pretty-print-width (#(procedure #:clean) pretty-print-width (#!optional fixnum) *))
(printf (#(procedure #:enforce) printf (string #!rest) undefined))
(random (#(procedure #:clean #:enforce) random (fixnum) fixnum))
(randomize (#(procedure #:clean #:enforce) randomize (#!optional fixnum) undefined))
(read-buffered (#(procedure #:enforce) read-buffered (#!optional input-port) string))
(read-byte (#(procedure #:enforce) read-byte (#!optional input-port) *))
(read-file (#(procedure #:enforce) read-file (#!optional (or input-port string) (procedure (input-port) *) fixnum) list))
(read-line (#(procedure #:enforce) read-line (#!optional input-port (or false fixnum)) (or eof string)))
(read-lines (#(procedure #:enforce) read-lines (#!optional (or input-port string) fixnum) (list-of string)))
(read-string (#(procedure #:enforce) read-string (#!optional * input-port) string))
(read-string! (#(procedure #:enforce) read-string! ((or fixnum false) string #!optional input-port fixnum) fixnum))
(read-token (#(procedure #:enforce) read-token ((procedure (char) *) #!optional input-port) string))
(sprintf (#(procedure #:enforce #:foldable) sprintf (string #!rest) string))
(write-byte (#(procedure #:enforce) write-byte (fixnum #!optional output-port) undefined))
(write-line (#(procedure #:enforce) write-line (string #!optional output-port) undefined))
(write-string (#(procedure #:enforce) write-string (string #!optional * output-port) undefined))


;; files

(delete-file* (#(procedure #:clean #:enforce) delete-file* (string) *))
(file-copy (#(procedure #:clean #:enforce) file-copy (string string #!optional * fixnum) fixnum))
(file-move (#(procedure #:clean #:enforce) file-move (string string #!optional * fixnum) fixnum))
(make-pathname (#(procedure #:clean #:enforce) make-pathname ((or string (list-of string) false) #!optional (or string false) (or string false)) string))
(directory-null? (#(procedure #:clean #:enforce) directory-null? (string) boolean))
(make-absolute-pathname (#(procedure #:clean #:enforce) make-absolute-pathname (* #!optional string string) string))
(create-temporary-directory (#(procedure #:clean #:enforce) create-temporary-directory () string))
(create-temporary-file (#(procedure #:clean #:enforce) create-temporary-file (#!optional string) string))
(decompose-directory (#(procedure #:clean #:enforce) decompose-directory (string) * * *))
(decompose-pathname (#(procedure #:clean #:enforce) decompose-pathname (string) * * *))
(absolute-pathname? (#(procedure #:clean #:enforce) absolute-pathname? (string) boolean))
(pathname-directory (#(procedure #:clean #:enforce) pathname-directory (string) *))
(pathname-extension (#(procedure #:clean #:enforce) pathname-extension (string) *))
(pathname-file (#(procedure #:clean #:enforce) pathname-file (string) *))
(pathname-replace-directory (#(procedure #:clean #:enforce) pathname-replace-directory (string string) string))
(pathname-replace-extension (#(procedure #:clean #:enforce) pathname-replace-extension (string string) string))
(pathname-replace-file (#(procedure #:clean #:enforce) pathname-replace-file (string string) string))
(pathname-strip-directory (#(procedure #:clean #:enforce) pathname-strip-directory (string) string))
(pathname-strip-extension (#(procedure #:clean #:enforce) pathname-strip-extension (string) string))
(normalize-pathname (#(procedure #:clean #:enforce) normalize-pathname (string #!optional symbol) string))


;; irregex

(irregex (#(procedure #:clean) irregex (#!rest) (struct regexp)))

;; Both of these DFA accessors return either #f or a DFA vector.
;; TODO: Should we spec out the entire DFA type layout?  It's plenty complex, so we don't
;; want to be specifying this for all procedures accepting a DFA!
;; A DFA looks like a vector of lists;
;; the car of each list is a number (for init-state), false or an alist;
;; the cdr is a list of alists, which contains a char (or vector) and two alists
;; These alists have types themselves, of course...
(irregex-dfa (#(procedure #:clean #:enforce) irregex-dfa ((struct regexp)) (or false vector))
	     (((struct regexp)) (##sys#slot #(1) '1)))

(irregex-dfa/search (#(procedure #:clean #:enforce) irregex-dfa/search ((struct regexp)) (or false vector))
		    (((struct regexp)) (##sys#slot #(1) '2)))

;; Procedure type returned by irregex-nfa is a matcher type (it is misnamed)
;; which is another complex procedure type.
(irregex-nfa (#(procedure #:clean #:enforce) irregex-nfa ((struct regexp)) (or false procedure))
	     (((struct regexp)) (##sys#slot #(1) '3)))

(irregex-flags (#(procedure #:clean #:enforce) irregex-flags ((struct regexp)) fixnum)
	       (((struct regexp)) (##sys#slot #(1) '4)))

(irregex-num-submatches (#(procedure #:clean #:enforce) irregex-num-submatches ((struct regexp))
				   fixnum)
			(((struct regexp)) (##sys#slot #(1) '5)))

(irregex-lengths (#(procedure #:clean #:enforce) irregex-lengths ((struct regexp))
                  (vector-of (or false pair)))
		 (((struct regexp)) (##sys#slot #(1) '6)))

;; XXX: Submatch names ought to be symbols according to the docs, but this is
;;      not enforced anywhere, so we can't assume it in the return type here.
(irregex-names (#(procedure #:clean #:enforce) irregex-names ((struct regexp))
                (list-of (pair * fixnum)))
	       (((struct regexp)) (##sys#slot #(1) '7)))

;; XXX: specialize these? (how?)
(irregex-extract (#(procedure #:clean #:enforce) irregex-extract (* string #!optional fixnum fixnum)
                  (list-of string)))
(irregex-split (#(procedure #:clean #:enforce) irregex-split (* string #!optional fixnum fixnum)
                (list-of string)))

(irregex-fold (forall (a) (#(procedure #:enforce) irregex-fold (* (procedure (fixnum (struct regexp-match) a) a) a string #!optional (procedure (fixnum *) *) fixnum fixnum) a)))
;; XXX TODO: chunker is a plain vector
(irregex-fold/chunked (forall (a c) (#(procedure #:enforce) irregex-fold/chunked (* (procedure (c fixnum (struct regexp-match) a) a) a vector c #!optional (procedure (c fixnum a) a) fixnum fixnum) a)))
(irregex-reset-matches! (procedure irregex-reset-matches! ((struct regexp-match))
                                   (struct regexp-match)))

;; A silly procedure, but at least we can "inline" it like this
(irregex-match? (#(procedure #:clean #:enforce) irregex-match? (* string #!optional fixnum fixnum)
                 boolean)
                ((* string) (and (irregex-match #(1) #(2)) '#t))
                ((* string fixnum) (and (irregex-match #(1) #(2) #(3)) '#t))
                ((* string fixnum fixnum) (and (irregex-match #(1) #(2) #(3) #(4)) '#t)))
;; These two return #f or a match object
(irregex-match (#(procedure #:clean #:enforce) irregex-match (* string #!optional fixnum fixnum)
                (or false (struct regexp-match))))
;; XXX chunker is a plain vector
;; Not marked clean because we don't know what chunker procedures will do
(irregex-match/chunked (#(procedure #:enforce) irregex-match/chunked (* vector * #!optional fixnum)
                        (or false (struct regexp-match))))

(irregex-match-data? (#(procedure #:pure #:predicate (struct regexp-match)) irregex-match-data? (*) boolean))

(irregex-match-end-index (#(procedure #:clean #:enforce) irregex-match-end-index ((struct regexp-match) #!optional *) fixnum))
(irregex-match-end-chunk (#(procedure #:clean #:enforce) irregex-match-end-chunk ((struct regexp-match) #!optional *) *))
(irregex-match-start-index (#(procedure #:clean #:enforce) irregex-match-start-index ((struct regexp-match) #!optional *) fixnum))
(irregex-match-start-chunk (#(procedure #:clean #:enforce) irregex-match-start-chunk ((struct regexp-match) #!optional *) *))
(irregex-match-substring (#(procedure #:clean #:enforce) irregex-match-substring ((struct regexp-match) #!optional *) *))
(irregex-match-subchunk (#(procedure #:clean #:enforce) irregex-match-subchunk ((struct regexp-match) #!optional *) *))

(irregex-match-names (#(procedure #:clean #:enforce) irregex-match-names ((struct regexp-match)) list)
		     (((struct regexp-match)) (##sys#slot #(1) '2)))

(irregex-match-num-submatches (#(procedure #:enforce) irregex-match-num-submatches ((struct regexp-match)) fixnum)
                              (((struct regexp-match))
                               (fx- (fx/ (##sys#size (##sys#slot #(1) '1)) '4) '2)))

(irregex-new-matches (procedure irregex-new-matches (*) *)) ; really only for internal use..
(irregex-opt (#(procedure #:clean #:enforce) irregex-opt (list) *))
(irregex-quote (#(procedure #:clean #:enforce) irregex-quote (string) string))

(irregex-replace (#(procedure #:enforce) irregex-replace (* string #!rest) string))
(irregex-replace/all (#(procedure #:enforce) irregex-replace/all (* string #!rest) string))
;; Returns a list of strings, but *only* when all user-procedures do
(irregex-apply-match (procedure ((struct regexp-match) list) list)) ; internal use

;; These return #f or a match object
(irregex-search (#(procedure #:clean #:enforce) irregex-search (* string #!optional fixnum fixnum)
                 (or false (struct regexp-match))))
;; XXX chunker is a plain vector
(irregex-search/chunked (#(procedure #:enforce) irregex-search/chunked (* vector * #!optional fixnum *)
                         (or false (struct regexp-match))))
(irregex-search/matches (#(procedure #:enforce) irregex-search/matches (* vector * * fixnum (struct regexp-match))
                         (or false (struct regexp-match))))
(irregex-match-valid-index? 
 (#(procedure #:clean #:enforce) irregex-match-valid-index? ((struct regexp-match) *) boolean))

(irregex? (#(procedure #:pure #:predicate (struct regexp)) irregex? (*) boolean))

(make-irregex-chunker
 (#(procedure #:enforce) make-irregex-chunker 
	    ((procedure (*) *)
	     (procedure (*) *)
	     #!optional
	     (procedure (*) *)
	     (procedure (*) *)
	     (procedure (* fixnum * fixnum) string)
	     (procedure (* fixnum * fixnum) *))
	    *))
(maybe-string->sre (#(procedure #:clean) maybe-string->sre (*) *))
(sre->irregex (#(procedure #:clean) sre->irregex (#!rest) *))
(string->irregex (#(procedure #:clean #:enforce) string->irregex (string #!rest) *))
(string->sre (#(procedure #:clean #:enforce) string->sre (string #!rest) *))


;; lolevel

(address->pointer (#(procedure #:clean #:enforce) address->pointer (fixnum) pointer)
		  ((fixnum) (##sys#address->pointer #(1))))

(align-to-word
 (#(procedure #:clean) 
  align-to-word
  ((or number pointer locative procedure port)) 
  (or pointer number)))

(allocate (#(procedure #:clean #:enforce) allocate (fixnum) (or false pointer)))
(block-ref (#(procedure #:clean #:enforce) block-ref (* fixnum) *))
(block-set! (#(procedure #:enforce) block-set! (* fixnum *) *))
(extend-procedure (#(procedure #:clean #:enforce) extend-procedure (procedure *) procedure))
(extended-procedure? (#(procedure #:clean) extended-procedure (*) boolean))
(free (#(procedure #:clean #:enforce) free (pointer) undefined))
(locative->object (#(procedure #:clean #:enforce) locative->object (locative) *))
(locative-ref (#(procedure #:clean #:enforce) locative-ref (locative) *))
(locative-set! (#(procedure #:enforce) locative-set! (locative *) *))
(locative? (#(procedure #:pure #:predicate locative) locative? (*) boolean))
(make-locative (#(procedure #:clean #:enforce) make-locative (* #!optional fixnum) locative))
(make-pointer-vector (#(procedure #:clean #:enforce) make-pointer-vector (fixnum #!optional (or pointer false)) pointer-vector))
(make-record-instance (#(procedure #:clean) make-record-instance (symbol #!rest) *))
(make-weak-locative (#(procedure #:clean #:enforce) make-weak-locative (* #!optional fixnum) locative))

(move-memory! (#(procedure #:enforce) move-memory! (* * #!optional fixnum fixnum fixnum) *)
	      ((pointer pointer fixnum)
	       (##core#inline "C_copy_ptr_memory" #(2) #(1) #(3) '0 '0))
	      ((pointer pointer fixnum fixnum)
	       (##core#inline "C_copy_ptr_memory" #(2) #(1) #(3) '0 #(4)))
	      ((pointer pointer fixnum fixnum fixnum)
	       (##core#inline "C_copy_ptr_memory" #(2) #(1) #(3) #(5) #(4)))
	      ((locative locative fixnum)
	       (##core#inline "C_copy_ptr_memory" #(2) #(1) #(3) '0 '0))
	      ((locative locative fixnum fixnum)
	       (##core#inline "C_copy_ptr_memory" #(2) #(1) #(3) '0 #(4)))
	      ((locative locative fixnum fixnum fixnum)
	       (##core#inline "C_copy_ptr_memory" #(2) #(1) #(3) #(5) #(4))))

(mutate-procedure!
 (#(procedure #:enforce) mutate-procedure! (procedure (procedure (procedure) . *)) procedure))

(number-of-bytes (#(procedure #:clean) number-of-bytes (*) fixnum)
		 (((or blob string)) (##sys#size #(1)))
		 (((or port procedure symbol pair vector locative float pointer-vector))
		  ;; would be applicable to all structure types, but we can't specify
		  ;; "(struct *)" (yet)
		  (##core#inline "C_bytes" (##sys#size #(1)))))

(number-of-slots (#(procedure #:clean #:foldable) number-of-slots (*) fixnum)
		 (((or vector symbol pair)) (##sys#size #(1))))

(object->pointer (#(procedure #:clean) object->pointer (*) *))
(object-become! (procedure object-become! (list) *))
(object-copy (#(procedure #:clean) object-copy (*) *))
(pointer+ (#(procedure #:clean #:enforce) pointer+ ((or pointer procedure port locative) fixnum) pointer))

(pointer->address (#(procedure #:clean #:enforce) pointer->address ((or pointer procedure port locative)) integer)
		  ((pointer) (##sys#pointer->address #(1))))

(pointer->object (#(procedure #:clean #:enforce) pointer->object (pointer) *)
		 ((pointer) (##core#inline "C_pointer_to_object" #(1))))

(pointer-like? (#(procedure #:pure #:predicate (or pointer locative procedure port)) pointer-like? (*) boolean)
	       (((or pointer locative procedure port)) (let ((#(tmp) #(1))) '#t)))

(pointer-f32-ref (#(procedure #:clean #:enforce) pointer-f32-ref (pointer) number))
(pointer-f32-set! (#(procedure #:clean #:enforce) pointer-f32-set! (pointer number) undefined))
(pointer-f64-ref (#(procedure #:clean #:enforce) pointer-f64-ref (pointer) number))
(pointer-f64-set! (#(procedure #:clean #:enforce) pointer-f64-set! (pointer number) undefined))
(pointer-vector (#(procedure #:clean #:enforce) pointer-vector (#!rest pointer-vector) boolean))

(pointer-vector? (#(procedure #:pure #:predicate pointer-vector) pointer-vector? (*) boolean))

(pointer-vector-fill! (#(procedure #:clean #:enforce) pointer-vector-fill! (pointer-vector (or pointer false)) undefined))

(pointer-vector-length (#(procedure #:clean #:enforce) pointer-vector-length (pointer-vector) fixnum)
		       ((pointer-vector) (##sys#slot #(1) '1)))

(pointer-vector-ref (#(procedure #:clean #:enforce) pointer-vector-ref (pointer-vector fixnum) (or pointer false)))
(pointer-vector-set! (#(procedure #:clean #:enforce) pointer-vector-set! (pointer-vector fixnum (or pointer false)) undefined))
(pointer-s16-ref (#(procedure #:clean #:enforce) pointer-s16-ref (pointer) fixnum))
(pointer-s16-set! (#(procedure #:clean #:enforce) pointer-s16-set! (pointer fixnum) undefined))
(pointer-s32-ref (#(procedure #:clean #:enforce) pointer-s32-ref (pointer) integer))
(pointer-s32-set! (#(procedure #:clean #:enforce) pointer-s32-set! (pointer integer) undefined))
(pointer-s64-ref (#(procedure #:clean #:enforce) pointer-s64-ref (pointer) integer))
(pointer-s64-set! (#(procedure #:clean #:enforce) pointer-s64-set! (pointer integer) undefined))
(pointer-s8-ref (#(procedure #:clean #:enforce) pointer-s8-ref (pointer) fixnum))
(pointer-s8-set! (#(procedure #:clean #:enforce) pointer-s8-set! (pointer fixnum) undefined))

(pointer-tag (#(procedure #:clean #:enforce) pointer-tag ((or pointer locative procedure port)) *)
	     (((or locative procedure port)) (let ((#(tmp) #(1))) '#f)))

(pointer-u16-ref (#(procedure #:clean #:enforce) pointer-u16-ref (pointer) fixnum))
(pointer-u16-set! (#(procedure #:clean #:enforce) pointer-u16-set! (pointer fixnum) undefined))
(pointer-u32-ref (#(procedure #:clean #:enforce) pointer-u32-ref (pointer) integer))
(pointer-u32-set! (#(procedure #:clean #:enforce) pointer-u32-set! (pointer integer) undefined))
(pointer-u64-ref (#(procedure #:clean #:enforce) pointer-u64-ref (pointer) integer))
(pointer-u64-set! (#(procedure #:clean #:enforce) pointer-u64-set! (pointer integer) undefined))
(pointer-u8-ref (#(procedure #:clean #:enforce) pointer-u8-ref (pointer) fixnum))
(pointer-u8-set! (#(procedure #:clean #:enforce) pointer-u8-set! (pointer fixnum) undefined))

(pointer=? (#(procedure #:clean #:enforce) pointer=? ((or pointer locative procedure port)
				  (or pointer locative procedure port)) boolean)
	   ((pointer pointer) (##core#inline "C_pointer_eqp" #(1) #(2))))

(pointer? (#(procedure #:clean #:predicate pointer) pointer? (*) boolean))

(procedure-data (#(procedure #:clean #:enforce) procedure-data (procedure) *))
(record->vector (#(procedure #:clean) record->vector (*) vector))

(record-instance? (#(procedure #:clean) record-instance? (* #!optional symbol) boolean)
		  ((* symbol) (##sys#structure? #(1) #(2)))
		  ((*) (let ((#(tmp) #(1)))
			 (if (##sys#immediate? #(tmp))
			     '#f
			     (##sys#generic-structure? #(tmp))))))

(record-instance-length (#(procedure #:clean) record-instance-length (*) fixnum))
(record-instance-slot (#(procedure #:clean #:enforce) record-instance-slot (* fixnum) *))
(record-instance-slot-set! (#(procedure #:clean #:enforce) record-instance-slot-set! (* fixnum *) undefined))
(record-instance-type (#(procedure #:clean) record-instance-type (*) *))
(set-procedure-data! (#(procedure #:clean #:enforce) set-procedure-data! (procedure *) undefined))
(tag-pointer (#(procedure #:clean #:enforce) tag-pointer (pointer *) pointer))
(tagged-pointer? (#(procedure #:clean #:enforce) tagged-pointer? (* #!optional *) boolean))


;; ports

(call-with-input-string (#(procedure #:enforce) call-with-input-string (string (procedure (input-port) . *)) . *))
(call-with-output-string (#(procedure #:enforce) call-with-output-string ((procedure (output-port) . *)) string))
(copy-port (#(procedure #:enforce) copy-port (* * #!optional (procedure (*) *) (procedure (* output-port) *)) undefined)) 
(make-input-port (#(procedure #:clean #:enforce) make-input-port ((procedure () (or char eof)) (procedure () *) (procedure () . *) #!optional * * * *) input-port))
(make-output-port (#(procedure #:clean #:enforce) make-output-port ((procedure (string) . *) (procedure () . *) #!optional (procedure () . *)) output-port))
(port-for-each (#(procedure #:enforce) port-for-each ((procedure (*) *) (procedure () . *)) undefined))

(port-map
 (forall (a b) (#(procedure #:enforce) port-map ((procedure (a) b) (procedure () a)) (list-of b))))

(port-fold (#(procedure #:enforce) port-fold ((procedure (* *) *) * (procedure () *)) *))
(make-broadcast-port (#(procedure #:clean #:enforce) make-broadcast-port (#!rest output-port) output-port))
(make-concatenated-port (#(procedure #:clean #:enforce) make-concatenated-port (port #!rest input-port) input-port))
(with-error-output-to-port (#(procedure #:enforce) with-error-output-to-port (output-port (procedure () . *)) . *))
(with-input-from-port (#(procedure #:enforce) with-input-from-port (input-port (procedure () . *)) . *))
(with-input-from-string (#(procedure #:enforce) with-input-from-string (string (procedure () . *)) . *))
(with-output-to-port (#(procedure #:enforce) with-output-to-port (output-port (procedure () . *)) . *))
(with-output-to-string (#(procedure #:enforce) with-output-to-string ((procedure () . *)) . *))


;; posix

(_exit (procedure _exit (#!optional fixnum) noreturn))
(call-with-input-pipe (#(procedure #:enforce) call-with-input-pipe (string (procedure (input-port) . *) #!optional symbol) . *))
(call-with-output-pipe (#(procedure #:enforce) call-with-output-pipe (string (procedure (input-port) . *) #!optional symbol) . *))
(change-directory (#(procedure #:clean #:enforce) change-directory (string) string))
(change-directory* (#(procedure #:clean #:enforce) change-directory* (fixnum) fixnum))
(change-file-mode (#(procedure #:clean #:enforce) change-file-mode (string fixnum) undefined))
(change-file-owner (#(procedure #:clean #:enforce) change-file-owner (string fixnum fixnum) undefined))
(close-input-pipe (#(procedure #:clean #:enforce) close-input-pipe (input-port) fixnum))
(close-output-pipe (#(procedure #:clean #:enforce) close-output-pipe (output-port) fixnum))
(create-directory (#(procedure #:clean #:enforce) create-directory (string #!optional *) string))
(create-fifo (#(procedure #:clean #:enforce) create-fifo (string #!optional fixnum) undefined))
(create-pipe (procedure create-pipe () fixnum fixnum))
(create-session (#(procedure #:clean) create-session () fixnum))
(create-symbolic-link (#(procedure #:clean #:enforce) create-symbolic-link (string string) undefined))

;; extra arg for "parameterize" - ugh, what a hack...
(current-directory (#(procedure #:clean #:enforce) current-directory (#!optional string *) string))

(current-effective-group-id (#(procedure #:clean) current-effective-group-id () fixnum))
(current-effective-user-id (#(procedure #:clean) current-effective-user-id () fixnum))
(current-effective-user-name (#(procedure #:clean) current-effective-user-name () string))
(get-environment-variables (#(procedure #:clean) get-environment-variables () (list-of string)))
(current-group-id (#(procedure #:clean) current-group-id () fixnum))
(current-process-id (#(procedure #:clean) current-process-id () fixnum))
(current-user-id (#(procedure #:clean) current-user-id () fixnum))
(current-user-name (#(procedure #:clean) current-user-name () string))
(delete-directory (#(procedure #:clean #:enforce) delete-directory (string #!optional *) string))
(directory (#(procedure #:clean #:enforce) directory (#!optional string *) (list-of string)))
(directory? (#(procedure #:clean #:enforce) directory? ((or string fixnum)) boolean))
(duplicate-fileno (#(procedure #:clean #:enforce) duplicate-fileno (fixnum #!optional fixnum) fixnum))
(errno/2big fixnum)
(errno/acces fixnum)
(errno/again fixnum)
(errno/badf fixnum)
(errno/busy fixnum)
(errno/child fixnum)
(errno/deadlk fixnum)
(errno/dom fixnum)
(errno/exist fixnum)
(errno/fault fixnum)
(errno/fbig fixnum)
(errno/ilseq fixnum)
(errno/intr fixnum)
(errno/inval fixnum)
(errno/io fixnum)
(errno/isdir fixnum)
(errno/mfile fixnum)
(errno/mlink fixnum)
(errno/nametoolong fixnum)
(errno/nfile fixnum)
(errno/nodev fixnum)
(errno/noent fixnum)
(errno/noexec fixnum)
(errno/nolck fixnum)
(errno/nomem fixnum)
(errno/nospc fixnum)
(errno/nosys fixnum)
(errno/notdir fixnum)
(errno/notempty fixnum)
(errno/notty fixnum)
(errno/nxio fixnum)
(errno/perm fixnum)
(errno/pipe fixnum)
(errno/range fixnum)
(errno/rofs fixnum)
(errno/spipe fixnum)
(errno/srch fixnum)
(errno/wouldblock fixnum)
(errno/xdev fixnum)
(fcntl/dupfd fixnum)
(fcntl/getfd fixnum)
(fcntl/getfl fixnum)
(fcntl/setfd fixnum)
(fcntl/setfl fixnum)
(file-access-time (#(procedure #:clean #:enforce) file-access-time ((or string fixnum)) integer))
(file-change-time (#(procedure #:clean #:enforce) file-change-time ((or string fixnum)) integer))
(file-close (#(procedure #:clean #:enforce) file-close (fixnum) undefined))
(file-control (#(procedure #:clean #:enforce) file-control (fixnum fixnum #!optional fixnum) fixnum))
(file-creation-mode (#(procedure #:clean #:enforce) file-creation-mode (#!optional fixnum) fixnum))
(file-execute-access? (#(procedure #:clean #:enforce) file-execute-access? (string) boolean))
(file-link (#(procedure #:clean #:enforce) file-link (string string) undefined))
(file-lock (#(procedure #:clean #:enforce) file-lock (port #!optional fixnum integer) (struct lock)))
(file-lock/blocking (#(procedure #:clean #:enforce) file-lock/blocking (port #!optional fixnum integer) (struct lock)))
(file-mkstemp (#(procedure #:clean #:enforce) file-mkstemp (string) fixnum string))
(file-modification-time (#(procedure #:clean #:enforce) file-modification-time ((or string fixnum)) integer))
(file-open (#(procedure #:clean #:enforce) file-open (string fixnum #!optional fixnum) fixnum))
(file-owner (#(procedure #:clean #:enforce) file-owner ((or string fixnum)) fixnum))
(file-permissions (#(procedure #:clean #:enforce) file-permissions ((or string fixnum)) fixnum))
(file-position (#(procedure #:clean #:enforce) file-position ((or port fixnum)) integer))
(file-read (#(procedure #:clean #:enforce) file-read (fixnum fixnum #!optional *) list))
(file-read-access? (#(procedure #:clean #:enforce) file-read-access? (string) boolean))
(file-select (#(procedure #:clean #:enforce) file-select ((or (list-of fixnum) fixnum false) (or (list-of fixnum) fixnum false) #!optional fixnum) * *))
(file-size (#(procedure #:clean #:enforce) file-size ((or string fixnum)) integer))
(file-stat (#(procedure #:clean #:enforce) file-stat ((or string fixnum) #!optional *) (vector-of integer)))
(file-test-lock (#(procedure #:clean #:enforce) file-test-lock (port #!optional fixnum *) boolean))
(file-truncate (#(procedure #:clean #:enforce) file-truncate ((or string fixnum) integer) undefined))
(file-type (#(procedure #:clean #:enforce) ((or string fixnum) #!optional * *) symbol))
(file-unlock (#(procedure #:clean #:enforce) file-unlock ((struct lock)) undefined))
(file-write (#(procedure #:clean #:enforce) file-write (fixnum * #!optional fixnum) fixnum))
(file-write-access? (#(procedure #:clean #:enforce) file-write-access? (string) boolean))
(fileno/stderr fixnum)
(fileno/stdin fixnum)
(fileno/stdout fixnum)
(find-files (#(procedure #:enforce) find-files (string #!rest) list))
(get-groups (#(procedure #:clean) get-groups () list))
(get-host-name (#(procedure #:clean) get-host-name () string))
(glob (#(procedure #:clean #:enforce) glob (#!rest string) list))
(group-information (#(procedure #:clean #:enforce) group-information (fixnum #!optional *) *))
(initialize-groups (#(procedure #:clean #:enforce) initialize-groups (string fixnum) undefined))
(local-time->seconds (#(procedure #:clean #:enforce) local-time->seconds ((vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)) integer))
(local-timezone-abbreviation (#(procedure #:clean) local-timezone-abbreviation () string))
(open-input-file* (#(procedure #:clean #:enforce) open-input-file* (fixnum #!optional symbol) input-port))
(open-input-pipe (#(procedure #:clean #:enforce) open-input-pipe (string #!optional symbol) input-port))
(open-output-file* (#(procedure #:clean #:enforce) open-output-file* (fixnum #!optional symbol) output-port))
(open-output-pipe (#(procedure #:clean #:enforce) open-output-pipe (string #!optional symbol) output-port))
(open/append fixnum)
(open/binary fixnum)
(open/creat fixnum)
(open/excl fixnum)
(open/fsync fixnum)
(open/noctty fixnum)
(open/nonblock fixnum)
(open/rdonly fixnum)
(open/rdwr fixnum)
(open/read fixnum)
(open/sync fixnum)
(open/text fixnum)
(open/trunc fixnum)
(open/write fixnum)
(open/wronly fixnum)
(parent-process-id (#(procedure #:clean) parent-process-id () fixnum))
(perm/irgrp fixnum)
(perm/iroth fixnum)
(perm/irusr fixnum)
(perm/irwxg fixnum)
(perm/irwxo fixnum)
(perm/irwxu fixnum)
(perm/isgid fixnum)
(perm/isuid fixnum)
(perm/isvtx fixnum)
(perm/iwgrp fixnum)
(perm/iwoth fixnum)
(perm/iwusr fixnum)
(perm/ixgrp fixnum)
(perm/ixoth fixnum)
(perm/ixusr fixnum)
(pipe/buf fixnum)
(port->fileno (#(procedure #:clean #:enforce) port->fileno (port) fixnum))
(process (#(procedure #:clean #:enforce) process (string #!optional (list-of string) (list-of string)) input-port output-port fixnum))
(process* (#(procedure #:clean #:enforce) process* (string #!optional (list-of string) (list-of string)) input-port output-port fixnum *))

(process-execute
 (#(procedure #:clean #:enforce) process-execute (string #!optional (list-of string) (list-of string)) noreturn))

(process-fork (#(procedure #:enforce) process-fork (#!optional (or (procedure () . *) false) *) fixnum))

(process-group-id (#(procedure #:clean #:enforce) process-group-id () fixnum))
(process-run (#(procedure #:clean #:enforce) process-run (string #!optional (list-of string)) fixnum))
(process-signal (#(procedure #:clean #:enforce) process-signal (fixnum #!optional fixnum) undefined))
(process-wait (#(procedure #:clean #:enforce) process-wait (#!optional fixnum *) fixnum fixnum fixnum))
(read-symbolic-link (#(procedure #:clean #:enforce) read-symbolic-link (string #!optional boolean) string))
(regular-file? (#(procedure #:clean #:enforce) regular-file? ((or string fixnum)) boolean))
(seconds->local-time (#(procedure #:clean #:enforce) seconds->local-time (#!optional integer) (vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)))
(seconds->string (#(procedure #:clean #:enforce) seconds->string (#!optional integer) string))
(seconds->utc-time (#(procedure #:clean #:enforce) seconds->utc-time (#!optional integer) (vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)))
(seek/cur fixnum)
(seek/end fixnum)
(seek/set fixnum)
(set-alarm! (#(procedure #:clean #:enforce) set-alarm! (integer) integer))
(set-buffering-mode! (#(procedure #:clean #:enforce) set-buffering-mode! (port symbol #!optional fixnum) undefined))
(set-file-position! (#(procedure #:clean #:enforce) set-file-position! ((or port fixnum) integer #!optional fixnum) undefined))
(set-groups! (#(procedure #:clean #:enforce) set-groups! ((list-of fixnum)) undefined))
(set-root-directory! (#(procedure #:clean #:enforce) set-root-directory! (string) undefined))
(set-signal-handler! (#(procedure #:clean #:enforce) set-signal-handler! (fixnum (or false (procedure (fixnum) . *))) undefined))
(set-signal-mask! (#(procedure #:clean #:enforce) set-signal-mask! ((list-of fixnum)) undefined))
(setenv (#(procedure #:clean #:enforce) setenv (string string) undefined))
(signal-handler (#(procedure #:clean #:enforce) signal-handler (fixnum) (or false (procedure (fixnum) . *))))
(signal-mask (#(procedure #:clean) signal-mask () fixnum))
(signal-mask! (#(procedure #:clean #:enforce) signal-mask! (fixnum) undefined))
(signal-masked? (#(procedure #:clean #:enforce) signal-masked? (fixnum) boolean))
(signal-unmask! (#(procedure #:clean #:enforce) signal-unmask! (fixnum) undefined))
(signal/abrt fixnum)
(signal/alrm fixnum)
(signal/chld fixnum)
(signal/cont fixnum)
(signal/fpe fixnum)
(signal/hup fixnum)
(signal/ill fixnum)
(signal/int fixnum)
(signal/io fixnum)
(signal/bus fixnum)
(signal/kill fixnum)
(signal/pipe fixnum)
(signal/prof fixnum)
(signal/quit fixnum)
(signal/segv fixnum)
(signal/stop fixnum)
(signal/term fixnum)
(signal/trap fixnum)
(signal/tstp fixnum)
(signal/urg fixnum)
(signal/usr1 fixnum)
(signal/usr2 fixnum)
(signal/vtalrm fixnum)
(signal/winch fixnum)
(signal/xcpu fixnum)
(signal/xfsz fixnum)
(signals-list list)
(sleep (#(procedure #:clean #:enforce) sleep (fixnum) fixnum))
(block-device? (#(procedure #:clean #:enforce) block-device? ((or string fixnum)) boolean))
(character-device? (#(procedure #:clean #:enforce) character-device? ((or string fixnum)) boolean))
(fifo? (#(procedure #:clean #:enforce) fifo? ((or string fixnum)) boolean))
(socket? (#(procedure #:clean #:enforce) socket? ((or string fixnum)) boolean))
(string->time (#(procedure #:clean #:enforce) string->time (string #!optional string) (vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)))
(symbolic-link? (#(procedure #:clean #:enforce) symbolic-link? ((or string fixnum)) boolean))
(system-information (#(procedure #:clean) system-information () list))
(terminal-name (#(procedure #:clean #:enforce) terminal-name (port) string))
(terminal-port? (#(procedure #:clean #:enforce) terminal-port? (port) boolean))
(terminal-size (#(procedure #:clean #:enforce) terminal-size (port) fixnum fixnum))
(time->string (#(procedure #:clean #:enforce) time->string ((vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum) #!optional string) string))
(unmap-file-from-memory (#(procedure #:clean #:enforce) unmap-file-from-memory ((struct mmap) #!optional fixnum) undefined))
(unsetenv (#(procedure #:clean #:enforce) unsetenv (string) undefined))
(user-information (#(procedure #:clean #:enforce) user-information ((or string fixnum) #!optional *) *))
(utc-time->seconds (#(procedure #:clean #:enforce) utc-time->seconds ((vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)) integer))
(with-input-from-pipe (#(procedure #:enforce) with-input-from-pipe (string (procedure () . *) #!optional symbol) . *))
(with-output-to-pipe (#(procedure #:enforce) with-output-to-pipe (string (procedure () . *) #!optional symbol) . *))


;; srfi-4

(blob->f32vector (#(procedure #:clean #:enforce) blob->f32vector (blob) (struct f32vector)))
(blob->f32vector/shared (#(procedure #:clean #:enforce) blob->f32vector/shared (blob) (struct f32vector)))
(blob->f64vector (#(procedure #:clean #:enforce) blob->f64vector (blob) (struct f64vector)))
(blob->f64vector/shared (#(procedure #:clean #:enforce) blob->f64vector/shared (blob) (struct f64vector)))
(blob->s16vector (#(procedure #:clean #:enforce) blob->s16vector (blob) (struct s16vector)))
(blob->s16vector/shared (#(procedure #:clean #:enforce) blob->s16vector/shared (blob) (struct s16vector)))
(blob->s32vector (#(procedure #:clean #:enforce) blob->s32vector (blob) (struct s32vector)))
(blob->s32vector/shared (#(procedure #:clean #:enforce) blob->s32vector/shared (blob) (struct s32vector)))
(blob->s8vector (#(procedure #:clean #:enforce) blob->s8vector (blob) (struct u8vector)))
(blob->s8vector/shared (#(procedure #:clean #:enforce) blob->s8vector/shared (blob) (struct u8vector)))
(blob->u16vector (#(procedure #:clean #:enforce) blob->u16vector (blob) (struct u16vector)))
(blob->u16vector/shared (#(procedure #:clean #:enforce) blob->u16vector/shared (blob) (struct u16vector)))
(blob->u32vector (#(procedure #:clean #:enforce) blob->u32vector (blob) (struct u32vector)))
(blob->u32vector/shared (#(procedure #:clean #:enforce) blob->u32vector/shared (blob) (struct u32vector)))
(blob->u64vector (#(procedure #:clean #:enforce) blob->u64vector (blob) (struct u64vector)))
(blob->u64vector/shared (#(procedure #:clean #:enforce) blob->u64vector/shared (blob) (struct u64vector)))
(blob->u8vector (#(procedure #:clean #:enforce) blob->u8vector (blob) (struct u8vector)))
(blob->u8vector/shared (#(procedure #:clean #:enforce) blob->u8vector/shared (blob) (struct u8vector)))
(f32vector (#(procedure #:clean #:enforce) f32vector (#!rest (or integer float)) (struct f32vector)))
(f32vector->blob (#(procedure #:clean #:enforce) f32vector->blob ((struct f32vector)) blob))
(f32vector->blob/shared (#(procedure #:clean #:enforce) f32vector->blob/shared ((struct f32vector)) blob))
(f32vector->list (#(procedure #:clean #:enforce) f32vector->list ((struct f32vector)) (list-of float)))

(f32vector-length (#(procedure #:clean #:enforce) f32vector-length ((struct f32vector)) fixnum)
		  (((struct f32vector)) (##core#inline "C_u_i_32vector_length" #(1))))

(f32vector-ref (#(procedure #:clean #:enforce) f32vector-ref ((struct f32vector) fixnum) float))
(f32vector-set! (#(procedure #:clean #:enforce) f32vector-set! ((struct f32vector) fixnum (or integer float)) undefined))

(f32vector? (#(procedure #:pure #:predicate (struct f32vector)) f32vector? (*) boolean))

(f64vector (#(procedure #:clean #:enforce) f64vector (#!rest (or integer float)) (struct f64vector)))
(f64vector->blob (#(procedure #:clean #:enforce) f64vector->blob ((struct f32vector)) blob))
(f64vector->blob/shared (#(procedure #:clean #:enforce) f64vector->blob/shared ((struct f64vector)) blob))
(f64vector->list (#(procedure #:clean #:enforce) f64vector->list ((struct f64vector)) (list-of float)))

(f64vector-length (#(procedure #:clean #:enforce) f64vector-length ((struct f64vector)) fixnum)
		  (((struct f32vector)) (##core#inline "C_u_i_64vector_length" #(1))))

(f64vector-ref (#(procedure #:clean #:enforce) f64vector-ref ((struct f64vector) fixnum) float))
(f64vector-set! (#(procedure #:clean #:enforce) f64vector-set! ((struct f64vector) fixnum (or integer float)) undefined))

(f64vector? (#(procedure #:pure #:predicate (struct f64vector)) f64vector? (*) boolean))

(list->f32vector (#(procedure #:clean #:enforce) list->f32vector ((list-of (or float integer))) (struct f32vector)))
(list->f64vector (#(procedure #:clean #:enforce) list->f64vector ((list-of (or float integer))) (struct f64vector)))
(list->s16vector (#(procedure #:clean #:enforce) list->s16vector ((list-of fixnum)) (struct s16vector)))
(list->s32vector (#(procedure #:clean #:enforce) list->s32vector ((list-of integer)) (struct s32vector)))
(list->s8vector (#(procedure #:clean #:enforce) list->s8vector ((list-of fixnum)) (struct s8vector)))
(list->u16vector (#(procedure #:clean #:enforce) list->u16vector ((list-of fixnum)) (struct u16vector)))
(list->u32vector (#(procedure #:clean #:enforce) list->u32vector ((list-of integer)) (struct u32vector)))
(list->u64vector (#(procedure #:clean #:enforce) list->u64vector ((list-of integer)) (struct u64vector)))
(list->u8vector (#(procedure #:clean #:enforce) list->u8vector ((list-of fixnum)) (struct u8vector)))
(make-f32vector (#(procedure #:clean #:enforce) make-f32vector (fixnum #!optional (or integer float false) boolean boolean) (struct f32vector)))
(make-f64vector (#(procedure #:clean #:enforce) make-f64vector (fixnum #!optional (or integer float false) boolean) (struct f64vector)))
(make-s16vector (#(procedure #:clean #:enforce) make-s16vector (fixnum #!optional (or fixnum false) boolean boolean) (struct s16vector)))
(make-s32vector (#(procedure #:clean #:enforce) make-s32vector (fixnum #!optional (or integer false) boolean boolean) (struct s32vector)))
(make-s8vector (#(procedure #:clean #:enforce) make-s8vector (fixnum #!optional (or fixnum false) boolean boolean) (struct s8vector)))
(make-u16vector (#(procedure #:clean #:enforce) make-u16vector (fixnum #!optional (or fixnum false) boolean boolean) (struct u16vector)))
(make-u32vector (#(procedure #:clean #:enforce) make-u32vector (fixnum #!optional (or integer false) boolean boolean) (struct u32vector)))
(make-u64vector (#(procedure #:clean #:enforce) make-u64vector (fixnum #!optional (or integer false) boolean boolean) (struct u64vector)))
(make-u8vector (#(procedure #:clean #:enforce) make-u8vector (fixnum #!optional (or fixnum false) boolean boolean) (struct u8vector)))
(read-u8vector (#(procedure #:enforce) read-u8vector (#!optional fixnum input-port) (struct u8vector)))
(read-u8vector! (#(procedure #:enforce) read-u8vector! ((or fixnum false) (struct u8vector) #!optional input-port fixnum) integer))
(release-number-vector (procedure release-number-vector (*) undefined))
(s16vector (#(procedure #:clean #:enforce) s16vector (#!rest fixnum) (struct s16vector)))
(s16vector->blob (#(procedure #:clean #:enforce) s16vector->blob ((struct s16vector)) blob))
(s16vector->blob/shared (#(procedure #:clean #:enforce) s16vector->blob/shared ((struct s16vector)) blob))
(s16vector->list (#(procedure #:clean #:enforce) s16vector->list ((struct s16vector)) (list-of fixnum)))

(s16vector-length (#(procedure #:clean #:enforce) s16vector-length ((struct s16vector)) fixnum)
		  (((struct s16vector)) (##core#inline "C_u_i_16vector_length" #(1))))

(s16vector-ref (#(procedure #:clean #:enforce) s16vector-ref ((struct s16vector) fixnum) fixnum))
(s16vector-set! (#(procedure #:clean #:enforce) s16vector-set! ((struct s16vector) fixnum fixnum) undefined))

(s16vector? (#(procedure #:pure #:predicate (struct s16vector)) s16vector? (*) boolean))

(s32vector (#(procedure #:clean #:enforce) s32vector (#!rest integer) (struct s32vector)))
(s32vector->blob (#(procedure #:clean #:enforce) s32vector->blob ((struct 32vector)) blob))
(s32vector->blob/shared (#(procedure #:clean #:enforce) s32vector->blob/shared ((struct s32vector)) blob))
(s32vector->list (#(procedure #:clean #:enforce) s32vector->list ((struct s32vector)) (list-of integer)))

(s32vector-length (#(procedure #:clean #:enforce) s32vector-length ((struct s32vector)) fixnum)
		  (((struct s32vector)) (##core#inline "C_u_i_32vector_length" #(1))))

(s32vector-ref (#(procedure #:clean #:enforce) s32vector-ref ((struct s32vector) fixnum) integer))
(s32vector-set! (#(procedure #:clean #:enforce) s32vector-set! ((struct s32vector) fixnum integer) undefined))

(s32vector? (#(procedure #:pure #:predicate (struct s32vector)) s32vector? (*) boolean))

(s8vector (#(procedure #:clean #:enforce) s8vector (#!rest fixnum) (struct s8vector)))
(s8vector->blob (#(procedure #:clean #:enforce) s8vector->blob ((struct s8vector)) blob))
(s8vector->blob/shared (#(procedure #:clean #:enforce) s8vector->blob/shared ((struct s8vector)) blob))
(s8vector->list (#(procedure #:clean #:enforce) s8vector->list ((struct s8vector)) (list-of fixnum)))

(s8vector-length (#(procedure #:clean #:enforce) s8vector-length ((struct s8vector)) fixnum)
		 (((struct s8vector)) (##core#inline "C_u_i_8vector_length" #(1))))

(s8vector-ref (#(procedure #:clean #:enforce) s8vector-ref ((struct s8vector) fixnum) fixnum))
(s8vector-set! (#(procedure #:clean #:enforce) s8vector-set! ((struct s8vector) fixnum fixnum) undefined))

(s8vector? (#(procedure #:pure #:predicate (struct s8vector)) s8vector? (*) boolean))

(subf32vector (#(procedure #:clean #:enforce) subf32vector ((struct f32vector) fixnum fixnum) (struct f32vector)))
(subf64vector (#(procedure #:clean #:enforce) subf64vector ((struct f64vector) fixnum fixnum) (struct f64vector)))
(subs16vector (#(procedure #:clean #:enforce) subs16vector ((struct s16vector) fixnum fixnum) (struct s16vector)))
(subs32vector (#(procedure #:clean #:enforce) subs32vector ((struct s32vector) fixnum fixnum) (struct s32vector)))
(subs8vector (#(procedure #:clean #:enforce) subs8vector  ((struct s8vector) fixnum fixnum) (struct s8vector)))
(subu16vector (#(procedure #:clean #:enforce) subu16vector ((struct u16vector) fixnum fixnum) (struct u16vector)))
(subu32vector (#(procedure #:clean #:enforce) subu32vector ((struct u32vector) fixnum fixnum) (struct u32vector)))
(subu64vector (#(procedure #:clean #:enforce) subu64vector ((struct u64vector) fixnum fixnum) (struct u64vector)))
(subu8vector (#(procedure #:clean #:enforce) subu8vector ((struct u8vector) fixnum fixnum) (struct u8vector)))
(u16vector (#(procedure #:clean #:enforce) u16vector (#!rest fixnum) (struct u16vector)))
(u16vector->blob (#(procedure #:clean #:enforce) u16vector->blob ((struct u16vector)) blob))
(u16vector->blob/shared (#(procedure #:clean #:enforce) u16vector->blob/shared ((struct u16vector)) blob))
(u16vector->list (#(procedure #:clean #:enforce) u16vector->list ((struct u16vector)) (list-of fixnum)))

(u16vector-length (#(procedure #:clean #:enforce) u16vector-length ((struct u16vector)) fixnum)
		  (((struct u16vector)) (##core#inline "C_u_i_16vector_length" #(1))))

(u16vector-ref (#(procedure #:clean #:enforce) u16vector-ref ((struct u16vector) fixnum) fixnum))
(u16vector-set! (#(procedure #:clean #:enforce) u16vector-set! ((struct u16vector) fixnum fixnum) undefined))

(u16vector? (#(procedure #:pure #:predicate (struct u16vector)) u16vector? (*) boolean))

(u32vector (#(procedure #:clean #:enforce) u32vector (#!rest integer) (struct u32vector)))
(u32vector->blob (#(procedure #:clean #:enforce) u32vector->blob ((struct u32vector)) blob))
(u32vector->blob/shared (#(procedure #:clean #:enforce) u32vector->blob/shared ((struct u32vector)) blob))
(u32vector->list (#(procedure #:clean #:enforce) u32vector->list ((struct u32vector)) (list-of integer)))

(u32vector-length (#(procedure #:clean #:enforce) u32vector-length ((struct u32vector)) fixnum)
		  (((struct u32vector)) (##core#inline "C_u_i_32vector_length" #(1))))

(u32vector-ref (#(procedure #:clean #:enforce) u32vector-ref ((struct u32vector) fixnum) integer))
(u32vector-set! (#(procedure #:clean #:enforce) u32vector-set! ((struct u32vector) fixnum integer) undefined))

(u32vector? (#(procedure #:pure #:predicate (struct u32vector)) u32vector? (*) boolean))

(u64vector (#(procedure #:clean #:enforce) u64vector (#!rest integer) (struct u64vector)))
(u64vector->blob (#(procedure #:clean #:enforce) u64vector->blob ((struct u64vector)) blob))
(u64vector->blob/shared (#(procedure #:clean #:enforce) u64vector->blob/shared ((struct u64vector)) blob))
(u64vector->list (#(procedure #:clean #:enforce) u64vector->list ((struct u64vector)) (list-of integer)))

(u64vector-length (#(procedure #:clean #:enforce) u64vector-length ((struct u64vector)) fixnum)
		  (((struct u64vector)) (##core#inline "C_u_i_64vector_length" #(1))))

(u64vector-ref (#(procedure #:clean #:enforce) u64vector-ref ((struct u64vector) fixnum) integer))
(u64vector-set! (#(procedure #:clean #:enforce) u64vector-set! ((struct u64vector) fixnum integer) undefined))

(u64vector? (#(procedure #:pure #:predicate (struct u64vector)) u64vector? (*) boolean))

(u8vector (#(procedure #:clean #:enforce) u8vector (#!rest fixnum) (struct u8vector)))
(u8vector->blob (#(procedure #:clean #:enforce) u8vector->blob ((struct u8vector)) blob))
(u8vector->blob/shared (#(procedure #:clean #:enforce) u8vector->blob/shared ((struct u8vector)) blob))
(u8vector->list (#(procedure #:clean #:enforce) u8vector->list ((struct u8vector)) (list-of fixnum)))

(u8vector-length (#(procedure #:clean #:enforce) u8vector-length ((struct u8vector)) fixnum)
		 (((struct u8vector)) (##core#inline "C_u_i_8vector_length" #(1))))

(u8vector-ref (#(procedure #:clean #:enforce) u8vector-ref ((struct u8vector) fixnum) fixnum))
(u8vector-set! (#(procedure #:clean #:enforce) u8vector-set! ((struct u8vector) fixnum fixnum) undefined))

(u8vector? (#(procedure #:pure #:predicate (struct u8vector)) u8vector? (*) boolean))

(write-u8vector (#(procedure #:enforce) write-u8vector ((struct u8vector) #!optional output-port fixnum fixnum) undefined))

(number-vector? (#(procedure #:pure #:predicate (or (struct u8vector) (struct u16vector) (struct s8vector) (struct s16vector) (struct u32vector) (struct s32vector) (struct u64vector) (struct s64vector) (struct f32vector) (struct f64vector))) number-vector? (*) boolean))
(##sys#srfi-4-vector? (#(procedure #:pure #:predicate (or (struct u8vector) (struct u16vector) (struct s8vector) (struct s16vector) (struct u32vector) (struct s32vector) (struct u64vector) (struct s64vector) (struct f32vector) (struct f64vector))) ##sys#srfi-4-vector? (*) boolean))


;; tcp

(tcp-abandon-port (#(procedure #:clean #:enforce) tcp-abandon-port (port) undefined))
(tcp-accept (#(procedure #:clean #:enforce) tcp-accept ((struct tcp-listener)) input-port output-port))
(tcp-accept-ready? (#(procedure #:clean #:enforce) tcp-accept-ready? ((struct tcp-listener)) boolean))
(tcp-accept-timeout (#(procedure #:clean #:enforce) tcp-accept-timeout (#!optional (or false integer)) (or false integer)))
(tcp-addresses (#(procedure #:clean #:enforce) tcp-addresses (port) string string))
(tcp-buffer-size (#(procedure #:clean #:enforce) tcp-buffer-size (#!optional fixnum) fixnum))
(tcp-close (#(procedure #:clean #:enforce) tcp-close ((struct tcp-listener)) undefined))
(tcp-connect (#(procedure #:clean #:enforce) tcp-connect (string #!optional fixnum) input-port output-port))
(tcp-connect-timeout (#(procedure #:clean #:enforce) tcp-connect-timeout (#!optional (or false integer)) (or false integer)))
(tcp-listen (#(procedure #:clean #:enforce) tcp-listen (fixnum #!optional fixnum *) (struct tcp-listener)))

(tcp-listener-fileno (#(procedure #:clean #:enforce) tcp-listener-fileno ((struct tcp-listener)) fixnum)
		     (((struct tcp-listener)) (##sys#slot #(1) '1)))

(tcp-listener-port (#(procedure #:clean #:enforce) tcp-listener-port ((struct tcp-listener)) fixnum))

(tcp-listener? (#(procedure #:clean #:predicate (struct tcp-listener)) tcp-listener? (*) boolean))

(tcp-port-numbers (#(procedure #:clean #:enforce) tcp-port-numbers (port) fixnum fixnum))
(tcp-read-timeout (#(procedure #:clean #:enforce) tcp-read-timeout (#!optional (or false integer)) (or false integer)))
(tcp-write-timeout (#(procedure #:clean #:enforce) tcp-write-timeout (#!optional (or false integer)) (or false integer)))


;; utils

(read-all (#(procedure #:enforce) read-all (#!optional (or input-port string)) string))
(system* (#(procedure #:clean #:enforce) system* (string #!rest) undefined))
(qs (#(procedure #:clean #:enforce) qs (string) string))
(compile-file (#(procedure #:clean #:enforce) compile-file (string #!rest) (or false string)))
(compile-file-options (#(procedure #:clean #:enforce) compile-file-options (#!optional (list-of string)) (list-of string)))
(scan-input-lines (#(procedure #:enforce) scan-input-lines (* #!optional input-port) *))
(yes-or-no? (#(procedure #:enforce) yes-or-no? (string #!rest) *))
