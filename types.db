;;;; types.db - Type-information for core library functions -*- Scheme -*-
;
; Copyright (c) 2009-2015, The CHICKEN Team
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following
; conditions are met:
;
;   Redistributions of source code must retain the above copyright notice, this list of conditions and the following
;     disclaimer. 
;   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
;     disclaimer in the documentation and/or other materials provided with the distribution. 
;   Neither the name of the author nor the names of its contributors may be used to endorse or promote
;     products derived from this software without specific prior written permission. 
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
; OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
; AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
; CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY
; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
; OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.


;;; Notes:
;
; - numeric types are disjoint, "fixnum" or "float" will not match "number" in the
;   rewrite rules
; - for a description of the type-specifier syntax, see "scrutinizer.scm" (top of file)
; - in templates, "#(INTEGER)" refers to the INTEGERth argument (starting from 1)
; - in templates, "#(INTEGER ...)" refers to the INTEGERth argument (starting from 1) and
;   all remaining arguments
; - in templates "#(SYMBOL)" binds X to a temporary gensym'd variable, further references
;   to "#(SYMBOL)" allow backreferences to this generated identifier
; - "#(procedure PROPERTY ...)" may be used in place of "procedure", properties are:
;     #:clean - procedure does not modify state that might be used locally
;     #:enforce - when procedure returns, arguments are of correct type
;     #:predicate TYPE - procedure is a predicate on TYPE
;     #:pure - procedure has no side effects
; - "#:clean" means: will not invoke procedures that modify local variables and
;   will not modify list or vector data held locally (note that I/O may invoke
;   port handlers)
; - "#:pure" means: will not have side-effects; this is a bit of a lie,
;   since arity-mismatch will for example always have a side effect.
; - "#:enforce" means: after return from this procedure, the argument is of
;   the correct type (it would have signalled an error otherwise)


;; scheme

(not (#(procedure #:pure) not (*) boolean)
     (((not boolean)) (let ((#(tmp) #(1))) '#f)))

(boolean? (#(procedure #:pure #:predicate boolean) boolean? (*) boolean))

(eq? (#(procedure #:pure) eq? (* *) boolean))

(eqv? (#(procedure #:pure) eqv? (* *) boolean)
      (((not float) *) (eq? #(1) #(2)))
      ((* (not float)) (eq? #(1) #(2))))

(equal? (#(procedure #:pure) equal? (* *) boolean)
	(((or fixnum symbol char eof null) *) (eq? #(1) #(2)))
	((* (or fixnum symbol char eof null)) (eq? #(1) #(2))))

(pair? (#(procedure #:pure #:predicate pair) pair? (*) boolean))

(cons (forall (a b) (#(procedure #:pure) cons (a b) (pair a b))))

(##sys#cons (forall (a b) (#(procedure #:pure) ##sys#cons (a b) (pair a b))))

(car (forall (a) (#(procedure #:clean #:enforce) car ((pair a *)) a)) ((pair) (##core#inline "C_u_i_car" #(1))))
(cdr (forall (a) (#(procedure #:clean #:enforce) cdr ((pair * a)) a)) ((pair) (##core#inline "C_u_i_cdr" #(1))))

(caar (forall (a) (#(procedure #:clean #:enforce) caar ((pair (pair a *) *)) a))
      (((pair (pair * *) *)) (##core#inline "C_u_i_car" (##core#inline "C_u_i_car" #(1)))))
(cadr (forall (a) (#(procedure #:clean #:enforce) cadr ((pair * (pair a *))) a))
      (((pair * (pair * *))) (##core#inline "C_u_i_car" (##core#inline "C_u_i_cdr" #(1)))))
(cdar (forall (a) (#(procedure #:clean #:enforce) cdar ((pair (pair * a) *)) a))
      (((pair (pair * *) *)) (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_car" #(1)))))
(cddr (forall (a) (#(procedure #:clean #:enforce) cddr ((pair * (pair * a))) a))
      (((pair * (pair * *))) (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_cdr" #(1)))))

(caaar (forall (a) (#(procedure #:clean #:enforce) caaar ((pair (pair (pair a *) *) *)) a))
       (((pair (pair (pair * *) *) *))
	(##core#inline "C_u_i_car"
		       (##core#inline "C_u_i_car" (##core#inline "C_u_i_car" #(1))))))

(caadr (forall (a) (#(procedure #:clean #:enforce) caadr ((pair * (pair (pair a *) *))) a))
       (((pair * (pair (pair * *) *)))
	(##core#inline "C_u_i_car"
		       (##core#inline "C_u_i_car" (##core#inline "C_u_i_cdr" #(1))))))

(cadar (forall (a) (#(procedure #:clean #:enforce) cadar ((pair (pair * (pair a *)) *)) a))
       (((pair (pair * (pair * *)) *))
	(##core#inline "C_u_i_car"
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_car" #(1))))))

(caddr (forall (a) (#(procedure #:clean #:enforce) caddr ((pair * (pair * (pair a *)))) a))
       (((pair * (pair * (pair * *))))
	(##core#inline "C_u_i_car"
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_cdr" #(1))))))

(cdaar (forall (a) (#(procedure #:clean #:enforce) cdaar ((pair (pair (pair * a) *) *)) a))
       (((pair (pair (pair * *) *) *))
	(##core#inline "C_u_i_cdr"
		       (##core#inline "C_u_i_car" (##core#inline "C_u_i_car" #(1))))))

(cdadr (forall (a) (#(procedure #:clean #:enforce) cdadr ((pair * (pair (pair * a) *))) a))
       (((pair * (pair (pair * *) *)))
	(##core#inline "C_u_i_cdr"
		       (##core#inline "C_u_i_car" (##core#inline "C_u_i_cdr" #(1))))))

(cddar (forall (a) (#(procedure #:clean #:enforce) cddar ((pair (pair * (pair * a)) *)) a))
       (((pair (pair * (pair * *)) *))
	(##core#inline "C_u_i_cdr"
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_car" #(1))))))

(cdddr (forall (a) (#(procedure #:clean #:enforce) cdddr ((pair * (pair * (pair * a)))) a))
       (((pair * (pair * (pair * *))))
	(##core#inline "C_u_i_cdr"
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_cdr" #(1))))))

(caaaar (forall (a) (#(procedure #:clean #:enforce) caaaar ((pair (pair (pair (pair a *) *) *) *)) a)))
(caaadr (forall (a) (#(procedure #:clean #:enforce) caaadr ((pair * (pair (pair (pair a *) *) *))) a)))
(caadar (forall (a) (#(procedure #:clean #:enforce) caadar ((pair (pair * (pair (pair a *) *)) *)) a)))
(caaddr (forall (a) (#(procedure #:clean #:enforce) caaddr ((pair * (pair * (pair (pair a *) *)))) a)))
(cadaar (forall (a) (#(procedure #:clean #:enforce) cadaar ((pair (pair (pair * (pair a *)) *) *)) a)))
(cadadr (forall (a) (#(procedure #:clean #:enforce) cadadr ((pair * (pair (pair * (pair a *)) *))) a)))
(caddar (forall (a) (#(procedure #:clean #:enforce) caddar ((pair (pair * (pair * (pair a *))) *)) a)))
(cadddr (forall (a) (#(procedure #:clean #:enforce) cadddr ((pair * (pair * (pair * (pair a *))))) a)))
(cdaaar (forall (a) (#(procedure #:clean #:enforce) cdaaar ((pair (pair (pair (pair * a) *) *) *)) a)))
(cdaadr (forall (a) (#(procedure #:clean #:enforce) cdaadr ((pair * (pair (pair (pair * a) *) *))) a)))
(cdadar (forall (a) (#(procedure #:clean #:enforce) cdadar ((pair (pair * (pair (pair * a) *)) *)) a)))
(cdaddr (forall (a) (#(procedure #:clean #:enforce) cdaddr ((pair * (pair * (pair (pair * a) *)))) a)))
(cddaar (forall (a) (#(procedure #:clean #:enforce) cddaar ((pair (pair (pair * (pair * a)) *) *)) a)))
(cddadr (forall (a) (#(procedure #:clean #:enforce) cddadr ((pair * (pair (pair * (pair * a)) *))) a)))
(cdddar (forall (a) (#(procedure #:clean #:enforce) cdddar ((pair (pair * (pair * (pair * a))) *)) a)))
(cddddr (forall (a) (#(procedure #:clean #:enforce) cddddr ((pair * (pair * (pair * (pair * a))))) a)))

(set-car! (#(procedure #:enforce) set-car! (pair *) undefined) 
	  ((pair (or fixnum char boolean eof null undefined)) (##sys#setislot #(1) '0 #(2)))
	  ((pair *) (##sys#setslot #(1) '0 #(2))))

(set-cdr! (#(procedure #:enforce) set-cdr! (pair *) undefined)
	  ((pair (or fixnum char boolean eof null undefined)) (##sys#setislot #(1) '1 #(2)))
	  ((pair *) (##sys#setslot #(1) '1 #(2))))

(null? (#(procedure #:pure #:predicate null) null? (*) boolean))
(list? (#(procedure #:pure #:predicate list) list? (*) boolean))

;; special cased (see scrutinizer.scm)
(list (#(procedure #:pure) list (#!rest) list))
(##sys#list (#(procedure #:pure) ##sys#list (#!rest) list))

(length (#(procedure #:clean #:enforce) length (list) fixnum) ; may loop
	((null) (let ((#(tmp) #(1))) '0))
	((list) (##core#inline "C_u_i_length" #(1))))

(##sys#length (#(procedure #:clean #:enforce) ##sys#length (list) fixnum)
	      ((null) (let ((#(tmp) #(1))) '0))
	      ((list) (##core#inline "C_u_i_length" #(1))))

;; these are special cased (see scrutinizer.scm)
(list-tail (forall (a) (#(procedure #:clean #:enforce) list-tail ((list-of a) fixnum) (list-of a))))
(list-ref (forall (a) (#(procedure #:clean #:enforce) list-ref ((list-of a) fixnum) a)))

(append (#(procedure #:clean) append (#!rest *) *)) ; sic
(##sys#append (#(procedure #:clean) ##sys#append (#!rest *) *))

;; special cased (see scrutinizer.scm)
(reverse (forall (a) (#(procedure #:clean #:enforce) reverse ((list-of a)) (list-of a)))
         ((null) (null) (let ((#(tmp) #(1))) '())))

(memq (forall (a b) (#(procedure #:clean) memq (a (list-of b)) (or false (list-of b))))
      ((* null) (let ((#(tmp) #(1))) '#f))
      ((* list) (##core#inline "C_u_i_memq" #(1) #(2))))

(memv (forall (a b) (#(procedure #:clean) memv (a (list-of b)) (or false (list-of b))))
      ((* null) (let ((#(tmp) #(1))) '#f))
      (((or symbol procedure immediate) list)
       (##core#inline "C_u_i_memq" #(1) #(2))))

(member (forall (a b) (#(procedure #:clean) member
		       (a (list-of b) #!optional (procedure (b a) *)) ; sic
		       (or false (list-of b))))
	((* null) (let ((#(tmp) #(1))) '#f))
	(((or symbol procedure immediate) list)
	 (##core#inline "C_u_i_memq" #(1) #(2)))
	((* (list-of (or symbol procedure immediate)))
	 (##core#inline "C_u_i_memq" #(1) #(2))))

(assq (forall (a b) (#(procedure #:clean) assq (* (list-of (pair a b)))
		     (or false (pair a b))))
      ((* null) (let ((#(tmp) #(1))) '#f))
      ((* (list-of pair)) (##core#inline "C_u_i_assq" #(1) #(2))))

(assv (forall (a b) (#(procedure #:clean) assv (* (list-of (pair a b))) 
		     (or false (pair a b))))
      ((* null) (let ((#(tmp) #(1))) '#f))
      (((or symbol immediate procedure) (list-of pair))
       (##core#inline "C_u_i_assq" #(1) #(2)))
      ((* (list-of (pair (or symbol procedure immediate) *)))
       (##core#inline "C_u_i_assq" #(1) #(2))))

(assoc (forall (a b c) (#(procedure #:clean) assoc (a (list-of (pair b c))
						      #!optional (procedure (b a) *)) ; sic
			(or false (pair b c))))
       ((* null) (let ((#(tmp) #(1))) '#f))
       (((or symbol procedure immediate) (list-of pair))
	(##core#inline "C_u_i_assq" #(1) #(2)))
       ((* (list-of (pair (or symbol procedure immediate) *)))
	(##core#inline "C_u_i_assq" #(1) #(2))))

(symbol? (#(procedure #:pure #:predicate symbol) symbol? (*) boolean))

(symbol-append (#(procedure #:clean #:enforce) symbol-append (#!rest symbol) symbol))
(symbol->string (#(procedure #:clean #:enforce) symbol->string (symbol) string))
(string->symbol (#(procedure #:clean #:enforce) string->symbol (string) symbol))

(number? (#(procedure #:pure #:predicate number) number? (*) boolean))

;;XXX predicate?
(integer? (#(procedure #:pure) integer? (*) boolean)
	  ((fixnum) (let ((#(tmp) #(1))) '#t))
	  ((float) (##core#inline "C_u_i_fpintegerp" #(1))))

(real? (#(procedure #:pure #:predicate number) real? (*) boolean))
(complex? (#(procedure #:pure #:predicate number) complex? (*) boolean))
(exact? (#(procedure #:clean #:enforce) exact? (number) boolean)
        ((fixnum) (let ((#(tmp) #(1))) '#t))
        ((float) (let ((#(tmp) #(1))) '#f)))
(inexact? (#(procedure #:clean #:enforce) inexact? (number) boolean)
          ((fixnum) (let ((#(tmp) #(1))) '#f))
          ((float) (let ((#(tmp) #(1))) '#t)))

;;XXX predicate?
(rational? (#(procedure #:pure) rational? (*) boolean)
	   ((fixnum) (let ((#(tmp) #(1))) '#t)))

(zero? (#(procedure #:clean #:enforce) zero? (number) boolean) 
       ((fixnum) (eq? #(1) '0))
       ((number) (##core#inline "C_u_i_zerop" #(1))))

(odd? (#(procedure #:clean #:enforce) odd? (number) boolean) ((fixnum) (fxodd? #(1))))
(even? (#(procedure #:clean #:enforce) even? (number) boolean) ((fixnum) (fxeven? #(1))))

(positive? (#(procedure #:clean #:enforce) positive? (number) boolean)
	   ((fixnum) (##core#inline "C_fixnum_greaterp" #(1) '0))
	   ((number) (##core#inline "C_u_i_positivep" #(1))))

(negative? (#(procedure #:clean #:enforce) negative? (number) boolean)
	   ((fixnum) (##core#inline "C_fixnum_lessp" #(1) '0))
	   ((number) (##core#inline "C_u_i_negativep" #(1))))

(max (#(procedure #:clean #:enforce) max (#!rest number) number)
     ((fixnum fixnum) (fxmax #(1) #(2)))
     ((float float) (##core#inline "C_i_flonum_max" #(1) #(2))))

(min (#(procedure #:clean #:enforce) min (#!rest number) number)
     ((fixnum fixnum) (fxmin #(1) #(2)))
     ((float float) (##core#inline "C_i_flonum_min" #(1) #(2))))

(+ (#(procedure #:clean #:enforce) + (#!rest number) number)
   (() (fixnum) '0)
   ((fixnum) (fixnum) #(1))
   ((float) (float) #(1))
   ((number) #(1))
   ((float fixnum) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_plus" 4) 
     #(1) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float)
    (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_plus" 4) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
     #(2)))
   ((float float) (float)
    (##core#inline_allocate ("C_a_i_flonum_plus" 4) #(1) #(2))))

(- (#(procedure #:clean #:enforce) - (number #!rest number) number)
   ((fixnum) (fixnum)
    (##core#inline "C_u_fixnum_negate" #(1)))
   ((float fixnum) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_difference" 4) 
     #(1) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_difference" 4) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
     #(2)))
   ((float float) (float)
    (##core#inline_allocate ("C_a_i_flonum_difference" 4) #(1) #(2)))
   ((float) (float) 
    (##core#inline_allocate ("C_a_i_flonum_negate" 4) #(1))))

(* (#(procedure #:clean #:enforce) * (#!rest number) number)
   (() (fixnum) '1)
   ((fixnum) (fixnum) #(1))
   ((float) (float) #(1))
   ((number) (number) #(1))
   ((float fixnum) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_times" 4) 
     #(1) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_times" 4) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
     #(2)))
   ((float float) (float)
    (##core#inline_allocate ("C_a_i_flonum_times" 4) #(1) #(2))))

(/ (#(procedure #:clean #:enforce) / (number #!rest number) number)
   ((float fixnum) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_quotient_checked" 4) 
     #(1) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float) (float)
    (##core#inline_allocate 
     ("C_a_i_flonum_quotient_checked" 4) 
     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
     #(2)))
   ((float float) (float)
    (##core#inline_allocate ("C_a_i_flonum_quotient_checked" 4) #(1) #(2))))

(= (#(procedure #:clean #:enforce) = (#!rest number) boolean)
   (() '#t)
   ((number) (let ((#(tmp) #(1))) '#t))
   ((fixnum fixnum) (eq? #(1) #(2)))
   ((float fixnum) (##core#inline
		    "C_flonum_equalp"
		    #(1) 
		    (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float) (##core#inline
		    "C_flonum_equalp"
		    (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
		    #(2)))
   ((float float) (##core#inline "C_flonum_equalp" #(1) #(2))))

(> (#(procedure #:clean #:enforce) > (#!rest number) boolean)
   (() '#t)
   ((number) (let ((#(tmp) #(1))) '#t))
   ((fixnum fixnum) (fx> #(1) #(2)))
   ((float fixnum) (##core#inline
		    "C_flonum_greaterp"
		    #(1) 
		    (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float) (##core#inline
		    "C_flonum_greaterp"
		    (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
		    #(2)))
   ((float float) (##core#inline "C_flonum_greaterp" #(1) #(2))))

(< (#(procedure #:clean #:enforce) < (#!rest number) boolean)
   (() '#t)
   ((number) (let ((#(tmp) #(1))) '#t))
   ((fixnum fixnum) (fx< #(1) #(2)))
   ((float fixnum) (##core#inline
		    "C_flonum_lessp"
		    #(1) 
		    (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
   ((fixnum float) (##core#inline
		    "C_flonum_lessp"
		    (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
		    #(2)))
   ((float float) (##core#inline "C_flonum_lessp" #(1) #(2))))

(>= (#(procedure #:clean #:enforce) >= (#!rest number) boolean)
    (() '#t)
    ((number) (let ((#(tmp) #(1))) '#t))
    ((fixnum fixnum) (fx>= #(1) #(2)))
    ((float fixnum) (##core#inline
		     "C_flonum_greater_or_equal_p"
		     #(1) 
		     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
    ((fixnum float) (##core#inline
		     "C_flonum_greater_or_equal_p"
		     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
		     #(2)))
    ((float float) (##core#inline "C_flonum_greater_or_equal_p" #(1) #(2))))

(<= (#(procedure #:clean #:enforce) <= (#!rest number) boolean)
    (() '#t)
    ((number) (let ((#(tmp) #(1))) '#t))
    ((fixnum fixnum) (fx<= #(1) #(2)))
    ((float fixnum) (##core#inline
		     "C_flonum_less_or_equal_p"
		     #(1) 
		     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
    ((fixnum float) (##core#inline
		     "C_flonum_less_or_equal_p"
		     (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
		     #(2)))
    ((float float) (##core#inline "C_flonum_less_or_equal_p" #(1) #(2))))

(quotient (#(procedure #:clean #:enforce) quotient (number number) number)
	  ;;XXX flonum/mixed case
	  ((fixnum fixnum) (fixnum)
	   (##core#inline "C_fixnum_divide" #(1) #(2))))

(remainder (#(procedure #:clean #:enforce) remainder (number number) number)
	   ;;XXX flonum/mixed case
	   ((fixnum fixnum) (fixnum)
	    (##core#inline "C_fixnum_modulo" #(1) #(2))))

(modulo (#(procedure #:clean #:enforce) modulo (number number) number))

(gcd (#(procedure #:clean #:enforce) gcd (#!rest number) number) ((* *) (##sys#gcd #(1) #(2))))
(lcm (#(procedure #:clean #:enforce) lcm (#!rest number) number) ((* *) (##sys#lcm #(1) #(2))))

(abs (#(procedure #:clean #:enforce) abs (number) number)
     ((fixnum) (fixnum)
      (##core#inline "C_fixnum_abs" #(1)))
     ((float) (float)
      (##core#inline_allocate ("C_a_i_flonum_abs" 4) #(1))))

(floor (#(procedure #:clean #:enforce) floor (number) number)
       ((fixnum) (fixnum) #(1))
       ((float) (float)
	(##core#inline_allocate ("C_a_i_flonum_floor" 4) #(1))))

(ceiling (#(procedure #:clean #:enforce) ceiling (number) number)
	 ((fixnum) (fixnum) #(1))
	 ((float) (float)
	  (##core#inline_allocate ("C_a_i_flonum_ceiling" 4) #(1))))

(truncate (#(procedure #:clean #:enforce) truncate (number) number)
	  ((fixnum) (fixnum) #(1))
	  ((float) (float)
	   (##core#inline_allocate ("C_a_i_flonum_truncate" 4) #(1))))

(round (#(procedure #:clean #:enforce) round (number) number)
       ((fixnum) (fixnum) #(1))
       ((float) (float)
	(##core#inline_allocate ("C_a_i_flonum_round_proper" 4) #(1))))

(exact->inexact (#(procedure #:clean #:enforce) exact->inexact (number) float)
		((float) #(1))
		((fixnum) (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))))

(inexact->exact (#(procedure #:clean #:enforce) inexact->exact (number) fixnum) ((fixnum) #(1)))

(exp (#(procedure #:clean #:enforce) exp (number) float)
     ((float) (##core#inline_allocate ("C_a_i_flonum_exp" 4) #(1))))

(log (#(procedure #:clean #:enforce) log (number) float)
     ((float) (##core#inline_allocate ("C_a_i_flonum_log" 4) #(1))))

(expt (#(procedure #:clean #:enforce) expt (number number) number)
      ((float float) (float)
       (##core#inline_allocate ("C_a_i_flonum_expt" 4) #(1) #(2)))
      ((float fixnum) (float)
       (##core#inline_allocate ("C_a_i_flonum_expt" 4) 
			       #(1)
			       (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
      ((fixnum float) (float)
       (##core#inline_allocate ("C_a_i_flonum_expt" 4)
			       (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
			       #(2))))

(sqrt (#(procedure #:clean #:enforce) sqrt (number) float)
      ((float) (##core#inline_allocate ("C_a_i_flonum_sqrt" 4) #(1))))

(sin (#(procedure #:clean #:enforce) sin (number) float)
     ((float) (##core#inline_allocate ("C_a_i_flonum_sin" 4) #(1))))

(cos (#(procedure #:clean #:enforce) cos (number) float)
     ((float) (##core#inline_allocate ("C_a_i_flonum_cos" 4) #(1))))

(tan (#(procedure #:clean #:enforce) tan (number) float)
     ((float) (##core#inline_allocate ("C_a_i_flonum_tan" 4) #(1))))

(asin (#(procedure #:clean #:enforce) asin (number) float) 
      ((float) (##core#inline_allocate ("C_a_i_flonum_asin" 4) #(1))))

(acos (#(procedure #:clean #:enforce) acos (number) float)
      ((float) (##core#inline_allocate ("C_a_i_flonum_acos" 4) #(1))))

(atan (#(procedure #:clean #:enforce) atan (number #!optional number) float)
      ((float) (##core#inline_allocate ("C_a_i_flonum_atan" 4) #(1)))
      ((float fixnum)
       (##core#inline_allocate ("C_a_i_flonum_atan2" 4) 
			       #(1)
			       (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(2))))
      ((fixnum float)
       (##core#inline_allocate ("C_a_i_flonum_atan2" 4) 
			       (##core#inline_allocate ("C_a_i_fix_to_flo" 4) #(1))
			       #(2)))
      ((float float) (##core#inline_allocate ("C_a_i_flonum_atan2" 4) #(1) #(2))))

(number->string (#(procedure #:clean #:enforce) number->string (number #!optional fixnum) string)
		((fixnum) (##sys#fixnum->string #(1))))

(string->number (#(procedure #:clean #:enforce) string->number (string #!optional fixnum) 
		 (or number false)))

(char? (#(procedure #:pure #:predicate char) char? (*) boolean))

;; we could rewrite these, but this is done by the optimizer anyway (safe)
(char=? (#(procedure #:clean #:enforce) char=? (char char) boolean))
(char>? (#(procedure #:clean #:enforce) char>? (char char) boolean))
(char<? (#(procedure #:clean #:enforce) char<? (char char) boolean))
(char>=? (#(procedure #:clean #:enforce) char>=? (char char) boolean))
(char<=? (#(procedure #:clean #:enforce) char<=? (char char) boolean))

(char-ci=? (#(procedure #:clean #:enforce) char-ci=? (char char) boolean))
(char-ci<? (#(procedure #:clean #:enforce) char-ci<? (char char) boolean))
(char-ci>? (#(procedure #:clean #:enforce) char-ci>? (char char) boolean))
(char-ci>=? (#(procedure #:clean #:enforce) char-ci>=? (char char) boolean))
(char-ci<=? (#(procedure #:clean #:enforce) char-ci<=? (char char) boolean))
(char-alphabetic? (#(procedure #:clean #:enforce) char-alphabetic? (char) boolean))
(char-whitespace? (#(procedure #:clean #:enforce) char-whitespace? (char) boolean))
(char-numeric? (#(procedure #:clean #:enforce) char-numeric? (char) boolean))
(char-upper-case? (#(procedure #:clean #:enforce) char-upper-case? (char) boolean))
(char-lower-case? (#(procedure #:clean #:enforce) char-lower-case? (char) boolean))
(char-upcase (#(procedure #:clean #:enforce) char-upcase (char) char))
(char-downcase (#(procedure #:clean #:enforce) char-downcase (char) char))

(char->integer (#(procedure #:clean #:enforce) char->integer (char) fixnum))
(integer->char (#(procedure #:clean #:enforce) integer->char (fixnum) char))

(string? (#(procedure #:pure #:predicate string) string? (*) boolean))

(string=? (#(procedure #:clean #:enforce) string=? (string string) boolean)
	  ((string string) (##core#inline "C_u_i_string_equal_p" #(1) #(2))))

(string>? (#(procedure #:clean #:enforce) string>? (string string) boolean))
(string<? (#(procedure #:clean #:enforce) string<? (string string) boolean))
(string>=? (#(procedure #:clean #:enforce) string>=? (string string) boolean))
(string<=? (#(procedure #:clean #:enforce) string<=? (string string) boolean))
(string-ci=? (#(procedure #:clean #:enforce) string-ci=? (string string) boolean))
(string-ci<? (#(procedure #:clean #:enforce) string-ci<? (string string) boolean))
(string-ci>? (#(procedure #:clean #:enforce) string-ci>? (string string) boolean))
(string-ci>=? (#(procedure #:clean #:enforce) string-ci>=? (string string) boolean))
(string-ci<=? (#(procedure #:clean #:enforce) string-ci<=? (string string) boolean))

(make-string (#(procedure #:clean #:enforce) make-string (fixnum #!optional char) string)
	     ((fixnum char) (##sys#make-string #(1) #(2)))
	     ((fixnum) (##sys#make-string #(1) '#\space)))

(string-length (#(procedure #:clean #:enforce) string-length (string) fixnum)
	       ((string) (##sys#size #(1))))

(string-ref (#(procedure #:clean #:enforce) string-ref (string fixnum) char)
	    ((string fixnum) (##core#inline "C_subchar" #(1) #(2))))

(string-set! (#(procedure #:enforce) string-set! (string fixnum char) undefined)
	     ((string fixnum char) (##core#inline "C_setsubchar" #(1) #(2) #(3))))

(string-append (#(procedure #:clean #:enforce) string-append (#!rest string) string)
	       ((string string) (##sys#string-append #(1) #(2))))

;(string-copy (#(procedure #:clean #:enforce) string-copy (string) string)) - we use the more general version from srfi-13

(string->list (#(procedure #:clean #:enforce) string->list (string) (list-of char)))
(list->string (#(procedure #:clean #:enforce) list->string ((list-of char)) string))
(substring (#(procedure #:clean #:enforce) substring (string fixnum #!optional fixnum) string))
;(string-fill! (#(procedure #:clean #:enforce) string-fill! (string char) string)) - s.a.
(string (#(procedure #:clean #:enforce) string (#!rest char) string))

(vector? (#(procedure #:pure #:predicate vector) vector? (*) boolean))

;; special-cased (see scrutinizer.scm)
(make-vector (forall (a) (#(procedure #:clean #:enforce) make-vector (fixnum #!optional a) 
			  (vector-of a))))

;; these are special cased (see scrutinizer.scm)
(vector-ref (forall (a) (#(procedure #:clean #:enforce) vector-ref ((vector-of a) fixnum) a)))
(##sys#vector-ref (forall (a) (#(procedure #:clean #:enforce) ##sys#vector-ref ((vector-of a) fixnum) a)))

(vector-set! (#(procedure #:enforce) vector-set! (vector fixnum *) undefined))

;; special cased (see scrutinizer.scm)
(vector (#(procedure #:pure) vector (#!rest) vector))
(##sys#vector (#(procedure #:pure) ##sys#vector (#!rest) vector))

(vector-length (#(procedure #:clean #:enforce) vector-length (vector) fixnum)
	       ((vector) (##sys#size #(1))))
(##sys#vector-length (#(procedure #:clean #:enforce) ##sys#vector-length (vector) fixnum)
		     ((vector) (##sys#size #(1))))

(vector->list (forall (a) (#(procedure #:clean #:enforce) vector->list ((vector-of a)) (list-of a))))
(##sys#vector->list (forall (a) (#(procedure #:clean #:enforce) ##sys#vector->list ((vector-of a)) (list-of a))))
(list->vector (forall (a) (#(procedure #:clean #:enforce) list->vector ((list-of a)) (vector-of a))))
(##sys#list->vector (forall (a) (#(procedure #:clean #:enforce) ##sys#list->vector ((list-of a)) (vector-of a))))
(vector-fill! (#(procedure #:enforce) vector-fill! (vector *) undefined))

(procedure? (#(procedure #:pure #:predicate procedure) procedure? (*) boolean))

(vector-copy! (#(procedure #:enforce) vector-copy! (vector vector #!optional fixnum) undefined))

(map (forall (a b) (#(procedure #:enforce) map ((procedure (a #!rest) b) (list-of a) #!rest list) (list-of b))))

(for-each
 (forall (a) (#(procedure #:enforce) for-each ((procedure (a #!rest) . *) (list-of a) #!rest list) undefined)))

(apply (#(procedure #:enforce) apply (procedure #!rest) . *))
(##sys#apply (#(procedure #:enforce) ##sys#apply (procedure #!rest) . *))

(force (procedure force (*) . *)
       (((not (struct promise))) #(1)))

(call-with-current-continuation
 (#(procedure #:enforce) call-with-current-continuation ((procedure (procedure) . *)) . *))

(input-port? (#(procedure #:pure #:predicate input-port) input-port? (*) boolean))
(output-port? (#(procedure #:pure #:predicate output-port) output-port? (*) boolean))

(current-input-port
 (#(procedure #:clean #:enforce) current-input-port (#!optional input-port) input-port)
 ((input-port) (let ((#(tmp1) #(1))) 
		 (let ((#(tmp2) (set! ##sys#standard-input #(tmp1))))
		   #(tmp1))))
 (() ##sys#standard-input))

(current-output-port
 (#(procedure #:clean #:enforce) current-output-port (#!optional output-port) output-port)
 ((output-port) (let ((#(tmp1) #(1)))
		  (let ((#(tmp2) (set! ##sys#standard-output #(tmp1))))
		    #(tmp1))))
 (() ##sys#standard-output))

(call-with-input-file
    (procedure call-with-input-file (string (procedure (input-port) . *) #!rest) . *))

(call-with-output-file
    (procedure call-with-output-file (string (procedure (output-port) . *) #!rest) . *))

(open-input-file (#(procedure #:clean #:enforce) open-input-file (string #!rest symbol) input-port))
(open-output-file (#(procedure #:clean #:enforce) open-output-file (string #!rest symbol) output-port))
(close-input-port (#(procedure #:enforce) close-input-port (input-port) undefined))
(close-output-port (#(procedure #:enforce) close-output-port (output-port) undefined))
(load (procedure load (string #!optional (procedure (*) . *)) undefined))
(read (#(procedure #:enforce) read (#!optional input-port) *))

(eof-object? (#(procedure #:pure #:predicate eof) eof-object? (*) boolean))

(read-char (#(procedure #:enforce) read-char (#!optional input-port) (or eof char)))
(peek-char (#(procedure #:enforce) peek-char (#!optional input-port) (or eof char)))

(write (#(procedure #:enforce) write (* #!optional output-port) undefined))
(display (#(procedure #:enforce) display (* #!optional output-port) undefined))
(write-char (#(procedure #:enforce) write-char (char #!optional output-port) undefined))

;;XXX Yes, that would be nice, but the output-port may be closed
#;(##sys#write-char-0
 (#(procedure #:enforce) ##sys#write-char-0 (char output-port) undefined)
 ((char output-port)
   (let ((#(tmp) #(1)))
     ((##sys#slot (##sys#slot #(tmp) '2) '2) #(tmp) #(2)))))

(newline (#(procedure #:enforce) newline (#!optional output-port) undefined))

(with-input-from-file
    (#(procedure #:enforce) with-input-from-file (string (procedure () . *) #!rest symbol) . *))

(with-output-to-file
    (#(procedure #:enforce) with-output-to-file (string (procedure () . *) #!rest symbol) . *))

(dynamic-wind
    (#(procedure #:enforce) dynamic-wind ((procedure () . *) (procedure () . *) (procedure () . *)) . *))

(values (#(procedure #:clean) values (#!rest values) . *))
(##sys#values (#(procedure #:clean) ##sys#values (#!rest values) . *))

(call-with-values (#(procedure #:enforce) call-with-values ((procedure () . *) procedure) . *)
  (((procedure () *) *) (let ((#(tmp1) #(1)))
			  (let ((#(tmp2) #(2)))
			    (#(tmp2) (#(tmp1)))))))

(##sys#call-with-values
 (#(procedure #:enforce) ##sys#call-with-values ((procedure () . *) procedure) . *)
 (((procedure () *) *) (let ((#(tmp1) #(1)))
			 (let ((#(tmp2) #(2)))
			   (#(tmp2) (#(tmp1)))))))

(eval (procedure eval (* #!optional (struct environment)) . *))
(char-ready? (#(procedure #:enforce) char-ready? (#!optional input-port) boolean))

(imag-part (#(procedure #:clean #:enforce) imag-part (number) number)
	   (((or fixnum float number)) (let ((#(tmp) #(1))) '0)))

(real-part (#(procedure #:clean #:enforce) real-part (number) number)
	   (((or fixnum float number)) #(1)))

(magnitude (#(procedure #:clean #:enforce) magnitude (number) number)
	   ((fixnum) (fixnum)
	    (##core#inline "C_fixnum_abs" #(1)))
	   ((float) (float)
	    (##core#inline_allocate ("C_a_i_flonum_abs" 4) #(1))))

(numerator (#(procedure #:clean #:enforce) numerator (number) number)
	   ((fixnum) (fixnum) #(1)))
	   
(denominator (#(procedure #:clean #:enforce) denominator (number) number)
	     ((fixnum) (fixnum) (let ((#(tmp) #(1))) '1)))

(scheme-report-environment 
 (#(procedure #:clean #:enforce) scheme-report-environment (#!optional fixnum) (struct environment)))

(null-environment
 (#(procedure #:clean #:enforce) null-environment (#!optional fixnum) (struct environment)))

(interaction-environment
 (#(procedure #:clean) interaction-environment () (struct environment)))

(port-closed? (#(procedure #:clean #:enforce) port-closed? (port) boolean)
	      ((port) (##sys#slot #(1) '8)))


;; chicken

(abort (procedure abort (*) noreturn))
(##sys#abort (procedure abort (*) noreturn))

(add1 (#(procedure #:clean #:enforce) add1 (number) number)
      ((float) (float) 
       (##core#inline_allocate ("C_a_i_flonum_plus" 4) #(1) '1.0)))

(argc+argv (#(procedure #:clean) argc+argv () fixnum (list-of string) fixnum))
(argv (#(procedure #:clean) argv () (list-of string)))
(arithmetic-shift (#(procedure #:clean #:enforce) arithmetic-shift (number number) number))

(bit-set? (#(procedure #:clean #:enforce) bit-set? (number fixnum) boolean)
	  ((fixnum fixnum) (##core#inline "C_u_i_bit_setp" #(1) #(2))))

(bitwise-and (#(procedure #:clean #:enforce) bitwise-and (#!rest number) number)
	     ((fixnum fixnum) (fixnum)
	      (##core#inline "C_fixnum_and" #(1) #(2))))

(bitwise-ior (#(procedure #:clean #:enforce) bitwise-ior (#!rest number) number)
	     ((fixnum fixnum) (fixnum)
	      (##core#inline "C_fixnum_or" #(1) #(2))))

(bitwise-not (#(procedure #:clean #:enforce) bitwise-not (number) number))

(bitwise-xor (#(procedure #:clean #:enforce) bitwise-xor (#!rest number) number)
	     ((fixnum fixnum) (fixnum) 
	      (##core#inline "C_fixnum_xor" #(1) #(2))))

(blob->string (#(procedure #:clean #:enforce) blob->string (blob) string))

(blob-size (#(procedure #:clean #:enforce) blob-size (blob) fixnum)
	   ((blob) (##sys#size #(1))))

(blob? (#(procedure #:pure #:predicate blob) blob? (*) boolean))

(blob=? (#(procedure #:clean #:enforce) blob=? (blob blob) boolean))
(build-platform (#(procedure #:pure) build-platform () symbol))
(call/cc (#(procedure #:enforce) call/cc ((procedure (*) . *)) . *))
(case-sensitive (#(procedure #:clean) case-sensitive (#!optional *) *))
(char-name (#(procedure #:clean #:enforce) char-name ((or char symbol) #!optional char) *)) ;XXX -> (or char symbol) ?
(chicken-home (#(procedure #:clean) chicken-home () string))
(chicken-version (#(procedure #:pure) chicken-version (#!optional *) string))
(command-line-arguments (#(procedure #:clean) command-line-arguments (#!optional (list-of string)) (list-of string)))
(condition-predicate (#(procedure #:clean #:enforce) condition-predicate (symbol) (procedure ((struct condition)) boolean)))
(condition-property-accessor (#(procedure #:clean #:enforce) condition-property-accessor (symbol symbol #!optional *) (procedure ((struct condition)) *)))

(condition? (#(procedure #:pure #:predicate (struct condition)) condition? (*) boolean))

(condition->list (#(procedure #:clean #:enforce) condition->list ((struct condition)) (list-of (pair symbol *))))
(continuation-capture (#(procedure #:enforce) continuation-capture ((procedure ((struct continuation)) . *)) *))
(continuation-graft (#(procedure #:clean #:enforce) continuation-graft ((struct continuation) (procedure () . *)) *))
(continuation-return (#(procedure #:enforce) continuation-return (procedure #!rest) . *)) ;XXX make return type more specific?

(continuation? (#(procedure #:pure #:predicate (struct continuation)) continuation? (*) boolean))

(copy-read-table (#(procedure #:clean #:enforce) copy-read-table ((struct read-table)) (struct read-table)))
(cpu-time (#(procedure #:clean) cpu-time () fixnum fixnum))

(current-error-port
 (#(procedure #:clean #:enforce) current-error-port (#!optional output-port) output-port)
 ((output-port) (let ((#(tmp1) #(1))) 
		  (let ((#(tmp2) (set! ##sys#standard-error #(tmp1))))
		    #(tmp1))))
 (() ##sys#standard-error))

(current-exception-handler
 (#(procedure #:clean #:enforce) current-exception-handler (#!optional (procedure (*) noreturn)) procedure)
 ((procedure) (let ((#(tmp1) #(1))) 
		(let ((#(tmp2) (set! ##sys#current-exception-handler #(tmp1))))
		  #(tmp1))))
 (() ##sys#current-exception-handler))

(current-gc-milliseconds (#(procedure #:clean) current-gc-milliseconds () fixnum))
(current-milliseconds (#(procedure #:clean) current-milliseconds () float))

(current-read-table
 (#(procedure #:clean) current-read-table (#!optional (struct read-table)) (struct read-table)))

(current-seconds (#(procedure #:clean) current-seconds () float))
(define-reader-ctor (#(procedure #:clean #:enforce) define-reader-ctor (symbol procedure) undefined))
(delete-file (#(procedure #:clean #:enforce) delete-file (string) string))
(enable-warnings (#(procedure #:clean) enable-warnings (#!optional *) *))

(equal=? (#(procedure #:clean) equal=? (* *) boolean)
	 ((fixnum fixnum) (eq? #(1) #(2)))
	 (((or symbol char eof null) *) (eq? #(1) #(2)))
	 ((* (or symbol char eof null undefined)) (eq? #(1) #(2)))
	 (((or float fixnum number) (or float fixnum number)) (= #(1) #(2))))

(er-macro-transformer
 (#(procedure #:clean #:enforce) 
  er-macro-transformer
  ((procedure (* (procedure (*) *) (procedure (* *) *)) *))
  (struct transformer)))

(errno (#(procedure #:clean) errno () fixnum))
(error (procedure error (* #!rest) noreturn))
(##sys#error (procedure ##sys#error (* #!rest) noreturn))
(##sys#signal-hook (procedure ##sys#signal-hook (* #!rest) noreturn))
(exit (procedure exit (#!optional fixnum) noreturn))
(exit-handler (#(procedure #:clean #:enforce) exit-handler (#!optional (procedure (fixnum) . *)) procedure))
(expand (procedure expand (* #!optional list) *))
(extension-information (#(procedure #:clean) extension-information (symbol) *))
(feature? (#(procedure #:clean) feature? (#!rest symbol) boolean))
(features (#(procedure #:clean) features () (list-of symbol)))
(file-exists? (#(procedure #:clean #:enforce) file-exists? (string) (or false string)))
(directory-exists? (#(procedure #:clean #:enforce) directory-exists? (string) (or false string)))

(finite? (#(procedure #:clean #:enforce) finite? (number) boolean)
	 ((fixnum) (let ((#(tmp) #(1))) '#t))
	 (((or float number)) (##core#inline "C_i_finitep" #(1))))

(fixnum-bits fixnum)
(fixnum-precision fixnum)

(fixnum? (#(procedure #:pure #:predicate fixnum) fixnum? (*) boolean))

(flonum-decimal-precision fixnum)
(flonum-epsilon float)
(flonum-maximum-decimal-exponent fixnum)
(flonum-maximum-exponent fixnum)
(flonum-minimum-decimal-exponent fixnum)
(flonum-minimum-exponent fixnum)
(flonum-precision fixnum)
(flonum-print-precision (#(procedure #:clean #:enforce) (#!optional fixnum) fixnum))
(flonum-radix fixnum)

(flonum? (#(procedure #:pure #:predicate float) flonum? (*) boolean))

(flush-output (#(procedure #:enforce) flush-output (#!optional output-port) undefined))

(foldl (forall (a b) (#(procedure #:enforce) foldl ((procedure (a b) a) a (list-of b)) a)))
(foldr (forall (a b) (#(procedure #:enforce) foldr ((procedure (a b) b) b (list-of a)) b)))

(force-finalizers (procedure force-finalizers () undefined))

(fp- (#(procedure #:clean #:enforce) fp- (float float) float)
     ((float float) (##core#inline_allocate ("C_a_i_flonum_difference" 4) #(1) #(2)) ))

(fp* (#(procedure #:clean #:enforce) fp* (float float) float)
     ((float float) (##core#inline_allocate ("C_a_i_flonum_times" 4) #(1) #(2)) ))

(fp/ (#(procedure #:clean #:enforce) fp/ (float float) float)
     ((float float) (##core#inline_allocate ("C_a_i_flonum_quotient" 4) #(1) #(2)) ))

(fp+ (#(procedure #:clean #:enforce) fp+ (float float) float)
     ((float float) (##core#inline_allocate ("C_a_i_flonum_plus" 4) #(1) #(2)) ))

(fp< (#(procedure #:clean #:enforce) fp< (float float) boolean)
     ((float float) (##core#inline "C_flonum_lessp" #(1) #(2)) ))

(fp<= (#(procedure #:clean #:enforce) fp<= (float float) boolean)
      ((float float) (##core#inline "C_flonum_less_or_equal_p" #(1) #(2)) ))

(fp= (#(procedure #:clean #:enforce) fp= (float float) boolean)
     ((float float) (##core#inline "C_flonum_equalp" #(1) #(2)) ))

(fp> (#(procedure #:clean #:enforce) fp> (float float) boolean)
     ((float float) (##core#inline "C_flonum_greaterp" #(1) #(2)) ))

(fp>= (#(procedure #:clean #:enforce) fp>= (float float) boolean)
      ((float float) (##core#inline "C_flonum_greater_or_equal_p" #(1) #(2)) ))

(fpabs (#(procedure #:clean #:enforce) fpabs (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_abs" 4) #(1) )))

(fpacos (#(procedure #:clean #:enforce) fpacos (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_acos" 4) #(1) )))

(fpasin (#(procedure #:clean #:enforce) fpasin (float) float)
	((float) (##core#inline_allocate ("C_a_i_flonum_asin" 4) #(1) )))

(fpatan (#(procedure #:clean #:enforce) fpatan (float) float)
	((float) (##core#inline_allocate ("C_a_i_flonum_atan" 4) #(1) )))

(fpatan2 (#(procedure #:clean #:enforce) fpatan2 (float float) float)
	 ((float float) (##core#inline_allocate ("C_a_i_flonum_atan2" 4)
						#(1) #(2))))
(fpceiling (#(procedure #:clean #:enforce) fpceiling (float) float)
	   ((float) (##core#inline_allocate ("C_a_i_flonum_ceiling" 4) #(1) )))

(fpcos (#(procedure #:clean #:enforce) fpcos (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_cos" 4) #(1) )))

(fpexp (#(procedure #:clean #:enforce) fpexp (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_exp" 4) #(1) )))

(fpexpt (#(procedure #:clean #:enforce) fpexpt (float float) float)
	((float float) (##core#inline_allocate ("C_a_i_flonum_expt" 4)
					       #(1) #(2))))

(fpfloor (#(procedure #:clean #:enforce) fpfloor (float) float)
	 ((float) (##core#inline_allocate ("C_a_i_flonum_floor" 4) #(1) )))

(fpinteger? (#(procedure #:clean #:enforce) fpinteger? (float) boolean)
	    ((float) (##core#inline "C_u_i_fpintegerp" #(1) )))

(fplog (#(procedure #:clean #:enforce) fplog (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_log" 4) #(1) )))

(fpmax (#(procedure #:clean #:enforce) fpmax (float float) float)
       ((float float) (##core#inline "C_i_flonum_max" #(1) #(2))))

(fpmin (#(procedure #:clean #:enforce) fpmin (float float) float)
       ((float float) (##core#inline "C_i_flonum_min" #(1) #(2))))

(fpneg (#(procedure #:clean #:enforce) fpneg (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_negate" 4) #(1) )))

(fpround (#(procedure #:clean #:enforce) fpround (float) float)
	 ((float) (##core#inline_allocate ("C_a_i_flonum_round" 4) #(1) )))

(fpsin (#(procedure #:clean #:enforce) fpsin (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_sin" 4) #(1) )))

(fpsqrt (#(procedure #:clean #:enforce) fpsqrt (float) float)
	((float) (##core#inline_allocate ("C_a_i_flonum_sqrt" 4) #(1) )))

(fptan (#(procedure #:clean #:enforce) fptan (float) float)
       ((float) (##core#inline_allocate ("C_a_i_flonum_tan" 4) #(1) )))

(fptruncate (#(procedure #:clean #:enforce) fptruncate (float) float)
	    ((float) (##core#inline_allocate ("C_a_i_flonum_truncate" 4) #(1) )))

;;XXX should these be enforcing?
(fx- (#(procedure #:clean) fx- (fixnum fixnum) fixnum))
(fx* (#(procedure #:clean) fx* (fixnum fixnum) fixnum))
(fx/ (#(procedure #:clean) fx/ (fixnum fixnum) fixnum))
(fx+ (#(procedure #:clean) fx+ (fixnum fixnum) fixnum))
(fx< (#(procedure #:clean) fx< (fixnum fixnum) boolean))
(fx<= (#(procedure #:clean) fx<= (fixnum fixnum) boolean))
(fx= (#(procedure #:clean) fx= (fixnum fixnum) boolean))
(fx> (#(procedure #:clean) fx> (fixnum fixnum) boolean))
(fx>= (#(procedure #:clean) fx>= (fixnum fixnum) boolean))
(fxand (#(procedure #:clean) fxand (fixnum fixnum) fixnum))
(fxeven? (#(procedure #:clean) fxeven? (fixnum) boolean))
(fxior (#(procedure #:clean) fxior (fixnum fixnum) fixnum))
(fxmax (#(procedure #:clean) fxmax (fixnum fixnum) fixnum))
(fxmin (#(procedure #:clean) fxmin (fixnum fixnum) fixnum))
(fxmod (#(procedure #:clean) fxmod (fixnum fixnum) fixnum))
(fxneg (#(procedure #:clean) fxneg (fixnum) fixnum))
(fxnot (#(procedure #:clean) fxnot (fixnum) fixnum))
(fxodd? (#(procedure #:clean) fxodd? (fixnum) boolean))
(fxshl (#(procedure #:clean) fxshl (fixnum fixnum) fixnum))
(fxshr (#(procedure #:clean) fxshr (fixnum fixnum) fixnum))
(fxxor (#(procedure #:clean) fxxor (fixnum fixnum) fixnum))
(gc (#(procedure #:clean) gc (#!optional *) fixnum))
(gensym (#(procedure #:clean) gensym (#!optional (or string symbol)) symbol))

(get (#(procedure #:clean #:enforce) get (symbol symbol #!optional *) *)
     ((symbol symbol *) (##core#inline "C_i_getprop" #(1) #(2) #(3))))

(get-call-chain (#(procedure #:clean #:enforce) get-call-chain (#!optional fixnum (struct thread)) (list-of vector)))
(get-condition-property (#(procedure #:clean #:enforce) get-condition-property ((struct condition) symbol symbol #!optional *) *))
(get-environment-variable (#(procedure #:clean #:enforce) get-environment-variable (string) *))
(get-keyword (#(procedure #:clean #:enforce) get-keyword (symbol list #!optional *) *))
(get-output-string (#(procedure #:clean #:enforce) get-output-string (output-port) string))
(get-properties (#(procedure #:clean #:enforce) get-properties (symbol list) symbol * list))

(getter-with-setter
 (#(procedure #:clean #:enforce)
  getter-with-setter
  ((procedure (#!rest) *) (procedure (* #!rest) . *) #!optional string)
  procedure))

(implicit-exit-handler
 (#(procedure #:clean #:enforce) implicit-exit-handler (#!optional (procedure () . *)) procedure))

(ir-macro-transformer
 (#(procedure #:clean #:enforce)
  ir-macro-transformer
  ((procedure (* (procedure (*) *) (procedure (* *) *)) *))
  (struct transformer)))

(keyword->string (#(procedure #:clean #:enforce) keyword->string (symbol) string))
(keyword-style (#(procedure #:clean) keyword-style (#!optional symbol) symbol))
(keyword? (#(procedure #:pure) keyword? (*) boolean))
(load-library (#(procedure #:enforce) load-library (symbol #!optional string) undefined))
(load-relative (#(procedure #:enforce) load-relative (string #!optional (procedure (*) . *)) undefined))
(load-verbose (#(procedure #:clean) load-verbose (#!optional *) *))
(machine-byte-order (#(procedure #:pure) machine-byte-order () symbol))
(machine-type (#(procedure #:pure) machine-type () symbol))

(make-blob (#(procedure #:clean #:enforce) make-blob (fixnum) blob)
	   ((fixnum) (##sys#make-blob #(1))))

(make-composite-condition (#(procedure #:clean #:enforce) make-composite-condition (#!rest (struct condition)) (struct condition)))
(make-parameter (#(procedure #:clean #:enforce) make-parameter (* #!optional procedure) procedure))
(make-property-condition (#(procedure #:clean #:enforce) make-property-condition (symbol #!rest *) (struct condition)))
(maximum-flonum float)
(memory-statistics (#(procedure #:clean) memory-statistics () (vector-of fixnum)))
(minimum-flonum float)
(module-environment (#(procedure #:clean #:enforce) module-environment (symbol #!optional symbol) (struct environment)))
(most-negative-fixnum fixnum)
(most-positive-fixnum fixnum)
(on-exit (#(procedure #:clean #:enforce) on-exit ((procedure () . *)) undefined))
(open-input-string (#(procedure #:clean #:enforce) open-input-string (string #!rest) input-port))
(open-output-string (#(procedure #:clean) open-output-string (#!rest) output-port))
(parentheses-synonyms (#(procedure #:clean) parentheses-synonyms (#!optional *) *))

(port-name (#(procedure #:clean #:enforce) port-name (#!optional port) *)
	   ((port) (##sys#slot #(1) '3)))

(port-position (#(procedure #:clean #:enforce) port-position (#!optional port) fixnum fixnum))

(port? (#(procedure #:pure #:predicate (or input-port output-port)) port? (*) boolean))

(print (procedure print (#!rest *) undefined))
(print-call-chain (#(procedure #:clean #:enforce) print-call-chain (#!optional output-port fixnum * string) undefined))
(print-error-message (#(procedure #:clean #:enforce) print-error-message (* #!optional output-port string) undefined))
(print* (procedure print* (#!rest) undefined))
(procedure-information (#(procedure #:clean #:enforce) procedure-information (procedure) *))
(program-name (#(procedure #:clean #:enforce) program-name (#!optional string) string))
(promise? (#(procedure #:pure #:predicate (struct promise)) promise? (*) boolean))

(make-promise (#(procedure #:enforce) make-promise (*) (struct promise))
              (((struct promise)) #(1)))

(put! (#(procedure #:clean #:enforce) put! (symbol symbol *) undefined)
      ((symbol symbol *)
       (##core#inline_allocate ("C_a_i_putprop" 8) #(1) #(2) #(3))))

(quit (procedure quit (#!optional *) noreturn))
(register-feature! (#(procedure #:clean #:enforce) register-feature! (#!rest symbol) undefined))
(remprop! (#(procedure #:clean #:enforce) remprop! (symbol symbol) undefined))
(rename-file (#(procedure #:clean #:enforce) rename-file (string string) string))
(repl (#(procedure #:enforce) repl (#!optional (procedure (*) . *)) undefined))
(repl-prompt (#(procedure #:clean #:enforce) repl-prompt (#!optional (procedure () string)) procedure))
(repository-path (#(procedure #:clean) repository-path (#!optional *) *))
(require (#(procedure #:clean) require (#!rest (or string symbol)) undefined))
(reset (procedure reset () noreturn))
(reset-handler (#(procedure #:clean #:enforce) reset-handler (#!optional (procedure () . *)) procedure))
(return-to-host (procedure return-to-host () . *))
(reverse-list->string (#(procedure #:clean #:enforce) reverse-list->string ((list-of char)) string))
(set-finalizer! (#(procedure #:clean #:enforce) set-finalizer! (* (procedure (*) . *)) *))
(set-gc-report! (#(procedure #:clean) set-gc-report! (*) undefined))

(set-parameterized-read-syntax!
 (#(procedure #:clean #:enforce) set-parameterized-read-syntax!
  (char (or false (procedure (input-port fixnum) . *)))
  undefined))

(set-port-name! (#(procedure #:clean #:enforce) set-port-name! (port string) undefined)
		((port string) (##sys#setslot #(1) '3 #(2))))

(set-read-syntax!
 (#(procedure #:clean #:enforce) set-read-syntax!
  (char (or false (procedure (input-port) . *)))
  undefined))

(set-sharp-read-syntax!
 (#(procedure #:clean #:enforce) set-sharp-read-syntax!
  (char (or false (procedure (input-port) . *))) undefined))

(setter (#(procedure #:clean #:enforce) setter (procedure) procedure))
(signal (procedure signal (*) . *))
(signum (#(procedure #:clean #:enforce) signum (number) number))
(software-type (#(procedure #:pure) software-type () symbol))
(software-version (#(procedure #:pure) software-version () symbol))
(string->blob (#(procedure #:clean #:enforce) string->blob (string) blob))
(string->keyword (#(procedure #:clean #:enforce) string->keyword (string) symbol))
(string->uninterned-symbol (#(procedure #:clean #:enforce) string->uninterned-symbol (string) symbol))
(strip-syntax (#(procedure #:clean) strip-syntax (*) *))

(sub1 (#(procedure #:clean #:enforce) sub1 (number) number)
      ((float) (float)
       (##core#inline_allocate ("C_a_i_flonum_difference" 4) #(1) '1.0)))

(subvector (forall (a) (#(procedure #:clean #:enforce) subvector ((vector-of a) fixnum #!optional fixnum) (vector-of a))))
(symbol-escape (#(procedure #:clean) symbol-escape (#!optional *) *))

(symbol-plist (#(procedure #:clean #:enforce) symbol-plist (symbol) list)
	      ((symbol) (##sys#slot #(1) '2)))

(syntax-error (procedure syntax-error (* #!rest) noreturn))
(system (#(procedure #:clean #:enforce) system (string) fixnum))
(unregister-feature! (#(procedure #:clean #:enforce) unregister-feature! (#!rest symbol) undefined))
(vector-resize
 (forall (a b) (#(procedure #:clean #:enforce) vector-resize ((vector-of a) fixnum #!optional b)
	       (vector-of (or a b)))))
(void (#(procedure #:pure) void (#!rest) undefined))
(##sys#void (#(procedure #:pure) void (#!rest) undefined))
(warning (procedure warning (* #!rest) undefined))

(with-exception-handler
 (#(procedure #:enforce) with-exception-handler ((procedure (*) . *) (procedure () . *)) . *))


;; chicken (internal)

(##sys#foreign-char-argument (#(procedure #:clean #:enforce) ##sys#foreign-char-argument (char) char)
			     ((char) #(1)))
(##sys#foreign-fixnum-argument (#(procedure #:clean #:enforce) ##sys#foreign-fixnum-argument (fixnum) fixnum)
			       ((fixnum) #(1)))
(##sys#foreign-flonum-argument (#(procedure #:clean #:enforce) ##sys#foreign-flonum-argument (number) number)
			       ((float) #(1)))
(##sys#foreign-string-argument (#(procedure #:clean #:enforce) ##sys#foreign-string-argument (string) string)
			       ((string) #(1)))
(##sys#foreign-symbol-argument (#(procedure #:clean #:enforce) ##sys#foreign-symbol-argument (symbol) symbol)
			       ((symbol) #(1)))
(##sys#foreign-pointer-argument (#(procedure #:clean #:enforce) ##sys#foreign-pointer-argument ((or pointer false)) pointer)
				((pointer) #(1)))

(##sys#check-blob (#(procedure #:clean #:enforce) ##sys#check-blob (blob #!optional *) *)
		  ((blob) (let ((#(tmp) #(1))) '#t))
		  ((blob *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-pair (#(procedure #:clean #:enforce) ##sys#check-pair (pair #!optional *) *)
		  ((pair) (let ((#(tmp) #(1))) '#t))
		  ((pair *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-list (#(procedure #:clean #:enforce) ##sys#check-list (list #!optional *) *)
		  (((or null pair list)) (let ((#(tmp) #(1))) '#t))
		  (((or null pair list) *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-string (#(procedure #:clean #:enforce) ##sys#check-string (string #!optional *) *)
		    ((string) (let ((#(tmp) #(1))) '#t))
		    ((string) * (let ((#(tmp) #(1))) '#t)))
(##sys#check-number (#(procedure #:clean #:enforce) ##sys#check-number (number #!optional *) *)
		    ((number) (let ((#(tmp) #(1))) '#t))
		    ((number *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-exact (#(procedure #:clean #:enforce) ##sys#check-exact (fixnum #!optional *) *)
		   ((fixnum) (let ((#(tmp) #(1))) '#t))
		   ((fixnum *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-inexact (#(procedure #:clean #:enforce) ##sys#check-inexact (float #!optional *) *)
		     ((float) (let ((#(tmp) #(1))) '#t))
		     ((float *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-symbol (#(procedure #:clean #:enforce) ##sys#check-symbol (symbol #!optional *) *)
		    ((symbol) (let ((#(tmp) #(1))) '#t))
		    ((symbol *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-vector (#(procedure #:clean #:enforce) ##sys#check-vector (vector #!optional *) *)
		    ((vector) (let ((#(tmp) #(1))) '#t))
		    ((vector *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-char (#(procedure #:clean #:enforce) ##sys#check-char (char #!optional *) *)
		  ((char) (let ((#(tmp) #(1))) '#t))
		  ((char *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-boolean (#(procedure #:clean #:enforce) ##sys#check-boolean (boolean #!optional *) *)
		     ((boolean) (let ((#(tmp) #(1))) '#t))
		     ((boolean *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-locative (#(procedure #:clean #:enforce) ##sys#check-locative (locative #!optional *) *)
		      ((locative) (let ((#(tmp) #(1))) '#t))
		      ((locative *) (let ((#(tmp) #(1))) '#t)))
(##sys#check-closure (#(procedure #:clean #:enforce) ##sys#check-closure (procedure #!optional *) *)
		     ((procedure) (let ((#(tmp) #(1))) '#t))
		     ((procedure *) (let ((#(tmp) #(1))) '#t)))

(##sys#check-port 
 (#(procedure #:clean #:enforce) ##sys#check-port ((or input-port output-port) #!optional *)
  *)
 (((or input-port output-port)) (let ((#(tmp) #(1))) '#t))
 (((or input-port output-port) *) (let ((#(tmp) #(1))) '#t)))

(##sys#check-input-port
 (#(procedure #:clean #:enforce) ##sys#check-input-port (input-port * #!optional *) *)
 ((* *) (##core#inline "C_i_check_port" #(1) '#t #(2)))
 ((* * *) (##core#inline "C_i_check_port_2" #(1) '#t #(2) #(3))))

(##sys#check-output-port
 (#(procedure #:clean #:enforce) ##sys#check-output-port (output-port * #!optional *) *)
 ((* *) (##core#inline "C_i_check_port" #(1) '#f #(2)))
 ((* * *) (##core#inline "C_i_check_port_2" #(1) '#f #(2) #(3))))

(##sys#check-open-port
 (#(procedure #:clean #:enforce) ##sys#check-open-port ((or input-port output-port) #!optional *) *)
 ((*) (##core#inline "C_i_check_port" #(1) '0 '#t))
 ((* *) (##core#inline "C_i_check_port_2" #(1) '0 '#t #(2))))

(##sys#setslot (#(procedure #:enforce) ##sys#setslot (* fixnum *) *)
	       #;((* fixnum immediate) (##sys#setislot #(1) #(2) #(3)))) ; too dangerous
(##sys#size (#(procedure #:pure) ##sys#size (*) fixnum))

(##sys#standard-input input-port)
(##sys#standard-output output-port)
(##sys#standard-error output-port)


;; data-structures

(->string (procedure ->string (*) string)
	  ((string) #(1)))

(alist-ref (#(procedure #:clean #:enforce) alist-ref (* (list-of pair) #!optional (procedure (* *) *) *) *))
(alist-update! (#(procedure #:enforce) alist-update! (* * (list-of pair) #!optional (procedure (* *) *)) *))
(alist-update (#(procedure #:clean #:enforce) alist-update (* * (list-of pair) #!optional (procedure (* *) *) *) *))

(any? (#(procedure #:pure) any? (*) boolean)
      ((*) (let ((#(tmp) #(1))) '#t)))

(atom? (#(procedure #:pure) atom? (*) boolean)
       ((pair) (let ((#(tmp) #(1))) '#f))
       (((not (or pair list))) (let ((#(tmp) #(1))) '#t)))

(binary-search (forall (a) (#(procedure #:enforce) binary-search ((vector-of a) (procedure (a) *)) *)))
(butlast (forall (a) (#(procedure #:clean #:enforce) butlast ((pair a *)) (list-of a))))
(chop (forall (a) (#(procedure #:clean #:enforce) chop ((list-of a) fixnum) (list-of a))))
(complement (#(procedure #:clean #:enforce) complement ((procedure (#!rest) *)) (procedure (#!rest) boolean)))
(compose (#(procedure #:clean #:enforce) compose (#!rest procedure) procedure))
(compress (forall (a) (#(procedure #:clean #:enforce) compress (list (list-of a)) (list-of a))))
(conc (procedure conc (#!rest) string))
(conjoin (#(procedure #:clean #:enforce) conjoin (#!rest (procedure (*) *)) (procedure (*) *)))
(constantly (forall (a) (#(procedure #:pure) constantly (a) (procedure (#!rest) a))))
(disjoin (#(procedure #:clean #:enforce) disjoin (#!rest (procedure (*) *)) (procedure (*) *)))
(each (#(procedure #:clean #:enforce) each (#!rest procedure) procedure))
(flatten (#(procedure #:clean #:enforce) flatten (#!rest *) list))
(flip (#(procedure #:clean #:enforce) flip ((procedure (* *) . *)) (procedure (* *) . *)))
(identity (forall (a) (#(procedure #:pure) identity (a) a)))
(intersperse (#(procedure #:clean #:enforce) intersperse (list *) list))
(join (#(procedure #:clean #:enforce) join ((list-of list) #!optional list) list))
(list->queue (#(procedure #:clean #:enforce) list->queue (list) (struct queue)))
(list-of? (#(procedure #:clean #:enforce) list-of? ((procedure (*) *)) (procedure (list) boolean)))
(make-queue (#(procedure #:pure) make-queue () (struct queue)))

(merge 
 (forall (e)
	 (#(procedure #:enforce) merge ((list-of e) (list-of e) (procedure (e e) *)) (list-of e))))

(merge!
 (forall (e)
	 (#(procedure #:enforce) merge! ((list-of e) (list-of e) (procedure (e e) *)) (list-of e))))

(o (#(procedure #:clean #:enforce) o (#!rest (procedure (*) *)) (procedure (*) *)))
(queue->list (#(procedure #:clean #:enforce) queue->list ((struct queue)) list))
(queue-add! (#(procedure #:clean #:enforce) queue-add! ((struct queue) *) undefined))

(queue-empty? (#(procedure #:clean #:enforce) queue-empty? ((struct queue)) boolean)
	      (((struct queue)) (##core#inline "C_i_nullp" (##sys#slot #(1) '1))))

(queue-first (#(procedure #:clean #:enforce) queue-first ((struct queue)) *))
(queue-last (#(procedure #:clean #:enforce) queue-last ((struct queue)) *))

(queue-length (#(procedure #:clean #:enforce) queue-length ((struct queue)) fixnum)
	      (((struct queue)) (##sys#slot #(1) '3)))

(queue-push-back! (#(procedure #:clean #:enforce) queue-push-back! ((struct queue) *) undefined))
(queue-push-back-list! (#(procedure #:clean #:enforce) queue-push-back-list! ((struct queue) list) undefined))
(queue-remove! (#(procedure #:clean #:enforce) queue-remove! ((struct queue)) *))
(queue? (#(procedure #:pure #:predicate (struct queue)) queue? (*) boolean))

(rassoc (#(procedure #:clean #:enforce) rassoc (* (list-of pair) #!optional (procedure (* *) *)) *))
(reverse-string-append (#(procedure #:clean #:enforce) reverse-string-append ((list-of string)) string))

(sort
 (forall (e (s (or (vector-of e) (list-of e))))
	 (#(procedure #:enforce) 
	  sort
	  (s (procedure (e e) *)) 
	  s)))

(sort!
 (forall (e (s (or (vector-of e) (list-of e))))
	 (#(procedure #:enforce) 
	  sort
	  (s (procedure (e e) *)) 
	  s)))

(sorted? (#(procedure #:enforce) sorted? ((or list vector) (procedure (* *) *)) boolean))
(topological-sort (#(procedure #:enforce) topological-sort ((list-of list) (procedure (* *) *)) list))
(string-chomp (#(procedure #:clean #:enforce) string-chomp (string #!optional string) string))
(string-chop (#(procedure #:clean #:enforce) string-chop (string fixnum) (list-of string)))
(string-compare3 (#(procedure #:clean #:enforce) string-compare3 (string string) fixnum))
(string-compare3-ci (#(procedure #:clean #:enforce) string-compare3-ci (string string) fixnum))
(string-intersperse (#(procedure #:clean #:enforce) string-intersperse ((list-of string) #!optional string) string))
(string-split (#(procedure #:clean #:enforce) string-split (string #!optional string *) (list-of string)))
(string-translate (#(procedure #:clean #:enforce) string-translate (string * #!optional *) string))
(string-translate* (#(procedure #:clean #:enforce) string-translate* (string (list-of (pair string string))) string))
(substring-ci=? (#(procedure #:clean #:enforce) substring-ci=? (string string #!optional fixnum fixnum fixnum) boolean))

(substring-index (#(procedure #:clean #:enforce) substring-index (string string #!optional fixnum) (or false fixnum))
		 ((* *) (##sys#substring-index #(1) #(2) '0))
		 ((* * *) (##sys#substring-index #(1) #(2) #(3))))

(substring-index-ci (#(procedure #:clean #:enforce) substring-index-ci (string string #!optional fixnum) (or false fixnum))
		    ((* *) (##sys#substring-index-ci #(1) #(2) '0))
		    ((* * *) (##sys#substring-index-ci #(1) #(2) #(3))))

(substring=? (#(procedure #:clean #:enforce) substring=? (string string #!optional fixnum fixnum fixnum) boolean))
(tail? (#(procedure #:clean) tail? (* *) boolean))


;; extras

(format (procedure format (#!rest) *))
(fprintf (#(procedure #:enforce) fprintf (output-port string #!rest) undefined))
(pp (#(procedure #:enforce) pp (* #!optional output-port) undefined))
(pretty-print (#(procedure #:enforce) pretty-print (* #!optional output-port) undefined))
(pretty-print-width (#(procedure #:clean) pretty-print-width (#!optional fixnum) *))
(printf (#(procedure #:enforce) printf (string #!rest) undefined))
(random (#(procedure #:clean #:enforce) random (fixnum) fixnum))
(randomize (#(procedure #:clean #:enforce) randomize (#!optional fixnum) undefined))
(read-buffered (#(procedure #:enforce) read-buffered (#!optional input-port) string))
(read-byte (#(procedure #:enforce) read-byte (#!optional input-port) *))
(read-file (#(procedure #:enforce) read-file (#!optional (or input-port string) (procedure (input-port) *) fixnum) list))
(read-line (#(procedure #:enforce) read-line (#!optional input-port (or false fixnum)) (or eof string)))
(read-lines (#(procedure #:enforce) read-lines (#!optional (or input-port string) fixnum) (list-of string)))
(read-string (#(procedure #:enforce) read-string (#!optional (or fixnum false) input-port) string))
(read-string! (#(procedure #:enforce) read-string! ((or fixnum false) string #!optional input-port fixnum) fixnum))
(read-token (#(procedure #:enforce) read-token ((procedure (char) *) #!optional input-port) string))
(sprintf (#(procedure #:enforce) sprintf (string #!rest) string))
(write-byte (#(procedure #:enforce) write-byte (fixnum #!optional output-port) undefined))
(write-line (#(procedure #:enforce) write-line (string #!optional output-port) undefined))
(write-string (#(procedure #:enforce) write-string (string #!optional (or fixnum false) output-port) undefined))


;; files

(delete-file* (#(procedure #:clean #:enforce) delete-file* (string) *))
(file-copy (#(procedure #:clean #:enforce) file-copy (string string #!optional * fixnum) fixnum))
(file-move (#(procedure #:clean #:enforce) file-move (string string #!optional * fixnum) fixnum))
(make-pathname (#(procedure #:clean #:enforce) make-pathname ((or string (list-of string) false) #!optional (or string false) (or string false)) string))
(directory-null? (#(procedure #:clean #:enforce) directory-null? (string) boolean))
(make-absolute-pathname (#(procedure #:clean #:enforce) make-absolute-pathname (* #!optional string string) string))
(create-temporary-directory (#(procedure #:clean #:enforce) create-temporary-directory () string))
(create-temporary-file (#(procedure #:clean #:enforce) create-temporary-file (#!optional string) string))
(decompose-directory (#(procedure #:clean #:enforce) decompose-directory (string) * * *))
(decompose-pathname (#(procedure #:clean #:enforce) decompose-pathname (string) * * *))
(absolute-pathname? (#(procedure #:clean #:enforce) absolute-pathname? (string) boolean))
(pathname-directory (#(procedure #:clean #:enforce) pathname-directory (string) *))
(pathname-extension (#(procedure #:clean #:enforce) pathname-extension (string) *))
(pathname-file (#(procedure #:clean #:enforce) pathname-file (string) *))
(pathname-replace-directory (#(procedure #:clean #:enforce) pathname-replace-directory (string string) string))
(pathname-replace-extension (#(procedure #:clean #:enforce) pathname-replace-extension (string string) string))
(pathname-replace-file (#(procedure #:clean #:enforce) pathname-replace-file (string string) string))
(pathname-strip-directory (#(procedure #:clean #:enforce) pathname-strip-directory (string) string))
(pathname-strip-extension (#(procedure #:clean #:enforce) pathname-strip-extension (string) string))
(normalize-pathname (#(procedure #:clean #:enforce) normalize-pathname (string #!optional symbol) string))


;; irregex

(irregex (#(procedure #:clean) irregex (#!rest) (struct regexp)))

;; Both of these DFA accessors return either #f or a DFA vector.
;; TODO: Should we spec out the entire DFA type layout?  It's plenty complex, so we don't
;; want to be specifying this for all procedures accepting a DFA!
;; A DFA looks like a vector of lists;
;; the car of each list is a number (for init-state), false or an alist;
;; the cdr is a list of alists, which contains a char (or vector) and two alists
;; These alists have types themselves, of course...
(irregex-dfa (#(procedure #:clean #:enforce) irregex-dfa ((struct regexp)) (or false vector))
	     (((struct regexp)) (##sys#slot #(1) '1)))

(irregex-dfa/search (#(procedure #:clean #:enforce) irregex-dfa/search ((struct regexp)) (or false vector))
		    (((struct regexp)) (##sys#slot #(1) '2)))

;; Procedure type returned by irregex-nfa is a matcher type (it is misnamed)
;; which is another complex procedure type.
(irregex-nfa (#(procedure #:clean #:enforce) irregex-nfa ((struct regexp)) (or false procedure))
	     (((struct regexp)) (##sys#slot #(1) '3)))

(irregex-flags (#(procedure #:clean #:enforce) irregex-flags ((struct regexp)) fixnum)
	       (((struct regexp)) (##sys#slot #(1) '4)))

(irregex-num-submatches (#(procedure #:clean #:enforce) irregex-num-submatches ((struct regexp))
				   fixnum)
			(((struct regexp)) (##sys#slot #(1) '5)))

(irregex-lengths (#(procedure #:clean #:enforce) irregex-lengths ((struct regexp))
                  (vector-of (or false pair)))
		 (((struct regexp)) (##sys#slot #(1) '6)))

;; XXX: Submatch names ought to be symbols according to the docs, but this is
;;      not enforced anywhere, so we can't assume it in the return type here.
(irregex-names (#(procedure #:clean #:enforce) irregex-names ((struct regexp))
                (list-of (pair * fixnum)))
	       (((struct regexp)) (##sys#slot #(1) '7)))

;; XXX: specialize these? (how?)
(irregex-extract (#(procedure #:clean #:enforce) irregex-extract (* string #!optional fixnum fixnum)
                  (list-of string)))
(irregex-split (#(procedure #:clean #:enforce) irregex-split (* string #!optional fixnum fixnum)
                (list-of string)))

(irregex-fold (forall (a) (#(procedure #:enforce) irregex-fold (* (procedure (fixnum (struct regexp-match) a) a) a string #!optional (procedure (fixnum *) *) fixnum fixnum) a)))
;; XXX TODO: chunker is a plain vector
(irregex-fold/chunked (forall (a c) (#(procedure #:enforce) irregex-fold/chunked (* (procedure (c fixnum (struct regexp-match) a) a) a vector c #!optional (procedure (c fixnum a) a) fixnum fixnum) a)))
(irregex-reset-matches! (procedure irregex-reset-matches! ((struct regexp-match))
                                   (struct regexp-match)))

;; A silly procedure, but at least we can "inline" it like this
(irregex-match? (#(procedure #:clean #:enforce) irregex-match? (* string #!optional fixnum fixnum)
                 boolean)
                ((* string) (and (irregex-match #(1) #(2)) '#t))
                ((* string fixnum) (and (irregex-match #(1) #(2) #(3)) '#t))
                ((* string fixnum fixnum) (and (irregex-match #(1) #(2) #(3) #(4)) '#t)))
;; These two return #f or a match object
(irregex-match (#(procedure #:clean #:enforce) irregex-match (* string #!optional fixnum fixnum)
                (or false (struct regexp-match))))
;; XXX chunker is a plain vector
;; Not marked clean because we don't know what chunker procedures will do
(irregex-match/chunked (#(procedure #:enforce) irregex-match/chunked (* vector * #!optional fixnum)
                        (or false (struct regexp-match))))

(irregex-match-data? (#(procedure #:pure #:predicate (struct regexp-match)) irregex-match-data? (*) boolean))

(irregex-match-end-index (#(procedure #:clean #:enforce) irregex-match-end-index ((struct regexp-match) #!optional *) fixnum))
(irregex-match-end-chunk (#(procedure #:clean #:enforce) irregex-match-end-chunk ((struct regexp-match) #!optional *) *))
(irregex-match-start-index (#(procedure #:clean #:enforce) irregex-match-start-index ((struct regexp-match) #!optional *) fixnum))
(irregex-match-start-chunk (#(procedure #:clean #:enforce) irregex-match-start-chunk ((struct regexp-match) #!optional *) *))
(irregex-match-substring (#(procedure #:clean #:enforce) irregex-match-substring ((struct regexp-match) #!optional *) *))
(irregex-match-subchunk (#(procedure #:clean #:enforce) irregex-match-subchunk ((struct regexp-match) #!optional *) *))

(irregex-match-names (#(procedure #:clean #:enforce) irregex-match-names ((struct regexp-match)) list)
		     (((struct regexp-match)) (##sys#slot #(1) '2)))

(irregex-match-num-submatches (#(procedure #:enforce) irregex-match-num-submatches ((struct regexp-match)) fixnum)
                              (((struct regexp-match))
                               (fx- (fx/ (##sys#size (##sys#slot #(1) '1)) '4) '2)))

(irregex-new-matches (procedure irregex-new-matches (*) *)) ; really only for internal use..
(irregex-opt (#(procedure #:clean #:enforce) irregex-opt (list) *))
(irregex-quote (#(procedure #:clean #:enforce) irregex-quote (string) string))

(irregex-replace (#(procedure #:enforce) irregex-replace (* string #!rest) string))
(irregex-replace/all (#(procedure #:enforce) irregex-replace/all (* string #!rest) string))
;; Returns a list of strings, but *only* when all user-procedures do
(irregex-apply-match (procedure ((struct regexp-match) list) list)) ; internal use

;; These return #f or a match object
(irregex-search (#(procedure #:clean #:enforce) irregex-search (* string #!optional fixnum fixnum)
                 (or false (struct regexp-match))))
;; XXX chunker is a plain vector
(irregex-search/chunked (#(procedure #:enforce) irregex-search/chunked (* vector * #!optional fixnum *)
                         (or false (struct regexp-match))))
(irregex-search/matches (#(procedure #:enforce) irregex-search/matches (* vector * * fixnum (struct regexp-match))
                         (or false (struct regexp-match))))
(irregex-match-valid-index? 
 (#(procedure #:clean #:enforce) irregex-match-valid-index? ((struct regexp-match) *) boolean))

(irregex? (#(procedure #:pure #:predicate (struct regexp)) irregex? (*) boolean))

(make-irregex-chunker
 (#(procedure #:enforce) make-irregex-chunker 
	    ((procedure (*) *)
	     (procedure (*) *)
	     #!optional
	     (procedure (*) *)
	     (procedure (*) *)
	     (procedure (* fixnum * fixnum) string)
	     (procedure (* fixnum * fixnum) *))
	    *))
(maybe-string->sre (#(procedure #:clean) maybe-string->sre (*) *))
(sre->irregex (#(procedure #:clean) sre->irregex (#!rest) *))
(string->irregex (#(procedure #:clean #:enforce) string->irregex (string #!rest) *))
(string->sre (#(procedure #:clean #:enforce) string->sre (string #!rest) *))


;; lolevel

(address->pointer (#(procedure #:clean #:enforce) address->pointer (fixnum) pointer)
		  ((fixnum) (##sys#address->pointer #(1))))

(align-to-word
 (#(procedure #:clean) 
  align-to-word
  ((or number pointer locative procedure port)) 
  (or pointer number)))

(allocate (#(procedure #:clean #:enforce) allocate (fixnum) (or false pointer)))
(block-ref (#(procedure #:clean #:enforce) block-ref (* fixnum) *))
(block-set! (#(procedure #:enforce) block-set! (* fixnum *) *))
(extend-procedure (#(procedure #:clean #:enforce) extend-procedure (procedure *) procedure))
(extended-procedure? (#(procedure #:clean) extended-procedure (*) boolean))
(free (#(procedure #:clean #:enforce) free (pointer) undefined))
(locative->object (#(procedure #:clean #:enforce) locative->object (locative) *))
(locative-ref (#(procedure #:clean #:enforce) locative-ref (locative) *))
(locative-set! (#(procedure #:enforce) locative-set! (locative *) *))
(locative? (#(procedure #:pure #:predicate locative) locative? (*) boolean))
(make-locative (#(procedure #:clean #:enforce) make-locative (* #!optional fixnum) locative))
(make-pointer-vector (#(procedure #:clean #:enforce) make-pointer-vector (fixnum #!optional (or pointer false)) pointer-vector))
(make-record-instance (#(procedure #:clean) make-record-instance (symbol #!rest) *))
(make-weak-locative (#(procedure #:clean #:enforce) make-weak-locative (* #!optional fixnum) locative))

(move-memory! (#(procedure #:enforce) move-memory! (* * #!optional fixnum fixnum fixnum) *)
	      ((pointer pointer fixnum)
	       (##core#inline "C_copy_ptr_memory" #(2) #(1) #(3) '0 '0))
	      ((pointer pointer fixnum fixnum)
	       (##core#inline "C_copy_ptr_memory" #(2) #(1) #(3) '0 #(4)))
	      ((pointer pointer fixnum fixnum fixnum)
	       (##core#inline "C_copy_ptr_memory" #(2) #(1) #(3) #(5) #(4)))
	      ((locative locative fixnum)
	       (##core#inline "C_copy_ptr_memory" #(2) #(1) #(3) '0 '0))
	      ((locative locative fixnum fixnum)
	       (##core#inline "C_copy_ptr_memory" #(2) #(1) #(3) '0 #(4)))
	      ((locative locative fixnum fixnum fixnum)
	       (##core#inline "C_copy_ptr_memory" #(2) #(1) #(3) #(5) #(4))))

(mutate-procedure!
 (#(procedure #:enforce) mutate-procedure! (procedure (procedure (procedure) . *)) procedure))

(number-of-bytes (#(procedure #:clean) number-of-bytes (*) fixnum)
		 (((or blob string)) (##sys#size #(1)))
		 (((or port procedure symbol pair vector locative float pointer-vector))
		  ;; would be applicable to all structure types, but we can't specify
		  ;; "(struct *)" (yet)
		  (##core#inline "C_bytes" (##sys#size #(1)))))

(number-of-slots (#(procedure #:clean) number-of-slots (*) fixnum)
		 (((or vector symbol pair)) (##sys#size #(1))))

(object->pointer (#(procedure #:clean) object->pointer (*) *))
(object-become! (procedure object-become! (list) *))
(object-copy (#(procedure #:clean) object-copy (*) *))
(object-evict (#(procedure #:clean #:enforce) object-evict (* #!optional (procedure (fixnum) pointer)) *))
(object-evict-to-location (#(procedure #:clean #:enforce) object-evict-to-location (* (or pointer locative procedure port) #!optional fixnum) * pointer))
(object-evicted? (#(procedure #:pure) object-evicted? (*) boolean))
(object-release (#(procedure #:enforce) object-release (* #!optional (procedure (pointer) *)) *))
(object-size (#(procedure #:clean) object-size (*) fixnum))
(object-unevict (procedure object-unevict (* #!optional *) *))
(pointer+ (#(procedure #:clean #:enforce) pointer+ ((or pointer procedure port locative) fixnum) pointer))

(pointer->address (#(procedure #:clean #:enforce) pointer->address ((or pointer procedure port locative)) number)
		  ((pointer) (##sys#pointer->address #(1))))

(pointer->object (#(procedure #:clean #:enforce) pointer->object (pointer) *)
		 ((pointer) (##core#inline "C_pointer_to_object" #(1))))

(pointer-like? (#(procedure #:pure #:predicate (or pointer locative procedure port)) pointer-like? (*) boolean)
	       (((or pointer locative procedure port)) (let ((#(tmp) #(1))) '#t)))

(pointer-f32-ref (#(procedure #:clean #:enforce) pointer-f32-ref (pointer) number))
(pointer-f32-set! (#(procedure #:clean #:enforce) pointer-f32-set! (pointer number) undefined))
(pointer-f64-ref (#(procedure #:clean #:enforce) pointer-f64-ref (pointer) number))
(pointer-f64-set! (#(procedure #:clean #:enforce) pointer-f64-set! (pointer number) undefined))
(pointer-vector (#(procedure #:clean #:enforce) pointer-vector (#!rest pointer-vector) boolean))

(pointer-vector? (#(procedure #:pure #:predicate pointer-vector) pointer-vector? (*) boolean))

(pointer-vector-fill! (#(procedure #:clean #:enforce) pointer-vector-fill! (pointer-vector (or pointer false)) undefined))

(pointer-vector-length (#(procedure #:clean #:enforce) pointer-vector-length (pointer-vector) fixnum)
		       ((pointer-vector) (##sys#slot #(1) '1)))

(pointer-vector-ref (#(procedure #:clean #:enforce) pointer-vector-ref (pointer-vector fixnum) (or pointer false)))
(pointer-vector-set! (#(procedure #:clean #:enforce) pointer-vector-set! (pointer-vector fixnum (or pointer false)) undefined))
(pointer-s16-ref (#(procedure #:clean #:enforce) pointer-s16-ref (pointer) fixnum))
(pointer-s16-set! (#(procedure #:clean #:enforce) pointer-s16-set! (pointer fixnum) undefined))
(pointer-s32-ref (#(procedure #:clean #:enforce) pointer-s32-ref (pointer) number))
(pointer-s32-set! (#(procedure #:clean #:enforce) pointer-s32-set! (pointer number) undefined))
(pointer-s8-ref (#(procedure #:clean #:enforce) pointer-s8-ref (pointer) fixnum))
(pointer-s8-set! (#(procedure #:clean #:enforce) pointer-s8-set! (pointer fixnum) undefined))

(pointer-tag (#(procedure #:clean #:enforce) pointer-tag ((or pointer locative procedure port)) *)
	     (((or locative procedure port)) (let ((#(tmp) #(1))) '#f)))

(pointer-u16-ref (#(procedure #:clean #:enforce) pointer-u16-ref (pointer) fixnum))
(pointer-u16-set! (#(procedure #:clean #:enforce) pointer-u16-set! (pointer fixnum) undefined))
(pointer-u32-ref (#(procedure #:clean #:enforce) pointer-u32-ref (pointer) number))
(pointer-u32-set! (#(procedure #:clean #:enforce) pointer-u32-set! (pointer number) undefined))
(pointer-u8-ref (#(procedure #:clean #:enforce) pointer-u8-ref (pointer) fixnum))
(pointer-u8-set! (#(procedure #:clean #:enforce) pointer-u8-set! (pointer fixnum) undefined))

(pointer=? (#(procedure #:clean #:enforce) pointer=? ((or pointer locative procedure port)
				  (or pointer locative procedure port)) boolean)
	   ((pointer pointer) (##core#inline "C_pointer_eqp" #(1) #(2))))

(pointer? (#(procedure #:clean #:predicate pointer) pointer? (*) boolean))

(procedure-data (#(procedure #:clean #:enforce) procedure-data (procedure) *))
(record->vector (#(procedure #:clean) record->vector (*) vector))

(record-instance? (#(procedure #:clean) record-instance? (* #!optional symbol) boolean)
		  ((* symbol) (##sys#structure? #(1) #(2)))
		  ((*) (let ((#(tmp) #(1)))
			 (if (##sys#immediate? #(tmp))
			     '#f
			     (##sys#generic-structure? #(tmp))))))

(record-instance-length (#(procedure #:clean) record-instance-length (*) fixnum))
(record-instance-slot (#(procedure #:clean #:enforce) record-instance-slot (* fixnum) *))
(record-instance-slot-set! (#(procedure #:clean #:enforce) record-instance-slot-set! (* fixnum *) undefined))
(record-instance-type (#(procedure #:clean) record-instance-type (*) *))
(set-procedure-data! (#(procedure #:clean #:enforce) set-procedure-data! (procedure *) undefined))
(tag-pointer (#(procedure #:clean #:enforce) tag-pointer (pointer *) pointer))
(tagged-pointer? (#(procedure #:clean #:enforce) tagged-pointer? (* #!optional *) boolean))


;; ports

(call-with-input-string (#(procedure #:enforce) call-with-input-string (string (procedure (input-port) . *)) . *))
(call-with-output-string (#(procedure #:enforce) call-with-output-string ((procedure (output-port) . *)) string))
(copy-port (#(procedure #:enforce) copy-port (* * #!optional (procedure (*) *) (procedure (* output-port) *)) undefined)) 
(make-input-port (#(procedure #:clean #:enforce) make-input-port ((procedure () (or char eof)) (procedure () *) (procedure () . *) #!optional * * * *) input-port))
(make-output-port (#(procedure #:clean #:enforce) make-output-port ((procedure (string) . *) (procedure () . *) #!optional (procedure () . *)) output-port))
(port-for-each (#(procedure #:enforce) port-for-each ((procedure (*) *) (procedure () . *)) undefined))

(port-map
 (forall (a b) (#(procedure #:enforce) port-map ((procedure (a) b) (procedure () a)) (list-of b))))

(port-fold (#(procedure #:enforce) port-fold ((procedure (* *) *) * (procedure () *)) *))
(make-broadcast-port (#(procedure #:clean #:enforce) make-broadcast-port (#!rest output-port) output-port))
(make-concatenated-port (#(procedure #:clean #:enforce) make-concatenated-port (port #!rest input-port) input-port))
(with-error-output-to-port (#(procedure #:enforce) with-error-output-to-port (output-port (procedure () . *)) . *))
(with-input-from-port (#(procedure #:enforce) with-input-from-port (input-port (procedure () . *)) . *))
(with-input-from-string (#(procedure #:enforce) with-input-from-string (string (procedure () . *)) . *))
(with-output-to-port (#(procedure #:enforce) with-output-to-port (output-port (procedure () . *)) . *))
(with-output-to-string (#(procedure #:enforce) with-output-to-string ((procedure () . *)) . *))


;; posix

(_exit (procedure _exit (#!optional fixnum) noreturn))
(call-with-input-pipe (#(procedure #:enforce) call-with-input-pipe (string (procedure (input-port) . *) #!optional symbol) . *))
(call-with-output-pipe (#(procedure #:enforce) call-with-output-pipe (string (procedure (input-port) . *) #!optional symbol) . *))
(change-directory (#(procedure #:clean #:enforce) change-directory (string) string))
(change-directory* (#(procedure #:clean #:enforce) change-directory* (fixnum) fixnum))
(change-file-mode (#(procedure #:clean #:enforce) change-file-mode (string fixnum) undefined))
(change-file-owner (#(procedure #:clean #:enforce) change-file-owner (string fixnum fixnum) undefined))
(close-input-pipe (#(procedure #:clean #:enforce) close-input-pipe (input-port) fixnum))
(close-output-pipe (#(procedure #:clean #:enforce) close-output-pipe (output-port) fixnum))
(create-directory (#(procedure #:clean #:enforce) create-directory (string #!optional *) string))
(create-fifo (#(procedure #:clean #:enforce) create-fifo (string #!optional fixnum) undefined))
(create-pipe (procedure create-pipe () fixnum fixnum))
(create-session (#(procedure #:clean) create-session () fixnum))
(create-symbolic-link (#(procedure #:clean #:enforce) create-symbolic-link (string string) undefined))

;; extra arg for "parameterize" - ugh, what a hack...
(current-directory (#(procedure #:clean #:enforce) current-directory (#!optional string *) string))

(current-effective-group-id (#(procedure #:clean) current-effective-group-id () fixnum))
(current-effective-user-id (#(procedure #:clean) current-effective-user-id () fixnum))
(current-effective-user-name (#(procedure #:clean) current-effective-user-name () string))
(get-environment-variables (#(procedure #:clean) get-environment-variables () (list-of string)))
(current-group-id (#(procedure #:clean) current-group-id () fixnum))
(current-process-id (#(procedure #:clean) current-process-id () fixnum))
(current-user-id (#(procedure #:clean) current-user-id () fixnum))
(current-user-name (#(procedure #:clean) current-user-name () string))
(delete-directory (#(procedure #:clean #:enforce) delete-directory (string #!optional *) string))
(directory (#(procedure #:clean #:enforce) directory (#!optional string *) (list-of string)))
(directory? (#(procedure #:clean #:enforce) directory? ((or string fixnum)) boolean))
(duplicate-fileno (#(procedure #:clean #:enforce) duplicate-fileno (fixnum #!optional fixnum) fixnum))
(errno/2big fixnum)
(errno/acces fixnum)
(errno/again fixnum)
(errno/badf fixnum)
(errno/busy fixnum)
(errno/child fixnum)
(errno/deadlk fixnum)
(errno/dom fixnum)
(errno/exist fixnum)
(errno/fault fixnum)
(errno/fbig fixnum)
(errno/ilseq fixnum)
(errno/intr fixnum)
(errno/inval fixnum)
(errno/io fixnum)
(errno/isdir fixnum)
(errno/mfile fixnum)
(errno/mlink fixnum)
(errno/nametoolong fixnum)
(errno/nfile fixnum)
(errno/nodev fixnum)
(errno/noent fixnum)
(errno/noexec fixnum)
(errno/nolck fixnum)
(errno/nomem fixnum)
(errno/nospc fixnum)
(errno/nosys fixnum)
(errno/notdir fixnum)
(errno/notempty fixnum)
(errno/notty fixnum)
(errno/nxio fixnum)
(errno/perm fixnum)
(errno/pipe fixnum)
(errno/range fixnum)
(errno/rofs fixnum)
(errno/spipe fixnum)
(errno/srch fixnum)
(errno/wouldblock fixnum)
(errno/xdev fixnum)
(fcntl/dupfd fixnum)
(fcntl/getfd fixnum)
(fcntl/getfl fixnum)
(fcntl/setfd fixnum)
(fcntl/setfl fixnum)
(file-access-time (#(procedure #:clean #:enforce) file-access-time ((or string fixnum)) number))
(file-change-time (#(procedure #:clean #:enforce) file-change-time ((or string fixnum)) number))
(file-close (#(procedure #:clean #:enforce) file-close (fixnum) undefined))
(file-control (#(procedure #:clean #:enforce) file-control (fixnum fixnum #!optional fixnum) fixnum))
(file-creation-mode (#(procedure #:clean #:enforce) file-creation-mode (#!optional fixnum) fixnum))
(file-execute-access? (#(procedure #:clean #:enforce) file-execute-access? (string) boolean))
(file-link (#(procedure #:clean #:enforce) file-link (string string) undefined))
(file-lock (#(procedure #:clean #:enforce) file-lock (port #!optional fixnum *) (struct lock)))
(file-lock/blocking (#(procedure #:clean #:enforce) file-lock/blocking (port #!optional fixnum *) (struct lock)))
(file-mkstemp (#(procedure #:clean #:enforce) file-mkstemp (string) fixnum string))
(file-modification-time (#(procedure #:clean #:enforce) file-modification-time ((or string fixnum)) number))
(file-open (#(procedure #:clean #:enforce) file-open (string fixnum #!optional fixnum) fixnum))
(file-owner (#(procedure #:clean #:enforce) file-owner ((or string fixnum)) fixnum))
(file-permissions (#(procedure #:clean #:enforce) file-permissions ((or string fixnum)) fixnum))
(file-position (#(procedure #:clean #:enforce) file-position ((or port fixnum)) fixnum))
(file-read (#(procedure #:clean #:enforce) file-read (fixnum fixnum #!optional *) list))
(file-read-access? (#(procedure #:clean #:enforce) file-read-access? (string) boolean))
(file-select (#(procedure #:clean #:enforce) file-select ((or (list-of fixnum) fixnum false) (or (list-of fixnum) fixnum false) #!optional fixnum) * *))
(file-size (#(procedure #:clean #:enforce) file-size ((or string fixnum)) number))
(file-stat (#(procedure #:clean #:enforce) file-stat ((or string fixnum) #!optional *) (vector-of number)))
(file-test-lock (#(procedure #:clean #:enforce) file-test-lock (port #!optional fixnum *) boolean))
(file-truncate (#(procedure #:clean #:enforce) file-truncate ((or string fixnum) fixnum) undefined))
(file-type (#(procedure #:clean #:enforce) ((or string fixnum) #!optional * *) symbol))
(file-unlock (#(procedure #:clean #:enforce) file-unlock ((struct lock)) undefined))
(file-write (#(procedure #:clean #:enforce) file-write (fixnum * #!optional fixnum) fixnum))
(file-write-access? (#(procedure #:clean #:enforce) file-write-access? (string) boolean))
(fileno/stderr fixnum)
(fileno/stdin fixnum)
(fileno/stdout fixnum)
(find-files (#(procedure #:enforce) find-files (string #!rest) list))
(get-groups (#(procedure #:clean) get-groups () list))
(get-host-name (#(procedure #:clean) get-host-name () string))
(glob (#(procedure #:clean #:enforce) glob (#!rest string) list))
(group-information (#(procedure #:clean #:enforce) group-information (fixnum #!optional *) *))
(initialize-groups (#(procedure #:clean #:enforce) initialize-groups (string fixnum) undefined))
(local-time->seconds (#(procedure #:clean #:enforce) local-time->seconds ((vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)) number))
(local-timezone-abbreviation (#(procedure #:clean) local-timezone-abbreviation () string))
(map-file-to-memory (#(procedure #:clean #:enforce) map-file-to-memory (* fixnum fixnum fixnum fixnum #!optional fixnum) (struct mmap)))
(map/anonymous fixnum)
(map/file fixnum)
(map/fixed fixnum)
(map/private fixnum)
(map/shared fixnum)
(memory-mapped-file-pointer (#(procedure #:clean #:enforce) memory-mapped-file-pointer ((struct mmap)) pointer))
(memory-mapped-file? (#(procedure #:clean #:predicate (struct mmap)) memory-mapped-file? (*) boolean))
(open-input-file* (#(procedure #:clean #:enforce) open-input-file* (fixnum #!optional symbol) input-port))
(open-input-pipe (#(procedure #:clean #:enforce) open-input-pipe (string #!optional symbol) input-port))
(open-output-file* (#(procedure #:clean #:enforce) open-output-file* (fixnum #!optional symbol) output-port))
(open-output-pipe (#(procedure #:clean #:enforce) open-output-pipe (string #!optional symbol) output-port))
(open/append fixnum)
(open/binary fixnum)
(open/creat fixnum)
(open/excl fixnum)
(open/fsync fixnum)
(open/noctty fixnum)
(open/nonblock fixnum)
(open/rdonly fixnum)
(open/rdwr fixnum)
(open/read fixnum)
(open/sync fixnum)
(open/text fixnum)
(open/trunc fixnum)
(open/write fixnum)
(open/wronly fixnum)
(parent-process-id (#(procedure #:clean) parent-process-id () fixnum))
(perm/irgrp fixnum)
(perm/iroth fixnum)
(perm/irusr fixnum)
(perm/irwxg fixnum)
(perm/irwxo fixnum)
(perm/irwxu fixnum)
(perm/isgid fixnum)
(perm/isuid fixnum)
(perm/isvtx fixnum)
(perm/iwgrp fixnum)
(perm/iwoth fixnum)
(perm/iwusr fixnum)
(perm/ixgrp fixnum)
(perm/ixoth fixnum)
(perm/ixusr fixnum)
(pipe/buf fixnum)
(port->fileno (#(procedure #:clean #:enforce) port->fileno (port) fixnum))
(process (#(procedure #:clean #:enforce) process (string #!optional (list-of string) (list-of string)) input-port output-port fixnum))
(process* (#(procedure #:clean #:enforce) process* (string #!optional (list-of string) (list-of string)) input-port output-port fixnum *))

(process-execute
 (#(procedure #:clean #:enforce) process-execute (string #!optional (list-of string) (list-of string)) noreturn))

(process-fork (#(procedure #:enforce) process-fork (#!optional (or (procedure () . *) false) *) fixnum))

(process-group-id (#(procedure #:clean #:enforce) process-group-id () fixnum))
(process-run (#(procedure #:clean #:enforce) process-run (string #!optional (list-of string)) fixnum))
(process-signal (#(procedure #:clean #:enforce) process-signal (fixnum #!optional fixnum) undefined))
(process-wait (#(procedure #:clean #:enforce) process-wait (#!optional fixnum *) fixnum fixnum fixnum))
(prot/exec fixnum)
(prot/none fixnum)
(prot/read fixnum)
(prot/write fixnum)
(read-symbolic-link (#(procedure #:clean #:enforce) read-symbolic-link (string #!optional boolean) string))
(regular-file? (#(procedure #:clean #:enforce) regular-file? ((or string fixnum)) boolean))
(seconds->local-time (#(procedure #:clean #:enforce) seconds->local-time (#!optional number) (vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)))
(seconds->string (#(procedure #:clean #:enforce) seconds->string (#!optional number) string))
(seconds->utc-time (#(procedure #:clean #:enforce) seconds->utc-time (#!optional number) (vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)))
(seek/cur fixnum)
(seek/end fixnum)
(seek/set fixnum)
(set-alarm! (#(procedure #:clean #:enforce) set-alarm! (number) number))
(set-buffering-mode! (#(procedure #:clean #:enforce) set-buffering-mode! (port symbol #!optional fixnum) undefined))
(set-file-position! (#(procedure #:clean #:enforce) set-file-position! ((or port fixnum) fixnum #!optional fixnum) undefined))
(set-groups! (#(procedure #:clean #:enforce) set-groups! ((list-of fixnum)) undefined))
(set-root-directory! (#(procedure #:clean #:enforce) set-root-directory! (string) undefined))
(set-signal-handler! (#(procedure #:clean #:enforce) set-signal-handler! (fixnum (or false (procedure (fixnum) . *))) undefined))
(set-signal-mask! (#(procedure #:clean #:enforce) set-signal-mask! ((list-of fixnum)) undefined))
(setenv (#(procedure #:clean #:enforce) setenv (string string) undefined))
(signal-handler (#(procedure #:clean #:enforce) signal-handler (fixnum) (or false (procedure (fixnum) . *))))
(signal-mask (#(procedure #:clean) signal-mask () fixnum))
(signal-mask! (#(procedure #:clean #:enforce) signal-mask! (fixnum) undefined))
(signal-masked? (#(procedure #:clean #:enforce) signal-masked? (fixnum) boolean))
(signal-unmask! (#(procedure #:clean #:enforce) signal-unmask! (fixnum) undefined))
(signal/abrt fixnum)
(signal/alrm fixnum)
(signal/chld fixnum)
(signal/cont fixnum)
(signal/fpe fixnum)
(signal/hup fixnum)
(signal/ill fixnum)
(signal/int fixnum)
(signal/io fixnum)
(signal/bus fixnum)
(signal/kill fixnum)
(signal/pipe fixnum)
(signal/prof fixnum)
(signal/quit fixnum)
(signal/segv fixnum)
(signal/stop fixnum)
(signal/term fixnum)
(signal/trap fixnum)
(signal/tstp fixnum)
(signal/urg fixnum)
(signal/usr1 fixnum)
(signal/usr2 fixnum)
(signal/vtalrm fixnum)
(signal/winch fixnum)
(signal/xcpu fixnum)
(signal/xfsz fixnum)
(signals-list list)
(sleep (#(procedure #:clean #:enforce) sleep (fixnum) fixnum))
(block-device? (#(procedure #:clean #:enforce) block-device? ((or string fixnum)) boolean))
(character-device? (#(procedure #:clean #:enforce) character-device? ((or string fixnum)) boolean))
(fifo? (#(procedure #:clean #:enforce) fifo? ((or string fixnum)) boolean))
(socket? (#(procedure #:clean #:enforce) socket? ((or string fixnum)) boolean))
(string->time (#(procedure #:clean #:enforce) string->time (string #!optional string) (vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)))
(symbolic-link? (#(procedure #:clean #:enforce) symbolic-link? ((or string fixnum)) boolean))
(system-information (#(procedure #:clean) system-information () list))
(terminal-name (#(procedure #:clean #:enforce) terminal-name (port) string))
(terminal-port? (#(procedure #:clean #:enforce) terminal-port? (port) boolean))
(terminal-size (#(procedure #:clean #:enforce) terminal-size (port) fixnum fixnum))
(time->string (#(procedure #:clean #:enforce) time->string ((vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum) #!optional string) string))
(unmap-file-from-memory (#(procedure #:clean #:enforce) unmap-file-from-memory ((struct mmap) #!optional fixnum) undefined))
(unsetenv (#(procedure #:clean #:enforce) unsetenv (string) undefined))
(user-information (#(procedure #:clean #:enforce) user-information ((or string fixnum) #!optional *) *))
(utc-time->seconds (#(procedure #:clean #:enforce) utc-time->seconds ((vector fixnum fixnum fixnum fixnum fixnum fixnum fixnum fixnum boolean fixnum)) number))
(with-input-from-pipe (#(procedure #:enforce) with-input-from-pipe (string (procedure () . *) #!optional symbol) . *))
(with-output-to-pipe (#(procedure #:enforce) with-output-to-pipe (string (procedure () . *) #!optional symbol) . *))


;; srfi-1

(alist-cons (forall (a b c) (#(procedure #:clean) alist-cons (a b (list-of c)) (pair a (pair b (list-of c))))))
(alist-copy (forall (a) (#(procedure #:clean #:enforce) alist-copy ((list-of a)) (list-of a))))
(alist-delete (forall (a b) (#(procedure #:enforce) alist-delete (a (list-of b) #!optional (procedure (a b) *)) list)))
(alist-delete! (forall (a b) (#(procedure #:enforce) alist-delete! (a (list-of b) #!optional (procedure (a b) *)) undefined)))
(any (forall (a) (#(procedure #:enforce) any ((procedure (a #!rest) *) (list-of a) #!rest list) *)))
(append! (#(procedure #:enforce) append! (#!rest list) list))

(append-map
 (forall (a b) (#(procedure #:enforce) append-map ((procedure (a #!rest) (list-of b)) (list-of a) #!rest list)
			   (list-of b))))

(append-map!
 (forall (a b) (#(procedure #:enforce) append-map! ((procedure (a #!rest) (list-of b)) (list-of a) #!rest list)
			   (list-of b))))

(append-reverse (#(procedure #:clean #:enforce) append-reverse (list list) list))
(append-reverse! (#(procedure #:enforce) append-reverse! (list list) list))
(break (forall (a) (#(procedure #:enforce) break ((procedure (a) *) (list-of a)) (list-of a) (list-of a))))
(break! (forall (a) (#(procedure #:enforce) break! ((procedure (a) *) (list-of a)) (list-of a) (list-of a))))
(car+cdr (forall (a b) (#(procedure #:clean #:enforce) car+cdr ((pair a b)) a b)))
(circular-list (#(procedure #:clean) circular-list (#!rest) list))

(circular-list? (#(procedure #:clean) circular-list? (*) boolean)
		((null) (let ((#(tmp) #(1))) '#f)))

(concatenate (#(procedure #:clean #:enforce) concatenate ((list-of list)) list))
(concatenate! (#(procedure #:enforce) concatenate! ((list-of list)) list))
(cons* (forall (a) (#(procedure #:clean) cons* (a #!rest) (pair a *))))
(count (forall (a) (#(procedure #:enforce) count ((procedure (a #!rest) *) (list-of a) #!rest list) fixnum)))
(delete (forall (a b) (#(procedure #:enforce) delete (a (list-of b) #!optional (procedure (a *) *)) (list-of b))))
(delete! (forall (a b) (#(procedure #:enforce) delete! (a (list-of b) #!optional (procedure (a *) *)) (list-of b))))

(delete-duplicates
 (forall (a) (#(procedure #:enforce) delete-duplicates ((list-of a) #!optional (procedure (a *) *)) (list-of a))))

(delete-duplicates!
 (forall (a) (#(procedure #:enforce) delete-duplicates! ((list-of a) #!optional (procedure (a *) *)) (list-of a))))

(dotted-list? (#(procedure #:clean) dotted-list? (*) boolean))
(drop (forall (a) (#(procedure #:enforce) drop ((list-of a) fixnum) (list-of a))))
(drop-right (forall (a) (#(procedure #:enforce) drop-right ((list-of a) fixnum) (list-of a))))
(drop-right! (forall (a) (#(procedure #:enforce) drop-right! ((list-of a) fixnum) (list-of a))))
(drop-while (forall (a) (#(procedure #:enforce) drop-while ((procedure (a) *) (list-of a)) (list-of a))))
(eighth (#(procedure #:clean #:enforce) eighth (pair) *))

(every
 (forall (a) (#(procedure #:enforce) every ((procedure (a #!rest) *) (list-of a) #!rest list) *)))

(fifth (#(procedure #:clean #:enforce) fifth (pair) *))
(filter (forall (a) (#(procedure #:enforce) filter ((procedure (a) *) (list-of a)) (list-of a))))
(filter! (forall (a) (#(procedure #:enforce) filter! ((procedure (a) *) (list-of a)) (list-of a))))

(filter-map
 (forall (a b) (#(procedure #:enforce) filter-map ((procedure (a #!rest) b) (list-of a) #!rest list) (list-of b))))

(find (forall (a) (#(procedure #:enforce) find ((procedure (a) *) (list-of a)) *)))
(find-tail (forall (a) (#(procedure #:enforce) find-tail ((procedure (a) *) (list-of a)) *)))

(first (forall (a) (#(procedure #:clean #:enforce) first ((pair a *)) a))
       ((pair) (##core#inline "C_u_i_car" #(1))))

(fold (#(procedure #:enforce) fold ((procedure (* #!rest) *) * #!rest list) *)) ;XXX
(fold-right (#(procedure #:enforce) fold-right ((procedure (* #!rest) *) * #!rest list) *)) ;XXX

(fourth (forall (a) (#(procedure #:clean #:enforce) fourth ((pair * (pair * (pair * (pair a *))))) a))
	(((pair * (pair * (pair * (pair * *)))))
	 (##core#inline "C_u_i_car" 
			(##core#inline "C_u_i_cdr"
				       (##core#inline "C_u_i_cdr"
						      (##core#inline "C_u_i_cdr" #(1)))))))

(iota (#(procedure #:clean #:enforce) iota (fixnum #!optional fixnum fixnum) (list-of number)))
(last (#(procedure #:clean #:enforce) last (pair) *))
(last-pair (#(procedure #:clean #:enforce) last-pair (pair) *))
(length+ (#(procedure #:clean #:enforce) length+ (list) *))
(list-copy (forall (a) (#(procedure #:pure) list-copy (a) a)))
(list-index (forall (a) (#(procedure #:enforce) list-index ((procedure (a #!rest) *) (list-of a) #!rest list) *)))
(list-tabulate (forall (a) (#(procedure #:enforce) list-tabulate (fixnum (procedure (fixnum) a)) (list-of a))))
(list= (#(procedure #:clean #:enforce) list= (#!optional (procedure (list list) *) #!rest list) boolean)
       (() '#t)
       ((procedure) (let ((#(tmp) #(1))) '#t)))

(lset-adjoin 
 (forall (a) (#(procedure #:enforce) lset-adjoin ((procedure (a a) *) (list-of a) #!rest a) (list-of a)))
 ((procedure list) (let ((#(tmp) #(1))) #(2))))

(lset-diff+intersection
 (forall (a)
	 (#(procedure #:enforce) lset-diff+intersection ((procedure (a a) *) (list-of a) #!rest (list-of a))
		     (list-of a) (list-of a)))
 ((procedure list) (let ((#(tmp) #(1))) (##sys#values #(2) '()))))

(lset-diff+intersection! 
 (forall (a)
	 (#(procedure #:enforce) lset-diff+intersection! ((procedure (a a) *) (list-of a) #!rest (list-of a))
		     (list-of a) (list-of a)))
 ((procedure list) (let ((#(tmp) #(1))) (##sys#values #(2) '()))))

(lset-difference
 (forall (a) (#(procedure #:enforce) lset-difference ((procedure (a a) *) (list-of a) #!rest (list-of a)) (list-of a)))
 ((procedure list) (let ((#(tmp) #(1))) #(2))))

(lset-difference!
 (forall (a) (#(procedure #:enforce) lset-difference! ((procedure (a a) *) (list-of a) #!rest (list-of a)) (list-of a)))
 ((procedure list) (let ((#(tmp) #(1))) #(2))))

(lset-intersection
 (forall (a) (#(procedure #:enforce) lset-intersection ((procedure (a a) *) (list-of a) #!rest (list-of a)) (list-of a)))
 ((procedure list) (let ((#(tmp) #(1))) #(2))))

(lset-intersection!
 (forall (a) (#(procedure #:enforce) lset-intersection! ((procedure (a a) *) (list-of a) #!rest (list-of a)) (list-of a)))
 ((procedure list) (let ((#(tmp) #(1))) #(2))))

(lset-union
 (forall (a) (#(procedure #:enforce) lset-union ((procedure (a a) *) #!rest (list-of a)) (list-of a)))
 ((procedure) (let ((#(tmp) #(1))) '()))
 ((procedure list) (let ((#(tmp) #(1))) #(2))))

(lset-union!
 (forall (a) (#(procedure #:enforce) lset-union! ((procedure (a a) *) #!rest (list-of a)) (list-of a)))
 ((procedure) (let ((#(tmp) #(1))) '()))
 ((procedure list) (let ((#(tmp) #(1))) #(2))))

(lset-xor
 (forall (a) (#(procedure #:enforce) lset-xor ((procedure (a a) *) #!rest (list-of a)) (list-of a)))
 ((procedure) (let ((#(tmp) #(1))) '()))
 ((procedure list) (let ((#(tmp) #(1))) #(2))))

(lset-xor!
 (forall (a) (#(procedure #:enforce) lset-xor! ((procedure (a a) *) #!rest (list-of a)) (list-of a)))
 ((procedure) (let ((#(tmp) #(1))) '()))
 ((procedure list) (let ((#(tmp) #(1))) #(2))))

(lset<=
 (forall (a) (#(procedure #:enforce) lset<= ((procedure (a a) *) #!rest (list-of a)) boolean))
 ((procedure) (let ((#(tmp) #(1))) '#t))
 ((procedure list) (let ((#(tmp1) #(1)) (#(tmp2) #(2))) '#t)))

(lset=
 (forall (a) (#(procedure #:enforce) lset= ((procedure (a a) *) #!rest (list-of a)) boolean))
 ((procedure) (let ((#(tmp) #(1))) '#t))
 ((procedure list) (let ((#(tmp1) #(1)) (#(tmp2) #(2))) '#t)))

;; special-cased (see scrutinizer.scm)
(make-list (forall (a) (#(procedure #:clean #:enforce) make-list (fixnum #!optional a) (list-of a))))

(map!
 (forall (a b) (#(procedure #:enforce) map! ((procedure (a #!rest) b) (list-of a) #!rest list) (list-of b))))

(map-in-order
 (forall 
  (a b)
  (#(procedure #:enforce) map-in-order ((procedure (a #!rest) b) (list-of a) #!rest list) (list-of b))))

(ninth (#(procedure #:clean #:enforce) ninth (pair) *))

(not-pair? (#(procedure #:clean) not-pair? (*) boolean)
	   ((pair) (let ((#(tmp) #(1))) '#f))
	   (((not (or pair list))) (let ((#(tmp) #(1))) '#t)))

(null-list? (#(procedure #:clean #:enforce) null-list? (list) boolean)
	    ((pair) (let ((#(tmp) #(1))) '#f))
	    ((list) (let ((#(tmp) #(1))) '#f))
	    ((null) (let ((#(tmp) #(1))) '#t)))

(pair-fold (#(procedure #:enforce) pair-fold (procedure * list #!rest list) *)) ;XXX do this
(pair-fold-right (#(procedure #:enforce) pair-fold-right (procedure * list #!rest list) *)) ;XXX
(pair-for-each (#(procedure #:enforce) pair-for-each ((procedure (#!rest) . *) list #!rest list) undefined)) ;XXX
(partition (forall (a) (#(procedure #:enforce) partition ((procedure (a) *) (list-of a)) (list-of a) (list-of a))))
(partition! (forall (a) (#(procedure #:enforce) partition! ((procedure (a) *) (list-of a)) (list-of a) (list-of a))))

(proper-list? (#(procedure #:clean) proper-list? (*) boolean)
	      ((null) (let ((#(tmp) #(1))) '#t)))

(reduce (#(procedure #:enforce) reduce ((procedure (* *) *) * list) *)) ;XXX
(reduce-right (#(procedure #:enforce) reduce-right ((procedure (* *) *) * list) *)) ;XXX
(remove (forall (a) (#(procedure #:enforce) remove ((procedure (a) *) (list-of a)) (list-of a))))
(remove! (forall (a) (#(procedure #:enforce) remove! ((procedure (a) *) (list-of a)) (list-of a))))
(reverse! (forall (a) (#(procedure #:enforce) reverse! ((list-of a)) (list-of a))))

(second (forall (a) (#(procedure #:clean #:enforce) second ((pair * (pair a *))) a))
	(((pair * (pair * *))) (##core#inline "C_u_i_car" (##core#inline "C_u_i_cdr" #(1)))))

(seventh (#(procedure #:clean #:enforce) seventh (pair) *))
(sixth (#(procedure #:clean #:enforce) sixth (pair) *))
(span (forall (a) (#(procedure #:enforce) span ((procedure (a) *) (list-of a)) (list-of a) (list-of a))))
(span! (forall (a) (#(procedure #:enforce) span! ((procedure (a) *) (list-of a)) (list-of a) (list-of a))))
(split-at (forall (a) (#(procedure #:enforce) split-at ((list-of a) fixnum) (list-of a) (list-of a))))
(split-at! (forall (a) (#(procedure #:enforce) split-at! ((list-of a) fixnum) (list-of a) (list-of a))))
(take (forall (a) (#(procedure #:enforce) take ((list-of a) fixnum) (list-of a))))
(take! (forall (a) (#(procedure #:enforce) take! ((list-of a) fixnum) (list-of a))))
(take-right (forall (a) (#(procedure #:enforce) take-right ((list-of a) fixnum) (list-of a))))
(take-while (forall (a) (#(procedure #:enforce) take-while ((procedure (a) *) (list-of a)) (list-of a))))
(take-while! (forall (a) (#(procedure #:enforce) take-while! ((procedure (a) *) (list-of a)) (list-of a))))
(tenth (#(procedure #:clean #:enforce) tenth (pair) *))

(third (forall (a) (#(procedure #:clean #:enforce) third ((pair * (pair * (pair a *)))) a))
       (((pair * (pair * (pair * *))))
	(##core#inline "C_u_i_car" 
		       (##core#inline "C_u_i_cdr" (##core#inline "C_u_i_cdr" #(1))))))

(unfold (#(procedure #:enforce) unfold ((procedure (*) *) (procedure (*) *) (procedure (*) *) * #!optional (procedure (*) *)) *)) ;XXX
(unfold-right (#(procedure #:enforce) unfold-right ((procedure (*) *) (procedure (*) *) (procedure (*) *) * #!optional (procedure (*) *)) *)) ;XXX
(unzip1 (forall (a) (#(procedure #:clean #:enforce) unzip1 ((list-of (pair a *))) (list-of a))))
(unzip2 (forall (a b) (#(procedure #:clean #:enforce) unzip2 ((list-of (pair a (pair b *)))) (list-of a) (list-of b))))

(unzip3
 (forall (a b c) (#(procedure #:clean #:enforce) unzip3 ((list-of (pair a (pair b (pair c *))))) (list-of a) (list-of b) (list-of c))))

(unzip4 (#(procedure #:clean #:enforce) unzip4 (list) list list list list)) ; yeah
(unzip5 (#(procedure #:clean #:enforce) unzip5 (list) list list list list list)) ; yeah, too
(xcons (forall (a b) (#(procedure #:pure) xcons (a b) (pair b a))))
(zip (forall (a) (#(procedure #:clean #:enforce) zip ((list-of a) #!rest list) (list-of (pair a *)))))


;; srfi-13

(check-substring-spec (#(procedure #:clean #:enforce) check-substring-spec (* string fixnum fixnum) undefined))
(kmp-step (#(procedure #:enforce) kmp-step (string vector char fixnum (procedure (char char) *) fixnum) fixnum))
(make-kmp-restart-vector (#(procedure #:clean #:enforce) make-kmp-restart-vector (string #!optional (procedure (* *) *) fixnum fixnum) vector))

(string-any
 (forall (a)
  (#(procedure #:enforce)
   string-any
   ((or char (struct char-set) (procedure (char) a)) string #!optional fixnum fixnum)
   (or boolean a))))

(string-append/shared (#(procedure #:clean #:enforce) string-append/shared (#!rest string) string)
		      ((string string) (##sys#string-append #(1) #(2))))

(string-ci< (#(procedure #:clean #:enforce) string-ci< (string string #!optional fixnum fixnum) boolean)
	    ((string string) (string-ci<? #(1) #(2))))

(string-ci<= (#(procedure #:clean #:enforce) string-ci<= (string string #!optional fixnum fixnum) boolean)
	     ((string string) (string-ci<=? #(1) #(2))))

(string-ci<> (#(procedure #:clean #:enforce) string-ci<> (string string #!optional fixnum fixnum) boolean)
	     ((string string) (not (##core#inline "C_i_string_ci_equal_p" #(1) #(2)))))

(string-ci= (#(procedure #:clean #:enforce) string-ci= (string string #!optional fixnum fixnum) boolean)
	    ((string string) (##core#inline "C_i_string_ci_equal_p" #(1) #(2))))

(string-ci> (#(procedure #:clean #:enforce) string-ci> (string string #!optional fixnum fixnum) boolean)
	    ((string string) (string-ci>? #(1) #(2))))

(string-ci>= (#(procedure #:clean #:enforce) string-ci>= (string string #!optional fixnum fixnum) boolean)
	     ((string string) (string-ci>=? #(1) #(2))))

(string-compare (#(procedure #:enforce) string-compare (string string (procedure (fixnum) *) (procedure (fixnum) *) (procedure (fixnum) *) #!optional fixnum fixnum fixnum fixnum) *))
(string-compare-ci (#(procedure #:enforce) string-compare (string string (procedure (fixnum) *) (procedure (fixnum) *) (procedure (fixnum) *) #!optional fixnum fixnum fixnum fixnum) *))
(string-concatenate (#(procedure #:clean #:enforce) string-concatenate ((list-of string)) string))
(string-concatenate-reverse (#(procedure #:clean #:enforce) string-concatenate-reverse ((list-of string) #!optional string fixnum) string))
(string-concatenate-reverse/shared (#(procedure #:clean #:enforce) string-concatenate-reverse/shared ((list-of string) #!optional string fixnum) string))
(string-concatenate/shared (#(procedure #:clean #:enforce) string-concatenate/shared ((list-of string)) string))
(string-contains (#(procedure #:clean #:enforce) string-contains (string string #!optional fixnum fixnum fixnum fixnum) (or fixnum false)))
(string-contains-ci (#(procedure #:clean #:enforce) string-contains-ci (string string #!optional fixnum fixnum fixnum fixnum) (or fixnum false)))
(string-copy (#(procedure #:clean #:enforce) string-copy (string #!optional fixnum fixnum) string))
(string-copy! (#(procedure #:clean #:enforce) string-copy! (string fixnum string #!optional fixnum fixnum) undefined))
(string-count (#(procedure #:clean #:enforce) string-count (string * #!optional fixnum fixnum) fixnum))
(string-delete (#(procedure #:clean #:enforce) string-delete (* string #!optional fixnum fixnum) string))
(string-downcase (#(procedure #:clean #:enforce) string-downcase (string #!optional fixnum fixnum) string))
(string-downcase! (#(procedure #:clean #:enforce) string-downcase! (string #!optional fixnum fixnum) string))
(string-drop (#(procedure #:clean #:enforce) string-drop (string fixnum) string))
(string-drop-right (#(procedure #:clean #:enforce) string-drop-right (string fixnum) string))

(string-every
 (forall (a)
  (#(procedure #:enforce)
   string-every
   ((or char (struct char-set) (procedure (char) a)) string #!optional fixnum fixnum)
   (or boolean a))))

(string-fill! (#(procedure #:clean #:enforce) string-fill! (string char #!optional fixnum fixnum) string))

(string-filter
 (#(procedure #:enforce) 
  string-filter
  ((or char (struct char-set) (procedure (char) *)) string #!optional fixnum fixnum) 
  string))

(string-fold (#(procedure #:enforce) string-fold ((procedure (char *) *) * string #!optional fixnum fixnum) *)) ;XXX

(string-fold-right (#(procedure #:enforce) string-fold-right ((procedure (char *) *) * string #!optional fixnum fixnum) *)) ;XXX
(string-for-each (#(procedure #:enforce) string-for-each ((procedure (char) . *) string #!optional fixnum fixnum) undefined))
(string-for-each-index (#(procedure #:enforce) string-for-each-index ((procedure (fixnum) . *) string #!optional fixnum fixnum) undefined))

(string-index
 (#(procedure #:enforce) 
  string-index
  (string (or char (struct char-set) (procedure (char) *)) #!optional fixnum fixnum)
  (or fixnum false)))

(string-index-right
 (#(procedure #:enforce) 
  string-index-right
  (string (or char (struct char-set) (procedure (char) *)) #!optional fixnum fixnum)
  (or fixnum false)))

(string-join (#(procedure #:clean #:enforce) string-join (list #!optional string symbol) string))
(string-kmp-partial-search (#(procedure #:enforce) string-kmp-partial-search (string vector string fixnum #!optional (procedure (char char) *) fixnum fixnum fixnum) fixnum))
(string-map (#(procedure #:enforce) string-map ((procedure (char) char) string #!optional fixnum fixnum) string))
(string-map! (#(procedure #:enforce) string-map! ((procedure (char) char) string #!optional fixnum fixnum) string))

(string-null? (#(procedure #:clean #:enforce) string-null? (string) boolean)
	      ((string) (##core#inline "C_zero_length_p" #(1))))

(string-pad (#(procedure #:clean #:enforce) string-pad (string fixnum #!optional char fixnum fixnum) string))
(string-pad-right (#(procedure #:clean #:enforce) string-pad-right (string fixnum #!optional char fixnum fixnum) string))
(string-parse-final-start+end (#(procedure #:enforce) string-parse-final-start+end (procedure string #!rest) . *))
(string-parse-start+end (#(procedure #:enforce) string-parse-start+end (procedure string #!rest) . *))
(string-prefix-ci? (#(procedure #:clean #:enforce) string-prefix-ci? (string string #!optional fixnum fixnum fixnum fixnum) boolean))
(string-prefix-length (#(procedure #:clean #:enforce) string-prefix-length (string string #!optional fixnum fixnum fixnum fixnum) fixnum))
(string-prefix-length-ci (#(procedure #:clean #:enforce) string-prefix-length-ci (string string #!optional fixnum fixnum fixnum fixnum) fixnum))
(string-prefix? (#(procedure #:clean #:enforce) string-prefix? (string string #!optional fixnum fixnum fixnum fixnum) boolean))
(string-replace (#(procedure #:clean #:enforce) string-replace (string string fixnum fixnum #!optional fixnum fixnum) string))
(string-reverse (#(procedure #:clean #:enforce) string-reverse (string #!optional fixnum fixnum) string))
(string-reverse! (#(procedure #:clean #:enforce) string-reverse! (string #!optional fixnum fixnum) string))

(string-skip
 (#(procedure #:enforce) 
  string-skip
  (string (or char (struct char-set) (procedure (char) *)) #!optional fixnum fixnum)
  (or fixnum false)))

(string-skip-right
 (#(procedure #:enforce) 
  string-skip-right
  (string (or char (struct char-set) (procedure (char) *)) #!optional fixnum fixnum)
  (or fixnum false)))

(string-suffix-ci? (#(procedure #:clean #:enforce) string-suffix-ci? (string string #!optional fixnum fixnum fixnum fixnum) boolean))
(string-suffix-length (#(procedure #:clean #:enforce) string-suffix-length (string string #!optional fixnum fixnum fixnum fixnum) fixnum))
(string-suffix-length-ci (#(procedure #:clean #:enforce) string-suffix-length-ci (string string #!optional fixnum fixnum fixnum fixnum) fixnum))
(string-suffix? (#(procedure #:clean #:enforce) string-suffix? (string string #!optional fixnum fixnum fixnum fixnum) boolean))
(string-tabulate (#(procedure #:enforce) string-tabulate ((procedure (fixnum) char) fixnum) string))
(string-take (#(procedure #:clean #:enforce) string-take (string fixnum) string))
(string-take-right (#(procedure #:clean #:enforce) string-take-right (string fixnum) string))
(string-titlecase (#(procedure #:clean #:enforce) string-titlecase (string #!optional fixnum fixnum) string))
(string-titlecase! (#(procedure #:clean #:enforce) string-titlecase! (string #!optional fixnum fixnum) string))

(string-tokenize
 (#(procedure #:clean #:enforce) string-tokenize (string #!optional (struct char-set) fixnum fixnum) list))

(string-trim
 (#(procedure #:enforce)
  string-trim
  (string #!optional (or char (struct char-set) (procedure (char) *)) fixnum fixnum) 
  string))

(string-trim-both
 (#(procedure #:enforce) 
  string-trim-both
  (string #!optional (or char (struct char-set) (procedure (char) *)) fixnum fixnum) 
  string))

(string-trim-right
 (#(procedure #:enforce) 
  string-trim-right
  (string #!optional (or char (struct char-set) (procedure (char) *)) fixnum fixnum) 
  string))

(string-unfold (#(procedure #:enforce) string-unfold (procedure procedure procedure * #!optional * procedure) string)) ;XXX
(string-unfold-right (#(procedure #:enforce) string-unfold-right (procedure procedure procedure * #!optional * procedure) string)) ;XXX
(string-upcase (#(procedure #:clean #:enforce) string-upcase (string #!optional fixnum fixnum) string))
(string-upcase! (#(procedure #:clean #:enforce) string-upcase! (string #!optional fixnum fixnum) string))
(string-xcopy! (#(procedure #:clean #:enforce) string-xcopy! (string string string fixnum #!optional fixnum fixnum fixnum) string))

(string< (#(procedure #:clean #:enforce) string< (string string #!optional fixnum fixnum fixnum fixnum) boolean)
	 ((string string) (string<? #(1) #(2))))

(string<= (#(procedure #:clean #:enforce) string<= (string string #!optional fixnum fixnum fixnum fixnum) boolean)
	  ((string string) (string<=? #(1) #(2))))

(string<> (#(procedure #:clean #:enforce) string<> (string string #!optional fixnum fixnum fixnum fixnum) boolean)
	  ((string string) (not (##core#inline "C_i_string_equal_p" #(1) #(2)))))

(string= (#(procedure #:clean #:enforce) string= (string string #!optional fixnum fixnum fixnum fixnum) boolean)
	 ((string string) (##core#inline "C_i_string_equal_p" #(1) #(2))))

(string> (#(procedure #:clean #:enforce) string> (string string #!optional fixnum fixnum fixnum fixnum) boolean)
	 ((string string) (string>? #(1) #(2))))

(string>= (#(procedure #:clean #:enforce) string>= (string string #!optional fixnum fixnum fixnum fixnum) boolean)
	  ((string string) (string>=? #(1) #(2))))

(substring-spec-ok? (#(procedure #:clean #:enforce) substring-spec-ok? (string fixnum fixnum) boolean))
(substring/shared (#(procedure #:clean #:enforce) substring/shared (string fixnum #!optional fixnum) string))
(xsubstring (#(procedure #:clean #:enforce) xsubstring (string fixnum #!optional fixnum fixnum fixnum) string))


;; srfi-14

(->char-set (procedure ->char-set (*) (struct char-set))
	    (((struct char-set)) #(1))
	    ((string) (string->char-set #(1)))
	    ((char) (char-set #(1))))

(char-set (#(procedure #:enforce) char-set (#!rest char) (struct char-set)))
(char-set->list (#(procedure #:clean #:enforce) char-set->list ((struct char-set)) list))
(char-set->string (#(procedure #:clean #:enforce) char-set->string ((struct char-set)) string))
(char-set-adjoin (#(procedure #:clean #:enforce) char-set-adjoin ((struct char-set) #!rest char) (struct char-set)))
(char-set-adjoin! (#(procedure #:clean #:enforce) char-set-adjoin! ((struct char-set) #!rest char) (struct char-set)))
(char-set-any (#(procedure #:enforce) char-set-any ((procedure (char) *) (struct char-set)) *))
(char-set-complement (#(procedure #:clean #:enforce) char-set-complement ((struct char-set)) (struct char-set)))
(char-set-complement! (#(procedure #:clean #:enforce) char-set-complement! ((struct char-set)) (struct char-set)))
(char-set-contains? (#(procedure #:clean #:enforce) char-set-contains? ((struct char-set) char) boolean))
(char-set-copy (#(procedure #:clean #:enforce) char-set-copy ((struct char-set)) (struct char-set)))
(char-set-count (#(procedure #:clean #:enforce) char-set-count ((procedure (char) *) (struct char-set)) fixnum))
(char-set-cursor (#(procedure #:clean #:enforce) char-set-cursor ((struct char-set)) fixnum))
(char-set-cursor-next (#(procedure #:clean #:enforce) char-set-cursor-next ((struct char-set) fixnum) fixnum))
(char-set-delete (#(procedure #:clean #:enforce) char-set-delete ((struct char-set) #!rest char) (struct char-set)))
(char-set-delete! (#(procedure #:clean #:enforce) char-set-delete! ((struct char-set) #!rest char) (struct char-set)))
(char-set-diff+intersection (#(procedure #:clean #:enforce) char-set-diff+intersection ((struct char-set) #!rest (struct char-set)) (struct char-set) (struct char-set)))
(char-set-diff+intersection! (#(procedure #:clean #:enforce) char-set-diff+intersection! ((struct char-set) #!rest (struct char-set)) (struct char-set) (struct char-set)))
(char-set-difference (#(procedure #:clean #:enforce) char-set-difference ((struct char-set) #!rest (struct char-set)) (struct char-set)))
(char-set-difference! (#(procedure #:clean #:enforce) char-set-difference! ((struct char-set) #!rest (struct char-set)) (struct char-set)))
(char-set-every (#(procedure #:enforce) char-set-every ((procedure (char) *) (struct char-set)) boolean))
(char-set-filter (#(procedure #:enforce) char-set-filter ((procedure (char) *) (struct char-set) #!optional (struct char-set)) (struct char-set)))
(char-set-filter! (#(procedure #:enforce) char-set-filter! ((procedure (char) *) (struct char-set) #!optional (struct char-set)) (struct char-set)))
(char-set-fold (#(procedure #:enforce) char-set-fold ((procedure (char *) *) * (struct char-set)) *))
(char-set-for-each (#(procedure #:enforce) char-set-for-each ((procedure (char) . *) (struct char-set)) undefined))
(char-set-hash (#(procedure #:clean #:enforce) char-set-hash ((struct char-set) #!optional number) number))
(char-set-intersection (#(procedure #:clean #:enforce) char-set-intersection (#!rest (struct char-set)) (struct char-set)))
(char-set-intersection! (#(procedure #:clean #:enforce) char-set-intersection! (#!rest (struct char-set)) (struct char-set)))
(char-set-map (#(procedure #:enforce) char-set-map ((procedure (char) char) (struct char-set)) (struct char-set)))
(char-set-ref (#(procedure #:clean #:enforce) char-set-ref ((struct char-set) fixnum) char))
(char-set-size (#(procedure #:clean #:enforce) char-set-size ((struct char-set)) fixnum))
(char-set-unfold (#(procedure #:enforce) char-set-unfold (procedure procedure procedure * #!optional (struct char-set)) (struct char-set)))
(char-set-unfold! (#(procedure #:enforce) char-set-unfold! (procedure procedure procedure * (struct char-set)) (struct char-set)))
(char-set-union (#(procedure #:clean #:enforce) char-set-union (#!rest (struct char-set)) (struct char-set)))
(char-set-union! (#(procedure #:clean #:enforce) char-set-union! (#!rest (struct char-set)) (struct char-set)))
(char-set-xor (#(procedure #:clean #:enforce) char-set-xor (#!rest (struct char-set)) (struct char-set)))
(char-set-xor! (#(procedure #:clean #:enforce) char-set-xor! (#!rest (struct char-set)) (struct char-set)))
(char-set:ascii (struct char-set))
(char-set:blank (struct char-set))
(char-set:digit (struct char-set))
(char-set:empty (struct char-set))
(char-set:full (struct char-set))
(char-set:graphic (struct char-set))
(char-set:hex-digit (struct char-set))
(char-set:iso-control (struct char-set))
(char-set:letter (struct char-set))
(char-set:letter+digit (struct char-set))
(char-set:lower-case (struct char-set))
(char-set:printing (struct char-set))
(char-set:punctuation (struct char-set))
(char-set:symbol (struct char-set))
(char-set:title-case (struct char-set))
(char-set:upper-case (struct char-set))
(char-set:whitespace (struct char-set))
(char-set<= (#(procedure #:clean #:enforce) char-set<= (#!rest (struct char-set)) boolean)
	    (() '#t)
	    (((struct char-set)) (let ((#(tmp) #(1))) '#t)))
(char-set= (#(procedure #:clean #:enforce) char-set= (#!rest (struct char-set)) boolean)
	   (() '#t)
	   (((struct char-set)) (let ((#(tmp) #(1))) '#t)))

(char-set? (#(procedure #:pure #:predicate (struct char-set)) char-set? (*) boolean))

(end-of-char-set? (#(procedure #:clean #:enforce) end-of-char-set? (fixnum) boolean))
(list->char-set (#(procedure #:clean #:enforce) list->char-set ((list-of char) #!optional (struct char-set)) (struct char-set)))
(list->char-set! (#(procedure #:clean #:enforce) list->char-set! ((list-of char) #!optional (struct char-set)) (struct char-set)))
(string->char-set (#(procedure #:clean #:enforce) string->char-set (string #!optional (struct char-set)) (struct char-set)))
(string->char-set! (#(procedure #:clean #:enforce) string->char-set! (string #!optional (struct char-set)) (struct char-set)))
(ucs-range->char-set (#(procedure #:clean #:enforce) ucs-range->char-set (fixnum fixnum #!optional * (struct char-set)) (struct char-set)))
(ucs-range->char-set! (#(procedure #:clean #:enforce) ucs-range->char-set! (fixnum fixnum #!optional * (struct char-set)) (struct char-set)))


;; srfi-18

(abandoned-mutex-exception? (#(procedure #:pure) abandoned-mutex-exception? (*) boolean))
(condition-variable-broadcast! (#(procedure #:clean #:enforce) condition-variable-broadcast! ((struct condition-variable)) undefined))
(condition-variable-name (#(procedure #:clean #:enforce) condition-variable-name ((struct condition-variable)) *))
(condition-variable-signal! (#(procedure #:clean #:enforce) condition-variable-signal! ((struct condition-variable)) undefined))
(condition-variable-specific (#(procedure #:clean #:enforce) condition-variable-specific ((struct condition-variable)) *))
(condition-variable-specific-set! (#(procedure #:clean #:enforce) condition-variable-specific-set! ((struct condition-variable) *) undefined))

(condition-variable? (#(procedure #:pure #:predicate (struct condition-variable))
		      condition-variable? (*) 
		      boolean))

(current-thread (#(procedure #:clean) current-thread () (struct thread))) ;XXX

(current-time (#(procedure #:clean) current-time () (struct time)))
(join-timeout-exception? (#(procedure #:pure) join-timeout-exception? (*) boolean))
(make-condition-variable (#(procedure #:clean) make-condition-variable (#!optional *) (struct condition-variable)))
(make-mutex (#(procedure #:clean) make-mutex (#!optional *) (struct mutex)))
(make-thread (#(procedure #:clean #:enforce) make-thread ((procedure () . *) #!optional *) (struct thread)))
(mutex-lock! (#(procedure #:clean #:enforce) mutex-lock! ((struct mutex) #!optional (or false number (struct time)) (or false (struct thread))) boolean))

(mutex-name (#(procedure #:clean #:enforce) mutex-name ((struct mutex)) *)
	    (((struct mutex)) (##sys#slot #(1) '1)))

(mutex-specific (#(procedure #:clean #:enforce) mutex-specific ((struct mutex)) *)
		(((struct mutex)) (##sys#slot #(1) '6)))

(mutex-specific-set! (#(procedure #:clean #:enforce) mutex-specific-set! ((struct mutex) *) undefined)
		     (((struct mutex) *) (##sys#setslot #(1) '6 #(2))))

(mutex-state (#(procedure #:clean #:enforce) mutex-state ((struct mutex)) (or symbol (struct thread))))
(mutex-unlock! (#(procedure #:clean #:enforce) mutex-unlock! ((struct mutex) #!optional (struct condition-variable) *) undefined))

(mutex? (#(procedure #:pure #:predicate (struct mutex)) mutex? (*) boolean))

(raise (procedure raise (*) noreturn))
(seconds->time (#(procedure #:clean #:enforce) seconds->time (number) (struct time)))
(terminated-thread-exception? (#(procedure #:pure) terminated-thread-exception? (*) boolean))
(thread-join! (#(procedure #:clean #:enforce) thread-join! ((struct thread) #!optional * *) . *))

(thread-name (#(procedure #:clean #:enforce) thread-name ((struct thread)) *)
	     (((struct thread)) (##sys#slot #(1) '6)))

(thread-quantum (#(procedure #:clean #:enforce) thread-quantum ((struct thread)) fixnum)
		(((struct thread)) (##sys#slot #(1) '9)))

(thread-quantum-set! (#(procedure #:clean #:enforce) thread-quantum-set! ((struct thread) fixnum) undefined))
(thread-resume! (#(procedure #:clean #:enforce) thread-resume! ((struct thread)) undefined))
(thread-signal! (#(procedure #:clean #:enforce) thread-signal! ((struct thread) *) undefined))
(thread-sleep! (#(procedure #:clean) thread-sleep! (*) undefined))

(thread-specific (#(procedure #:clean #:enforce) thread-specific ((struct thread)) *)
		 (((struct thread)) (##sys#slot #(1) '10)))

(thread-specific-set! (#(procedure #:clean #:enforce) thread-specific-set! ((struct thread) *) undefined)
		      (((struct thread) *) (##sys#setslot #(1) '10 #(2))))

(thread-start! (#(procedure #:enforce) thread-start! ((or (struct thread) (procedure () . *))) (struct thread)))

(thread-state (#(procedure #:clean #:enforce) thread-state ((struct thread)) symbol)
	      (((struct thread)) (##sys#slot #(1) '3)))

(thread-suspend! (#(procedure #:clean #:enforce) thread-suspend! ((struct thread)) undefined))
(thread-terminate! (#(procedure #:clean #:enforce) thread-terminate! ((struct thread)) undefined))
(thread-wait-for-i/o! (#(procedure #:clean #:enforce) thread-wait-for-i/o! (fixnum #!optional symbol) undefined))
(thread-yield! (#(procedure #:clean) thread-yield! () undefined))

(thread? (#(procedure #:pure #:predicate (struct thread)) thread? (*) boolean))

(time->seconds (#(procedure #:clean #:enforce) time->seconds ((struct time)) number))

(time? (#(procedure #:pure #:predicate (struct time)) time? (*) boolean))

(uncaught-exception-reason (#(procedure #:clean #:enforce) uncaught-exception-reason ((struct condition)) *))
(uncaught-exception? (#(procedure #:pure) uncaught-exception? (*) boolean))


;; srfi-4

(blob->f32vector (#(procedure #:clean #:enforce) blob->f32vector (blob) (struct f32vector)))
(blob->f32vector/shared (#(procedure #:clean #:enforce) blob->f32vector/shared (blob) (struct f32vector)))
(blob->f64vector (#(procedure #:clean #:enforce) blob->f64vector (blob) (struct f64vector)))
(blob->f64vector/shared (#(procedure #:clean #:enforce) blob->f64vector/shared (blob) (struct f64vector)))
(blob->s16vector (#(procedure #:clean #:enforce) blob->s16vector (blob) (struct s16vector)))
(blob->s16vector/shared (#(procedure #:clean #:enforce) blob->s16vector/shared (blob) (struct s16vector)))
(blob->s32vector (#(procedure #:clean #:enforce) blob->s32vector (blob) (struct s32vector)))
(blob->s32vector/shared (#(procedure #:clean #:enforce) blob->s32vector/shared (blob) (struct s32vector)))
(blob->s8vector (#(procedure #:clean #:enforce) blob->s8vector (blob) (struct s8vector)))
(blob->s8vector/shared (#(procedure #:clean #:enforce) blob->s8vector/shared (blob) (struct s8vector)))
(blob->u16vector (#(procedure #:clean #:enforce) blob->u16vector (blob) (struct u16vector)))
(blob->u16vector/shared (#(procedure #:clean #:enforce) blob->u16vector/shared (blob) (struct u16vector)))
(blob->u32vector (#(procedure #:clean #:enforce) blob->u32vector (blob) (struct u32vector)))
(blob->u32vector/shared (#(procedure #:clean #:enforce) blob->u32vector/shared (blob) (struct u32vector)))
(blob->u8vector (#(procedure #:clean #:enforce) blob->u8vector (blob) (struct u8vector)))
(blob->u8vector/shared (#(procedure #:clean #:enforce) blob->u8vector/shared (blob) (struct u8vector)))
(f32vector (#(procedure #:clean #:enforce) f32vector (#!rest number) (struct f32vector)))
(f32vector->blob (#(procedure #:clean #:enforce) f32vector->blob ((struct f32vector)) blob))
(f32vector->blob/shared (#(procedure #:clean #:enforce) f32vector->blob/shared ((struct f32vector)) blob))
(f32vector->list (#(procedure #:clean #:enforce) f32vector->list ((struct f32vector)) (list-of float)))

(f32vector-length (#(procedure #:clean #:enforce) f32vector-length ((struct f32vector)) fixnum)
		  (((struct f32vector)) (##core#inline "C_u_i_32vector_length" #(1))))

(f32vector-ref (#(procedure #:clean #:enforce) f32vector-ref ((struct f32vector) fixnum) float))
(f32vector-set! (#(procedure #:clean #:enforce) f32vector-set! ((struct f32vector) fixnum number) undefined))

(f32vector? (#(procedure #:pure #:predicate (struct f32vector)) f32vector? (*) boolean))

(f64vector (#(procedure #:clean #:enforce) f64vector (#!rest number) (struct f64vector)))
(f64vector->blob (#(procedure #:clean #:enforce) f64vector->blob ((struct f64vector)) blob))
(f64vector->blob/shared (#(procedure #:clean #:enforce) f64vector->blob/shared ((struct f64vector)) blob))
(f64vector->list (#(procedure #:clean #:enforce) f64vector->list ((struct f64vector)) (list-of float)))

(f64vector-length (#(procedure #:clean #:enforce) f64vector-length ((struct f64vector)) fixnum)
		  (((struct f64vector)) (##core#inline "C_u_i_64vector_length" #(1))))

(f64vector-ref (#(procedure #:clean #:enforce) f64vector-ref ((struct f64vector) fixnum) float))
(f64vector-set! (#(procedure #:clean #:enforce) f64vector-set! ((struct f64vector) fixnum number) undefined))

(f64vector? (#(procedure #:pure #:predicate (struct f64vector)) f64vector? (*) boolean))

(list->f32vector (#(procedure #:clean #:enforce) list->f32vector ((list-of number)) (struct f32vector)))
(list->f64vector (#(procedure #:clean #:enforce) list->f64vector ((list-of number)) (struct f64vector)))
(list->s16vector (#(procedure #:clean #:enforce) list->s16vector ((list-of fixnum)) (struct s16vector)))
(list->s32vector (#(procedure #:clean #:enforce) list->s32vector ((list-of number)) (struct s32vector)))
(list->s8vector (#(procedure #:clean #:enforce) list->s8vector ((list-of fixnum)) (struct s8vector)))
(list->u16vector (#(procedure #:clean #:enforce) list->u16vector ((list-of fixnum)) (struct u16vector)))
(list->u32vector (#(procedure #:clean #:enforce) list->u32vector ((list-of number)) (struct u32vector)))
(list->u8vector (#(procedure #:clean #:enforce) list->u8vector ((list-of fixnum)) (struct u8vector)))
(make-f32vector (#(procedure #:clean #:enforce) make-f32vector (fixnum #!optional * * *) (struct f32vector)))
(make-f64vector (#(procedure #:clean #:enforce) make-f64vector (fixnum #!optional * * *) (struct f64vector)))
(make-s16vector (#(procedure #:clean #:enforce) make-s16vector (fixnum #!optional * * *) (struct s16vector)))
(make-s32vector (#(procedure #:clean #:enforce) make-s32vector (fixnum #!optional * * *) (struct s32vector)))
(make-s8vector (#(procedure #:clean #:enforce) make-s8vector (fixnum #!optional * * *) (struct s8vector)))
(make-u16vector (#(procedure #:clean #:enforce) make-u16vector (fixnum #!optional * * *) (struct u16vector)))
(make-u32vector (#(procedure #:clean #:enforce) make-u32vector (fixnum #!optional * * *) (struct u32vector)))
(make-u8vector (#(procedure #:clean #:enforce) make-u8vector (fixnum #!optional * * *) (struct u8vector)))
(read-u8vector (#(procedure #:enforce) read-u8vector (#!optional (or fixnum false) input-port) (struct u8vector)))
(read-u8vector! (#(procedure #:enforce) read-u8vector! ((or fixnum false) (struct u8vector) #!optional input-port fixnum) number))
(release-number-vector (procedure release-number-vector (*) undefined))
(s16vector (#(procedure #:clean #:enforce) s16vector (#!rest fixnum) (struct s16vector)))
(s16vector->blob (#(procedure #:clean #:enforce) s16vector->blob ((struct s16vector)) blob))
(s16vector->blob/shared (#(procedure #:clean #:enforce) s16vector->blob/shared ((struct s16vector)) blob))
(s16vector->list (#(procedure #:clean #:enforce) s16vector->list ((struct s16vector)) (list-of fixnum)))

(s16vector-length (#(procedure #:clean #:enforce) s16vector-length ((struct s16vector)) fixnum)
		  (((struct s16vector)) (##core#inline "C_u_i_16vector_length" #(1))))

(s16vector-ref (#(procedure #:clean #:enforce) s16vector-ref ((struct s16vector) fixnum) fixnum))
(s16vector-set! (#(procedure #:clean #:enforce) s16vector-set! ((struct s16vector) fixnum fixnum) undefined))

(s16vector? (#(procedure #:pure #:predicate (struct s16vector)) s16vector? (*) boolean))

(s32vector (#(procedure #:clean #:enforce) s32vector (#!rest number) (struct s32vector)))
(s32vector->blob (#(procedure #:clean #:enforce) s32vector->blob ((struct s32vector)) blob))
(s32vector->blob/shared (#(procedure #:clean #:enforce) s32vector->blob/shared ((struct s32vector)) blob))
(s32vector->list (#(procedure #:clean #:enforce) s32vector->list ((struct s32vector)) (list-of number)))

(s32vector-length (#(procedure #:clean #:enforce) s32vector-length ((struct s32vector)) fixnum)
		  (((struct s32vector)) (##core#inline "C_u_i_32vector_length" #(1))))

(s32vector-ref (#(procedure #:clean #:enforce) s32vector-ref ((struct s32vector) fixnum) number))
(s32vector-set! (#(procedure #:clean #:enforce) s32vector-set! ((struct s32vector) fixnum number) undefined))

(s32vector? (#(procedure #:pure #:predicate (struct s32vector)) s32vector? (*) boolean))

(s8vector (#(procedure #:clean #:enforce) s8vector (#!rest fixnum) (struct s8vector)))
(s8vector->blob (#(procedure #:clean #:enforce) s8vector->blob ((struct s8vector)) blob))
(s8vector->blob/shared (#(procedure #:clean #:enforce) s8vector->blob/shared ((struct s8vector)) blob))
(s8vector->list (#(procedure #:clean #:enforce) s8vector->list ((struct s8vector)) (list-of fixnum)))

(s8vector-length (#(procedure #:clean #:enforce) s8vector-length ((struct s8vector)) fixnum)
		 (((struct s8vector)) (##core#inline "C_u_i_8vector_length" #(1))))

(s8vector-ref (#(procedure #:clean #:enforce) s8vector-ref ((struct s8vector) fixnum) fixnum))
(s8vector-set! (#(procedure #:clean #:enforce) s8vector-set! ((struct s8vector) fixnum fixnum) undefined))

(s8vector? (#(procedure #:pure #:predicate (struct s8vector)) s8vector? (*) boolean))

(subf32vector (#(procedure #:clean #:enforce) subf32vector ((struct f32vector) fixnum fixnum) (struct f32vector)))
(subf64vector (#(procedure #:clean #:enforce) subf64vector ((struct f64vector) fixnum fixnum) (struct f64vector)))
(subs16vector (#(procedure #:clean #:enforce) subs16vector ((struct s16vector) fixnum fixnum) (struct s16vector)))
(subs32vector (#(procedure #:clean #:enforce) subs32vector ((struct s32vector) fixnum fixnum) (struct s32vector)))
(subs8vector (#(procedure #:clean #:enforce) subs8vector  ((struct s8vector) fixnum fixnum) (struct s8vector)))
(subu16vector (#(procedure #:clean #:enforce) subu16vector ((struct u16vector) fixnum fixnum) (struct u16vector)))
(subu32vector (#(procedure #:clean #:enforce) subu32vector ((struct u32vector) fixnum fixnum) (struct u32vector)))
(subu8vector (#(procedure #:clean #:enforce) subu8vector ((struct u8vector) fixnum fixnum) (struct u8vector)))
(u16vector (#(procedure #:clean #:enforce) u16vector (#!rest fixnum) (struct u16vector)))
(u16vector->blob (#(procedure #:clean #:enforce) u16vector->blob ((struct u16vector)) blob))
(u16vector->blob/shared (#(procedure #:clean #:enforce) u16vector->blob/shared ((struct u16vector)) blob))
(u16vector->list (#(procedure #:clean #:enforce) u16vector->list ((struct u16vector)) (list-of fixnum)))

(u16vector-length (#(procedure #:clean #:enforce) u16vector-length ((struct u16vector)) fixnum)
		  (((struct u16vector)) (##core#inline "C_u_i_16vector_length" #(1))))

(u16vector-ref (#(procedure #:clean #:enforce) u16vector-ref ((struct u16vector) fixnum) fixnum))
(u16vector-set! (#(procedure #:clean #:enforce) u16vector-set! ((struct u16vector) fixnum fixnum) undefined))

(u16vector? (#(procedure #:pure #:predicate (struct u16vector)) u16vector? (*) boolean))

(u32vector (#(procedure #:clean #:enforce) u32vector (#!rest number) (struct u32vector)))
(u32vector->blob (#(procedure #:clean #:enforce) u32vector->blob ((struct u32vector)) blob))
(u32vector->blob/shared (#(procedure #:clean #:enforce) u32vector->blob/shared ((struct u32vector)) blob))
(u32vector->list (#(procedure #:clean #:enforce) u32vector->list ((struct u32vector)) (list-of number)))

(u32vector-length (#(procedure #:clean #:enforce) u32vector-length ((struct u32vector)) fixnum)
		  (((struct u32vector)) (##core#inline "C_u_i_32vector_length" #(1))))

(u32vector-ref (#(procedure #:clean #:enforce) u32vector-ref ((struct u32vector) fixnum) number))
(u32vector-set! (#(procedure #:clean #:enforce) u32vector-set! ((struct u32vector) fixnum number) undefined))

(u32vector? (#(procedure #:pure #:predicate (struct u32vector)) u32vector? (*) boolean))

(u8vector (#(procedure #:clean #:enforce) u8vector (#!rest fixnum) (struct u8vector)))
(u8vector->blob (#(procedure #:clean #:enforce) u8vector->blob ((struct u8vector)) blob))
(u8vector->blob/shared (#(procedure #:clean #:enforce) u8vector->blob/shared ((struct u8vector)) blob))
(u8vector->list (#(procedure #:clean #:enforce) u8vector->list ((struct u8vector)) (list-of fixnum)))

(u8vector-length (#(procedure #:clean #:enforce) u8vector-length ((struct u8vector)) fixnum)
		 (((struct u8vector)) (##core#inline "C_u_i_8vector_length" #(1))))

(u8vector-ref (#(procedure #:clean #:enforce) u8vector-ref ((struct u8vector) fixnum) fixnum))
(u8vector-set! (#(procedure #:clean #:enforce) u8vector-set! ((struct u8vector) fixnum fixnum) undefined))

(u8vector? (#(procedure #:pure #:predicate (struct u8vector)) u8vector? (*) boolean))

(write-u8vector (#(procedure #:enforce) write-u8vector ((struct u8vector) #!optional output-port fixnum fixnum) undefined))

(number-vector? (#(procedure #:pure #:predicate (or (struct u8vector) (struct u16vector) (struct s8vector) (struct s16vector) (struct u32vector) (struct s32vector) (struct f32vector) (struct f64vector))) number-vector? (*) boolean))
(##sys#srfi-4-vector? (#(procedure #:pure #:predicate (or (struct u8vector) (struct u16vector) (struct s8vector) (struct s16vector) (struct u32vector) (struct s32vector) (struct f32vector) (struct f64vector))) ##sys#srfi-4-vector? (*) boolean))


;; srfi-69

(alist->hash-table (#(procedure #:clean #:enforce) alist->hash-table ((list-of pair) #!rest) (struct hash-table)))
(eq?-hash (#(procedure #:clean #:enforce) eq?-hash (* #!optional fixnum fixnum) fixnum))
(equal?-hash (#(procedure #:clean #:enforce) equal?-hash (* #!optional fixnum fixnum) fixnum))
(eqv?-hash (#(procedure #:clean #:enforce) eqv?-hash (* #!optional fixnum fixnum) fixnum))
(hash (#(procedure #:pure #:enforce) hash (* #!optional fixnum fixnum) fixnum))
(hash-by-identity (#(procedure #:pure #:enforce) hash-by-identity (* #!optional fixnum fixnum) fixnum))
(hash-table->alist (#(procedure #:clean #:enforce) hash-table->alist ((struct hash-table)) (list-of pair)))
(hash-table-clear! (#(procedure #:clean #:enforce) hash-table-clear! ((struct hash-table)) undefined))
(hash-table-copy (#(procedure #:clean #:enforce) hash-table-copy ((struct hash-table)) (struct hash-table)))
(hash-table-delete! (#(procedure #:clean #:enforce) hash-table-delete! ((struct hash-table) *) boolean))
(hash-table-equivalence-function (#(procedure #:clean #:enforce) hash-table-equivalence-function ((struct hash-table)) (procedure (* *) *)))
(hash-table-exists? (#(procedure #:clean #:enforce) hash-table-exists? ((struct hash-table) *) boolean))
(hash-table-fold (#(procedure #:enforce) hash-table-fold ((struct hash-table) (procedure (* * *) *) *) *))
(hash-table-for-each (#(procedure #:enforce) hash-table-for-each ((struct hash-table) (procedure (* *) . *)) undefined))

(hash-table-has-initial? (#(procedure #:clean #:enforce) hash-table-has-initial? ((struct hash-table)) boolean)
			 (((struct hash-table)) (##sys#slot #(1) '9))) ;XXX might return other than #t

(hash-table-hash-function (#(procedure #:clean #:enforce) hash-table-hash-function ((struct hash-table)) (procedure (* fixnum) fixnum))
			  (((struct hash-table)) (##sys#slot #(1) '4)))

(hash-table-initial (#(procedure #:clean #:enforce) hash-table-initial ((struct hash-table)) *))
(hash-table-keys (#(procedure #:clean #:enforce) hash-table-keys ((struct hash-table)) list))
(hash-table-map (#(procedure #:clean #:enforce) hash-table-map ((struct hash-table) (procedure (* *) *)) list))

(hash-table-max-load (#(procedure #:clean #:enforce) hash-table-max-load ((struct hash-table)) fixnum)
		     (((struct hash-table)) (##sys#slot #(1) '6)))

(hash-table-merge (#(procedure #:clean #:enforce) hash-table-merge ((struct hash-table) (struct hash-table)) (struct hash-table)))
(hash-table-merge! (#(procedure #:clean #:enforce) hash-table-merge! ((struct hash-table) (struct hash-table)) undefined))

(hash-table-min-load (#(procedure #:clean #:enforce) hash-table-min-load ((struct hash-table)) fixnum)
		     (((struct hash-table)) (##sys#slot #(1) '5)))

(hash-table-ref (#(procedure #:clean #:enforce) hash-table-ref ((struct hash-table) * #!optional (procedure () *)) *))
(hash-table-ref/default (#(procedure #:clean #:enforce) hash-table-ref/default ((struct hash-table) * *) *))
(hash-table-remove! (#(procedure #:clean #:enforce) hash-table-remove! ((struct hash-table) (procedure (* *) *)) undefined))
(hash-table-set! (#(procedure #:clean #:enforce) hash-table-set! ((struct hash-table) * *) undefined))

(hash-table-size (#(procedure #:clean #:enforce) hash-table-size ((struct hash-table)) fixnum)
		 (((struct hash-table)) (##sys#slot #(1) '2)))

(hash-table-update! (#(procedure #:enforce) hash-table-update! ((struct hash-table) * (procedure (*) *) #!optional (procedure () *)) *))
(hash-table-update!/default (#(procedure #:clean #:enforce) hash-table-update!/default ((struct hash-table) * (procedure (*) *) *) *))
(hash-table-values (#(procedure #:clean #:enforce) hash-table-values ((struct hash-table)) list))
(hash-table-walk (#(procedure #:enforce) hash-table-walk ((struct hash-table) (procedure (* *) . *)) undefined))

(hash-table-weak-keys (#(procedure #:clean #:enforce) hash-table-weak-keys ((struct hash-table)) boolean)
		      (((struct hash-table)) (##sys#slot #(1) '7)))

(hash-table-weak-values (#(procedure #:clean #:enforce) hash-table-weak-values ((struct hash-table)) boolean)
			(((struct hash-table)) (##sys#slot #(1) '8)))

(hash-table? (#(procedure #:pure #:predicate (struct hash-table)) hash-table? (*) boolean))

;;XXX if we want to hardcode hash-default-bound here, we could rewrite the 1-arg case...
;     (applies to all hash-functions)
(keyword-hash (#(procedure #:clean #:enforce) keyword-hash (* #!optional fixnum fixnum) fixnum))

(make-hash-table (#(procedure #:clean #:enforce) make-hash-table (#!rest) (struct hash-table)))
(number-hash (#(procedure #:clean #:enforce) number-hash (fixnum #!optional fixnum fixnum) fixnum))
(object-uid-hash (#(procedure #:clean #:enforce) object-uid-hash (* #!optional fixnum fixnum) fixnum))
(symbol-hash (#(procedure #:clean #:enforce) symbol-hash (symbol #!optional fixnum fixnum) fixnum))
(string-hash (#(procedure #:clean #:enforce) string-hash (string #!optional fixnum fixnum fixnum fixnum) number))
(string-hash-ci (#(procedure #:clean #:enforce) string-hash-ci (string #!optional fixnum fixnum fixnum fixnum) number))
(string-ci-hash (#(procedure #:clean #:enforce) string-ci-hash (string #!optional fixnum fixnum fixnum fixnum) number))


;; tcp

(tcp-abandon-port (#(procedure #:clean #:enforce) tcp-abandon-port (port) undefined))
(tcp-accept (#(procedure #:clean #:enforce) tcp-accept ((struct tcp-listener)) input-port output-port))
(tcp-accept-ready? (#(procedure #:clean #:enforce) tcp-accept-ready? ((struct tcp-listener)) boolean))
(tcp-accept-timeout (#(procedure #:clean #:enforce) tcp-accept-timeout (#!optional (or false number)) (or false number)))
(tcp-addresses (#(procedure #:clean #:enforce) tcp-addresses (port) string string))
(tcp-buffer-size (#(procedure #:clean #:enforce) tcp-buffer-size (#!optional fixnum) fixnum))
(tcp-close (#(procedure #:clean #:enforce) tcp-close ((struct tcp-listener)) undefined))
(tcp-connect (#(procedure #:clean #:enforce) tcp-connect (string #!optional fixnum) input-port output-port))
(tcp-connect-timeout (#(procedure #:clean #:enforce) tcp-connect-timeout (#!optional (or false number)) (or false number)))
(tcp-listen (#(procedure #:clean #:enforce) tcp-listen (fixnum #!optional fixnum *) (struct tcp-listener)))

(tcp-listener-fileno (#(procedure #:clean #:enforce) tcp-listener-fileno ((struct tcp-listener)) fixnum)
		     (((struct tcp-listener)) (##sys#slot #(1) '1)))

(tcp-listener-port (#(procedure #:clean #:enforce) tcp-listener-port ((struct tcp-listener)) fixnum))

(tcp-listener? (#(procedure #:clean #:predicate (struct tcp-listener)) tcp-listener? (*) boolean))

(tcp-port-numbers (#(procedure #:clean #:enforce) tcp-port-numbers (port) fixnum fixnum))
(tcp-read-timeout (#(procedure #:clean #:enforce) tcp-read-timeout (#!optional (or false number)) (or false number)))
(tcp-write-timeout (#(procedure #:clean #:enforce) tcp-write-timeout (#!optional (or false number)) (or false number)))


;; utils

(read-all (#(procedure #:enforce) read-all (#!optional (or input-port string)) string))
(system* (#(procedure #:clean #:enforce) system* (string #!rest) undefined))
(qs (#(procedure #:clean #:enforce) qs (string) string))
(compile-file (#(procedure #:clean #:enforce) compile-file (string #!rest) (or false string)))
(compile-file-options (#(procedure #:clean #:enforce) compile-file-options (#!optional (list-of string)) (list-of string)))
(scan-input-lines (#(procedure #:enforce) scan-input-lines (* #!optional input-port) *))
(yes-or-no? (#(procedure #:enforce) yes-or-no? (string #!rest) *))
