[[tags: manual]]

== Unit srfi-14

Character set library.  An abbreviated version of the SRFI is provided
in this document.  Full documentation is available in the
[[http://srfi.schemers.org/srfi-14/srfi-14.html|original SRFI-14
document]].

On systems that support dynamic loading, the {{srfi-14}} unit can
be made available in the interpreter ({{csi}}) by entering

<enscript highlight=scheme>
(require-extension srfi-14)
</enscript>

This library provides only the Latin-1 character set.  To get Unicode
semantics, see the [[/egg/utf8|utf8]] egg.  However, information on Unicode
character sets is still provided in this document.

== Specification

In the following procedure specifications:


* A CS parameter is a character set. 
* An S parameter is a string. 
* A CHAR parameter is a character. 
* A CHAR-LIST parameter is a list of characters. 
* A PRED parameter is a unary character predicate procedure, returning a true/false value when applied to a character. 
* An OBJ parameter may be any value at all. 

Passing values to procedures with these parameters that do not satisfy
these types is an error.

Unless otherwise noted in the specification of a procedure, procedures
always return character sets that are distinct (from the point of view
of the linear-update operations) from the parameter character sets. For
example, {{char-set-adjoin}} is guaranteed to provide a fresh character
set, even if it is not given any character parameters.

Parameters given in square brackets are optional. Unless otherwise noted in
the text describing the procedure, any prefix of these optional parameters
may be supplied, from zero arguments to the full list. When a procedure
returns multiple values, this is shown by listing the return values in
square brackets, as well. So, for example, the procedure with signature


 halts? F [X INIT-STORE] -> [BOOLEAN INTEGER]


would take one (F), two (F, X) or three (F, X, INIT-STORE) input
parameters, and return two values, a boolean and an integer.

A parameter followed by "{{...}}" means zero-or-more elements. So the
procedure with the signature


 sum-squares X ...  -> NUMBER

takes zero or more arguments (X ...), while the procedure with signature


 spell-check DOC DICT_1 DICT_2 ... -> STRING-LIST


takes two required parameters (DOC and DICT_1) and zero or more optional
parameters (DICT_2 ...).


=== General procedures

<procedure>(char-set? obj) -> boolean</procedure><br>

Is the object OBJ a character set?

<procedure>(char-set= cs_1 ...) -> boolean</procedure><br>

Are the character sets equal?

Boundary cases:


 (char-set=) => TRUE
 (char-set= cs) => TRUE

Rationale: transitive binary relations are generally extended to n-ary
relations in Scheme, which enables clearer, more concise code to be
written. While the zero-argument and one-argument cases will almost
certainly not arise in first-order uses of such relations, they may well
arise in higher-order cases or macro-generated code. ''E.g.,'' consider


 (apply char-set= cset-list)


This is well-defined if the list is empty or a singleton list. Hence
we extend these relations to any number of arguments. Implementors have
reported actual uses of n-ary relations in higher-order cases allowing for
fewer than two arguments. The way of Scheme is to handle the general case;
we provide the fully general extension.

A counter-argument to this extension is that R5RS's transitive binary
arithmetic relations ({{=}}, {{<}}, ''etc.'') require at least two
arguments, hence this decision is a break with the prior convention --
although it is at least one that is backwards-compatible.

<procedure>(char-set<= cs_1 ...) -> boolean</procedure><br>

Returns true if every character set CS_I is a subset of character set
CS_I+1.

Boundary cases:


 (char-set<=) => TRUE
 (char-set<= cs) => TRUE

Rationale: See {{char-set=}} for discussion of zero- and one-argument
applications. Consider testing a list of char-sets for monotonicity with


 (apply char-set<= cset-list)

<procedure>(char-set-hash cs [bound]) -> integer</procedure><br>

Compute a hash value for the character set CS. BOUND is a non-negative
exact integer specifying the range of the hash function. A positive value
restricts the return value to the range [0,BOUND).

If BOUND is either zero or not given, the implementation may use an
implementation-specific default value, chosen to be as large as is
efficiently practical. For instance, the default range might be chosen for
a given implementation to map all strings into the range of integers that
can be represented with a single machine word.

Invariant:


 (char-set= cs_1 cs_2) => (= (char-set-hash cs_1 b) (char-set-hash cs_2 b))


A legal but nonetheless discouraged implementation:


 (define (char-set-hash cs . maybe-bound) 1)

Rationale: allowing the user to specify an explicit bound simplifies user
code by removing the mod operation that typically accompanies every hash
computation, and also may allow the implementation of the hash function to
exploit a reduced range to efficiently compute the hash value. ''E.g.'',
for small bounds, the hash function may be computed in a fashion such
that intermediate values never overflow into bignum integers, allowing
the implementor to provide a fixnum-specific "fast path" for computing the
common cases very rapidly.


=== Iterating over character sets

<procedure>(char-set-cursor cset) -> cursor</procedure><br>
<procedure>(char-set-ref cset cursor) -> char</procedure><br>
<procedure>(char-set-cursor-next cset cursor) -> cursor</procedure><br>
<procedure>(end-of-char-set? cursor) -> boolean</procedure><br>

Cursors are a low-level facility for iterating over the characters
in a set. A cursor is a value that indexes a character in a char set.
{{char-set-cursor}} produces a new cursor for a given char set. The
set element indexed by the cursor is fetched with {{char-set-ref}}.
A cursor index is incremented with {{char-set-cursor-next}}; in this
way, code can step through every character in a char set. Stepping
a cursor "past the end" of a char set produces a cursor that answers
true to {{end-of-char-set?}}. It is an error to pass such a cursor to
{{char-set-ref}} or to {{char-set-cursor-next}}.

A cursor value may not be used in conjunction with a different character
set; if it is passed to {{char-set-ref}} or {{char-set-cursor-next}} with a
character set other than the one used to create it, the results and effects
are undefined.

Cursor values are ''not'' necessarily distinct from other types. They
may be integers, linked lists, records, procedures or other values.
This license is granted to allow cursors to be very "lightweight" values
suitable for tight iteration, even in fairly simple implementations.

Note that these primitives are necessary to export an iteration facility
for char sets to loop macros.

Example:


 (define cs (char-set #\G #\a #\T #\e #\c #\h))
  
 ;; Collect elts of CS into a list.
 (let lp ((cur (char-set-cursor cs)) (ans '()))
   (if (end-of-char-set? cur) ans
       (lp (char-set-cursor-next cs cur)
           (cons (char-set-ref cs cur) ans))))
   => (#\G #\T #\a #\c #\e #\h)
  
 ;; Equivalently, using a list unfold (from SRFI 1):
 (unfold-right end-of-char-set? 
               (curry char-set-ref cs)
 	      (curry char-set-cursor-next cs)
 	      (char-set-cursor cs))
   => (#\G #\T #\a #\c #\e #\h)

Rationale: Note that the cursor API's four functions "fit" the functional
protocol used by the unfolders provided by the list, string and char-set
SRFIs (see the example above). By way of contrast, here is a simpler,
two-function API that was rejected for failing this criterion. Besides
{{char-set-cursor}}, it provided a single function that mapped a cursor and
a character set to two values, the indexed character and the next cursor.
If the cursor had exhausted the character set, then this function returned
false instead of the character value, and another end-of-char-set cursor.
In this way, the other three functions of the current API were combined
together.

<procedure>(char-set-fold kons knil cs) -> object</procedure><br>

This is the fundamental iterator for character sets. Applies the function
KONS across the character set CS using initial state value KNIL. That is,
if CS is the empty set, the procedure returns KNIL. Otherwise, some element
C of CS is chosen; let CS' be the remaining, unchosen characters. The
procedure returns


 (char-set-fold KONS (KONS C KNIL) CS')

Examples:


 ;; CHAR-SET-MEMBERS
 (lambda (cs) (char-set-fold cons '() cs))
  
 ;; CHAR-SET-SIZE
 (lambda (cs) (char-set-fold (lambda (c i) (+ i 1)) 0 cs))
  
 ;; How many vowels in the char set?
 (lambda (cs) 
   (char-set-fold (lambda (c i) (if (vowel? c) (+ i 1) i))
                  0 cs))

<procedure>(char-set-unfold f p g seed [base-cs]) -> char-set</procedure><br>
<procedure>(char-set-unfold! f p g seed base-cs) -> char-set</procedure><br>

This is a fundamental constructor for char-sets.


* G is used to generate a series of "seed" values from the initial seed: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ... 
* P tells us when to stop -- when it returns true when applied to one of these seed values. 
* F maps each seed value to a character. These characters are added to the base character set BASE-CS to form the result; BASE-CS defaults to the empty set. {{char-set-unfold!}} adds the characters to BASE-CS in a linear-update -- it is allowed, but not required, to side-effect and use BASE-CS's storage to construct the result. 

More precisely, the following definitions hold, ignoring the
optional-argument issues:


 (define (char-set-unfold p f g seed base-cs) 
   (char-set-unfold! p f g seed (char-set-copy base-cs)))
  
 (define (char-set-unfold! p f g seed base-cs)
   (let lp ((seed seed) (cs base-cs))
         (if (p seed) cs                                 ; P says we are done.
             (lp (g seed)                                ; Loop on (G SEED).
                 (char-set-adjoin! cs (f seed))))))      ; Add (F SEED) to set.

(Note that the actual implementation may be more efficient.)

Examples:



 (port->char-set p) = (char-set-unfold eof-object? values
                                       (lambda (x) (read-char p))
                                       (read-char p))
  
 (list->char-set lis) = (char-set-unfold null? car cdr lis)


<procedure>(char-set-for-each proc cs) -> unspecified</procedure><br>

Apply procedure PROC to each character in the character set CS. Note that
the order in which PROC is applied to the characters in the set is not
specified, and may even change from one procedure application to another.

Nothing at all is specified about the value returned by this procedure;
it is not even required to be consistent from call to call. It is simply
required to be a value (or values) that may be passed to a command
continuation, ''e.g.'' as the value of an expression appearing as a
non-terminal subform of a {{begin}} expression. Note that in R5RS, this
restricts the procedure to returning a single value; non-R5RS systems may
not even provide this restriction.

<procedure>(char-set-map proc cs) -> char-set</procedure><br>

PROC is a char->char procedure. Apply it to all the characters in the
char-set CS, and collect the results into a new character set.

Essentially lifts PROC from a char->char procedure to a char-set ->
char-set procedure.

Example:


 (char-set-map char-downcase cset)


=== Creating character sets

<procedure>(char-set-copy cs) -> char-set</procedure><br>

Returns a copy of the character set CS. "Copy" means that if either the
input parameter or the result value of this procedure is passed to one of
the linear-update procedures described below, the other character set is
guaranteed not to be altered.

A system that provides pure-functional implementations of the
linear-operator suite could implement this procedure as the identity
function -- so copies are ''not'' guaranteed to be distinct by {{eq?}}.

<procedure>(char-set char_1 ...) -> char-set</procedure><br>

Return a character set containing the given characters.

<procedure>(list->char-set char-list [base-cs]) -> char-set</procedure><br>
<procedure>(list->char-set! char-list base-cs) -> char-set</procedure><br>

Return a character set containing the characters in the list of characters
CHAR-LIST.

If character set BASE-CS is provided, the characters from CHAR-LIST
are added to it. {{list->char-set!}} is allowed, but not required, to
side-effect and reuse the storage in BASE-CS; {{list->char-set}} produces a
fresh character set.

<procedure>(string->char-set s [base-cs]) -> char-set</procedure><br>
<procedure>(string->char-set! s base-cs) -> char-set</procedure><br>

Return a character set containing the characters in the string S.

If character set BASE-CS is provided, the characters from S are added to
it. {{string->char-set!}} is allowed, but not required, to side-effect
and reuse the storage in BASE-CS; {{string->char-set}} produces a fresh
character set.

<procedure>(char-set-filter pred cs [base-cs]) -> char-set</procedure><br>
<procedure>(char-set-filter! pred cs base-cs) -> char-set</procedure><br>

Returns a character set containing every character C in CS such that
{{(PRED C)}} returns true.

If character set BASE-CS is provided, the characters specified by PRED
are added to it. {{char-set-filter!}} is allowed, but not required, to
side-effect and reuse the storage in BASE-CS; {{char-set-filter}} produces
a fresh character set.

An implementation may not save away a reference to PRED and invoke it after
{{char-set-filter}} or {{char-set-filter!}} returns -- that is, "lazy,"
on-demand implementations are not allowed, as PRED may have external
dependencies on mutable data or have other side-effects.

Rationale: This procedure provides a means of converting a character
predicate into its equivalent character set; the CS parameter allows the
programmer to bound the predicate's domain. Programmers should be aware
that filtering a character set such as {{char-set:full}} could be a very
expensive operation in an implementation that provided an extremely large
character type, such as 32-bit Unicode. An earlier draft of this library
provided a simple {{predicate->char-set}} procedure, which was rejected in
favor of {{char-set-filter}} for this reason.

<procedure>(ucs-range->char-set lower upper [error? base-cs]) -> char-set</procedure><br>
<procedure>(ucs-range->char-set! lower upper error? base-cs) -> char-set</procedure><br>

LOWER and UPPER are exact non-negative integers; LOWER <= UPPER.

Returns a character set containing every character whose ISO/IEC 10646
UCS-4 code lies in the half-open range [LOWER,UPPER).


* If the requested range includes unassigned UCS values, these are silently ignored (the current UCS specification has "holes" in the space of assigned codes). 
* If the requested range includes "private" or "user space" codes, these are handled in an implementation-specific manner; however, a UCS- or Unicode-based Scheme implementation should pass them through transparently. 
* If any code from the requested range specifies a valid, assigned UCS character that has no corresponding representative in the implementation's character type, then (1) an error is raised if ERROR? is true, and (2) the code is ignored if ERROR? is false (the default). This might happen, for example, if the implementation uses ASCII characters, and the requested range includes non-ASCII characters. 

If character set BASE-CS is provided, the characters specified by the range
are added to it. {{ucs-range->char-set!}} is allowed, but not required,
to side-effect and reuse the storage in BASE-CS; {{ucs-range->char-set}}
produces a fresh character set.

Note that ASCII codes are a subset of the Latin-1 codes, which are in turn
a subset of the 16-bit Unicode codes, which are themselves a subset of
the 32-bit UCS-4 codes. We commit to a specific encoding in this routine,
regardless of the underlying representation of characters, so that client
code using this library will be portable. ''I.e.'', a conformant Scheme
implementation may use EBCDIC or SHIFT-JIS to encode characters; it
must simply map the UCS characters from the given range into the native
representation when possible, and report errors when not possible.

<procedure>(->char-set x) -> char-set</procedure><br>

Coerces X into a char-set. X may be a string, character or char-set. A
string is converted to the set of its constituent characters; a character
is converted to a singleton set; a char-set is returned as-is. This
procedure is intended for use by other procedures that want to provide
"user-friendly," wide-spectrum interfaces to their clients.


=== Querying character sets

<procedure>(char-set-size cs) -> integer</procedure><br>

Returns the number of elements in character set CS.

<procedure>(char-set-count pred cs) -> integer</procedure><br>

Apply PRED to the chars of character set CS, and return the number of chars
that caused the predicate to return true.

<procedure>(char-set->list cs) -> character-list</procedure><br>

This procedure returns a list of the members of character set CS. The order
in which CS's characters appear in the list is not defined, and may be
different from one call to another.

<procedure>(char-set->string cs) -> string</procedure><br>

This procedure returns a string containing the members of character set CS.
The order in which CS's characters appear in the string is not defined, and
may be different from one call to another.

<procedure>(char-set-contains? cs char) -> boolean</procedure><br>

This procedure tests CHAR for membership in character set CS.

The MIT Scheme character-set package called this procedure
CHAR-SET-MEMBER?, but the argument order isn't consistent with the name.

<procedure>(char-set-every pred cs) -> boolean</procedure><br>
<procedure>(char-set-any pred cs) -> boolean</procedure><br>

The {{char-set-every}} procedure returns true if predicate PRED returns
true of every character in the character set CS. Likewise, {{char-set-any}}
applies PRED to every character in character set CS, and returns the first
true value it finds. If no character produces a true value, it returns
false. The order in which these procedures sequence through the elements of
CS is not specified.

Note that if you need to determine the actual character on which a
predicate returns true, use {{char-set-any}} and arrange for the predicate
to return the character parameter as its true value, ''e.g.''


 (char-set-any (lambda (c) (and (char-upper-case? c) c)) 
               cs)


=== Character-set algebra

<procedure>(char-set-adjoin cs char_1 ...) -> char-set</procedure><br>
<procedure>(char-set-delete cs char_1 ...) -> char-set</procedure><br>

Add/delete the CHAR_I characters to/from character set CS.

<procedure>(char-set-adjoin! cs char_1 ...) -> char-set</procedure><br>
<procedure>(char-set-delete! cs char_1 ...) -> char-set</procedure><br>

Linear-update variants. These procedures are allowed, but not required, to
side-effect their first parameter.

<procedure>(char-set-complement cs) -> char-set</procedure><br>
<procedure>(char-set-union cs_1 ...) -> char-set</procedure><br>
<procedure>(char-set-intersection cs_1 ...) -> char-set</procedure><br>
<procedure>(char-set-difference cs_1 cs_2 ...) -> char-set</procedure><br>
<procedure>(char-set-xor cs_1 ...) -> char-set</procedure><br>
<procedure>(char-set-diff+intersection cs_1 cs_2 ...) -> [char-set char-set]</procedure><br>

These procedures implement set complement, union, intersection, difference,
and exclusive-or for character sets. The union, intersection and xor
operations are n-ary. The difference function is also n-ary, associates to
the left (that is, it computes the difference between its first argument
and the union of all the other arguments), and requires at least one
argument.

Boundary cases:


 (char-set-union) => char-set:empty
 (char-set-intersection) => char-set:full
 (char-set-xor) => char-set:empty
 (char-set-difference CS) => CS


{{char-set-diff+intersection}} returns both the difference and the
intersection of the arguments -- it partitions its first parameter. It is
equivalent to


 (values (char-set-difference CS_1 CS_2 ...)
         (char-set-intersection CS_1 (char-set-union CS_2 ...)))


but can be implemented more efficiently.

Programmers should be aware that {{char-set-complement}} could potentially
be a very expensive operation in Scheme implementations that provide a very
large character type, such as 32-bit Unicode. If this is a possibility,
sets can be complimented with respect to a smaller universe using
{{char-set-difference}}.

<procedure>(char-set-complement! cs) -> char-set</procedure><br>
<procedure>(char-set-union! cs_1 cs_2 ...) -> char-set</procedure><br>
<procedure>(char-set-intersection! cs_1 cs_2 ...) -> char-set</procedure><br>
<procedure>(char-set-difference! cs_1 cs_2 ...) -> char-set</procedure><br>
<procedure>(char-set-xor! cs_1 cs_2 ...) -> char-set</procedure><br>
<procedure>(char-set-diff+intersection! cs_1 cs_2 cs_3 ...) -> [char-set char-set]</procedure><br>

These are linear-update variants of the set-algebra functions. They are
allowed, but not required, to side-effect their first (required) parameter.

{{char-set-diff+intersection!}} is allowed to side-effect both of its two
required parameters, CS_1 and CS_2.

== Standard character sets

Several character sets are predefined for convenience:

<table>
<tr><td>{{char-set:lower-case}}</td><td>Lower-case letters</td></tr>
<tr><td>{{char-set:upper-case}}</td><td>Upper-case letters</td></tr>
<tr><td>{{char-set:title-case}}</td><td>Title-case letters</td></tr>
<tr><td>{{char-set:letter}}</td><td>Letters</td></tr>
<tr><td>{{char-set:digit}}</td><td>Digits</td></tr>
<tr><td>{{char-set:letter+digit}}</td><td>Letters and digits</td></tr>
<tr><td>{{char-set:graphic}}</td><td>Printing characters except spaces</td></tr>
<tr><td>{{char-set:printing}}</td><td>Printing characters including spaces</td></tr>
<tr><td>{{char-set:whitespace}}</td><td>Whitespace characters</td></tr>
<tr><td>{{char-set:iso-control}}</td><td>The ISO control characters</td></tr>
<tr><td>{{char-set:punctuation}}</td><td>Punctuation characters</td></tr>
<tr><td>{{char-set:symbol}}</td><td>Symbol characters</td></tr>
<tr><td>{{char-set:hex-digit}}</td><td>A hexadecimal digit: 0-9, A-F, a-f</td></tr>
<tr><td>{{char-set:blank}}</td><td>Blank characters -- horizontal whitespace</td></tr>
<tr><td>{{char-set:ascii}}</td><td>All characters in the ASCII set.</td></tr>
<tr><td>{{char-set:empty}}</td><td>Empty set</td></tr>
<tr><td>{{char-set:full}}</td><td>All characters</td></tr></table>

In Unicode Scheme implementations, the base character sets are compatible
with Java's Unicode specifications. For ASCII or Latin-1, we simply
restrict the Unicode set specifications to their first 128 or 256 codes,
respectively.

Here are the definitions for some of the sets in an ASCII implementation:

<table>
<tr><td>{{char-set:lower-case}}</td><td>a-z</td></tr>
<tr><td>{{char-set:upper-case}}</td><td>A-Z</td></tr>
<tr><td>{{char-set:letter}}</td><td>A-Z and a-z</td></tr>
<tr><td>{{char-set:digit}}</td><td>0123456789</td></tr>
<tr><td>{{char-set:punctuation}}</td><td>{{!"#%&'()*,-./:;?@[\]_{}}}</td></tr>
<tr><td>{{char-set:symbol}}</td><td>{{$+<=>^`|~}}</td></tr>
<tr><td>{{char-set:whitespace}}</td><td>Space, newline, tab, form feed, vertical tab, carriage return</td></tr>
<tr><td>{{char-set:blank}}</td><td>Space and tab</td></tr>
<tr><td>{{char-set:graphic}}</td><td>letter + digit + punctuation + symbol</td></tr>
<tr><td>{{char-set:printing}}</td><td>graphic + whitespace</td></tr>
<tr><td>{{char-set:iso-control}}</td><td>ASCII 0-31 and 127</td></tr></table>

=== Character set constants

<constant>char-set:lower-case</constant>

For Unicode, a character is lowercase if


* it is not in the range [U+2000,U+2FFF], and 
* the Unicode attribute table does not give a lowercase mapping for it, and 
* at least one of the following is true: 
** the Unicode attribute table gives a mapping to uppercase for the character, or 
** the name for the character in the Unicode attribute table contains the words "SMALL LETTER" or "SMALL LIGATURE". 

The lower-case ASCII characters are

abcdefghijklmnopqrstuvwxyz

Latin-1 adds another 33 lower-case characters to the ASCII set:


<table>
<tr><td>00B5</td><td>MICRO SIGN</td></tr>
<tr><td>00DF</td><td>LATIN SMALL LETTER SHARP S</td></tr>
<tr><td>00E0</td><td>LATIN SMALL LETTER A WITH GRAVE</td></tr>
<tr><td>00E1</td><td>LATIN SMALL LETTER A WITH ACUTE</td></tr>
<tr><td>00E2</td><td>LATIN SMALL LETTER A WITH CIRCUMFLEX</td></tr>
<tr><td>00E3</td><td>LATIN SMALL LETTER A WITH TILDE</td></tr>
<tr><td>00E4</td><td>LATIN SMALL LETTER A WITH DIAERESIS</td></tr>
<tr><td>00E5</td><td>LATIN SMALL LETTER A WITH RING ABOVE</td></tr>
<tr><td>00E6</td><td>LATIN SMALL LETTER AE</td></tr>
<tr><td>00E7</td><td>LATIN SMALL LETTER C WITH CEDILLA</td></tr>
<tr><td>00E8</td><td>LATIN SMALL LETTER E WITH GRAVE</td></tr>
<tr><td>00E9</td><td>LATIN SMALL LETTER E WITH ACUTE</td></tr>
<tr><td>00EA</td><td>LATIN SMALL LETTER E WITH CIRCUMFLEX</td></tr>
<tr><td>00EB</td><td>LATIN SMALL LETTER E WITH DIAERESIS</td></tr>
<tr><td>00EC</td><td>LATIN SMALL LETTER I WITH GRAVE</td></tr>
<tr><td>00ED</td><td>LATIN SMALL LETTER I WITH ACUTE</td></tr>
<tr><td>00EE</td><td>LATIN SMALL LETTER I WITH CIRCUMFLEX</td></tr>
<tr><td>00EF</td><td>LATIN SMALL LETTER I WITH DIAERESIS</td></tr>
<tr><td>00F0</td><td>LATIN SMALL LETTER ETH</td></tr>
<tr><td>00F1</td><td>LATIN SMALL LETTER N WITH TILDE</td></tr>
<tr><td>00F2</td><td>LATIN SMALL LETTER O WITH GRAVE</td></tr>
<tr><td>00F3</td><td>LATIN SMALL LETTER O WITH ACUTE</td></tr>
<tr><td>00F4</td><td>LATIN SMALL LETTER O WITH CIRCUMFLEX</td></tr>
<tr><td>00F5</td><td>LATIN SMALL LETTER O WITH TILDE</td></tr>
<tr><td>00F6</td><td>LATIN SMALL LETTER O WITH DIAERESIS</td></tr>
<tr><td>00F8</td><td>LATIN SMALL LETTER O WITH STROKE</td></tr>
<tr><td>00F9</td><td>LATIN SMALL LETTER U WITH GRAVE</td></tr>
<tr><td>00FA</td><td>LATIN SMALL LETTER U WITH ACUTE</td></tr>
<tr><td>00FB</td><td>LATIN SMALL LETTER U WITH CIRCUMFLEX</td></tr>
<tr><td>00FC</td><td>LATIN SMALL LETTER U WITH DIAERESIS</td></tr>
<tr><td>00FD</td><td>LATIN SMALL LETTER Y WITH ACUTE</td></tr>
<tr><td>00FE</td><td>LATIN SMALL LETTER THORN</td></tr>
<tr><td>00FF</td><td>LATIN SMALL LETTER Y WITH DIAERESIS</td></tr></table>

Note that three of these have no corresponding Latin-1 upper-case
character:


<table>
<tr><td>00B5</td><td>MICRO SIGN</td></tr>
<tr><td>00DF</td><td>LATIN SMALL LETTER SHARP S</td></tr>
<tr><td>00FF</td><td>LATIN SMALL LETTER Y WITH DIAERESIS</td></tr></table>

(The compatibility micro character uppercases to the non-Latin-1 Greek
capital mu; the German sharp s character uppercases to the pair of
characters "SS," and the capital y-with-diaeresis is non-Latin-1.)

<constant>char-set:upper-case</constant>

For Unicode, a character is uppercase if


* it is not in the range [U+2000,U+2FFF], and 
* the Unicode attribute table does not give an uppercase mapping for it (this excludes titlecase characters), and 
* at least one of the following is true: 
** the Unicode attribute table gives a mapping to lowercase for the character, or 
** the name for the character in the Unicode attribute table contains the words "CAPITAL LETTER" or "CAPITAL LIGATURE". 

The upper-case ASCII characters are

ABCDEFGHIJKLMNOPQRSTUVWXYZ

Latin-1 adds another 30 upper-case characters to the ASCII set:


<table>
<tr><td>00C0</td><td>LATIN CAPITAL LETTER A WITH GRAVE</td></tr>
<tr><td>00C1</td><td>LATIN CAPITAL LETTER A WITH ACUTE</td></tr>
<tr><td>00C2</td><td>LATIN CAPITAL LETTER A WITH CIRCUMFLEX</td></tr>
<tr><td>00C3</td><td>LATIN CAPITAL LETTER A WITH TILDE</td></tr>
<tr><td>00C4</td><td>LATIN CAPITAL LETTER A WITH DIAERESIS</td></tr>
<tr><td>00C5</td><td>LATIN CAPITAL LETTER A WITH RING ABOVE</td></tr>
<tr><td>00C6</td><td>LATIN CAPITAL LETTER AE</td></tr>
<tr><td>00C7</td><td>LATIN CAPITAL LETTER C WITH CEDILLA</td></tr>
<tr><td>00C8</td><td>LATIN CAPITAL LETTER E WITH GRAVE</td></tr>
<tr><td>00C9</td><td>LATIN CAPITAL LETTER E WITH ACUTE</td></tr>
<tr><td>00CA</td><td>LATIN CAPITAL LETTER E WITH CIRCUMFLEX</td></tr>
<tr><td>00CB</td><td>LATIN CAPITAL LETTER E WITH DIAERESIS</td></tr>
<tr><td>00CC</td><td>LATIN CAPITAL LETTER I WITH GRAVE</td></tr>
<tr><td>00CD</td><td>LATIN CAPITAL LETTER I WITH ACUTE</td></tr>
<tr><td>00CE</td><td>LATIN CAPITAL LETTER I WITH CIRCUMFLEX</td></tr>
<tr><td>00CF</td><td>LATIN CAPITAL LETTER I WITH DIAERESIS</td></tr>
<tr><td>00D0</td><td>LATIN CAPITAL LETTER ETH</td></tr>
<tr><td>00D1</td><td>LATIN CAPITAL LETTER N WITH TILDE</td></tr>
<tr><td>00D2</td><td>LATIN CAPITAL LETTER O WITH GRAVE</td></tr>
<tr><td>00D3</td><td>LATIN CAPITAL LETTER O WITH ACUTE</td></tr>
<tr><td>00D4</td><td>LATIN CAPITAL LETTER O WITH CIRCUMFLEX</td></tr>
<tr><td>00D5</td><td>LATIN CAPITAL LETTER O WITH TILDE</td></tr>
<tr><td>00D6</td><td>LATIN CAPITAL LETTER O WITH DIAERESIS</td></tr>
<tr><td>00D8</td><td>LATIN CAPITAL LETTER O WITH STROKE</td></tr>
<tr><td>00D9</td><td>LATIN CAPITAL LETTER U WITH GRAVE</td></tr>
<tr><td>00DA</td><td>LATIN CAPITAL LETTER U WITH ACUTE</td></tr>
<tr><td>00DB</td><td>LATIN CAPITAL LETTER U WITH CIRCUMFLEX</td></tr>
<tr><td>00DC</td><td>LATIN CAPITAL LETTER U WITH DIAERESIS</td></tr>
<tr><td>00DD</td><td>LATIN CAPITAL LETTER Y WITH ACUTE</td></tr>
<tr><td>00DE</td><td>LATIN CAPITAL LETTER THORN</td></tr></table>


<constant>char-set:title-case</constant>

In Unicode, a character is titlecase if it has the category Lt in the
character attribute database. There are very few of these characters; here
is the entire 31-character list as of Unicode 3.0:


<table>
<tr><td>01C5</td><td>LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON</td></tr>
<tr><td>01C8</td><td>LATIN CAPITAL LETTER L WITH SMALL LETTER J</td></tr>
<tr><td>01CB</td><td>LATIN CAPITAL LETTER N WITH SMALL LETTER J</td></tr>
<tr><td>01F2</td><td>LATIN CAPITAL LETTER D WITH SMALL LETTER Z</td></tr>
<tr><td>1F88</td><td>GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI</td></tr>
<tr><td>1F89</td><td>GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1F8A</td><td>GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1F8B</td><td>GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1F8C</td><td>GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1F8D</td><td>GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1F8E</td><td>GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI</td></tr>
<tr><td>1F8F</td><td>GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI</td></tr>
<tr><td>1F98</td><td>GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI</td></tr>
<tr><td>1F99</td><td>GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1F9A</td><td>GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1F9B</td><td>GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1F9C</td><td>GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1F9D</td><td>GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1F9E</td><td>GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI</td></tr>
<tr><td>1F9F</td><td>GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI</td></tr>
<tr><td>1FA8</td><td>GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI</td></tr>
<tr><td>1FA9</td><td>GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1FAA</td><td>GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1FAB</td><td>GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1FAC</td><td>GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1FAD</td><td>GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI</td></tr>
<tr><td>1FAE</td><td>GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI</td></tr>
<tr><td>1FAF</td><td>GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI</td></tr>
<tr><td>1FBC</td><td>GREEK CAPITAL LETTER ALPHA WITH PROSGEGRAMMENI</td></tr>
<tr><td>1FCC</td><td>GREEK CAPITAL LETTER ETA WITH PROSGEGRAMMENI</td></tr>
<tr><td>1FFC</td><td>GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI</td></tr></table>

There are no ASCII or Latin-1 titlecase characters.


<constant>char-set:letter</constant>

In Unicode, a letter is any character with one of the letter categories
(Lu, Ll, Lt, Lm, Lo) in the Unicode character database.

There are 52 ASCII letters

abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ

There are 117 Latin-1 letters. These are the 115 characters that are
members of the Latin-1 {{char-set:lower-case}} and {{char-set:upper-case}}
sets, plus


<table>
<tr><td>00AA</td><td>FEMININE ORDINAL INDICATOR</td></tr>
<tr><td>00BA</td><td>MASCULINE ORDINAL INDICATOR</td></tr></table>

(These two letters are considered lower-case by Unicode, but not by SRFI 14.)


<constant>char-set:digit</constant>

In Unicode, a character is a digit if it has the category Nd in the
character attribute database. In Latin-1 and ASCII, the only such
characters are 0123456789. In Unicode, there are other digit characters in
other code blocks, such as Gujarati digits and Tibetan digits.


<constant>char-set:hex-digit</constant>

The only hex digits are 0123456789abcdefABCDEF.


<constant>char-set:letter+digit</constant>

The union of {{char-set:letter}} and {{char-set:digit.}}


<constant>char-set:graphic</constant>

A graphic character is one that would put ink on paper. The ASCII and
Latin-1 graphic characters are the members of


<table>
<tr><td>{{char-set:letter}}</td></tr>
<tr><td>{{char-set:digit}}</td></tr>
<tr><td>{{char-set:punctuation}}</td></tr>
<tr><td>{{char-set:symbol}}</td></tr></table>


<constant>char-set:printing</constant>

A printing character is one that would occupy space when printed, ''i.e.'',
a graphic character or a space character. {{char-set:printing}} is the
union of {{char-set:whitespace}} and {{char-set:graphic.}}


<constant>char-set:whitespace</constant>

In Unicode, a whitespace character is either


* a character with one of the space, line, or paragraph separator categories (Zs, Zl or Zp) of the Unicode character database. 
* U+0009 Horizontal tabulation (\t control-I) 
* U+000A Line feed (\n control-J) 
* U+000B Vertical tabulation (\v control-K) 
* U+000C Form feed (\f control-L) 
* U+000D Carriage return (\r control-M) 

There are 24 whitespace characters in Unicode 3.0:


<table>
<tr><td>0009</td><td>HORIZONTAL TABULATION</td><td>\t control-I</td></tr>
<tr><td>000A</td><td>LINE FEED</td><td>\n control-J</td></tr>
<tr><td>000B</td><td>VERTICAL TABULATION</td><td>\v control-K</td></tr>
<tr><td>000C</td><td>FORM FEED</td><td>\f control-L</td></tr>
<tr><td>000D</td><td>CARRIAGE RETURN</td><td>\r control-M</td></tr>
<tr><td>0020</td><td>SPACE</td><td>Zs</td></tr>
<tr><td>00A0</td><td>NO-BREAK SPACE</td><td>Zs</td></tr>
<tr><td>1680</td><td>OGHAM SPACE MARK</td><td>Zs</td></tr>
<tr><td>2000</td><td>EN QUAD</td><td>Zs</td></tr>
<tr><td>2001</td><td>EM QUAD</td><td>Zs</td></tr>
<tr><td>2002</td><td>EN SPACE</td><td>Zs</td></tr>
<tr><td>2003</td><td>EM SPACE</td><td>Zs</td></tr>
<tr><td>2004</td><td>THREE-PER-EM SPACE</td><td>Zs</td></tr>
<tr><td>2005</td><td>FOUR-PER-EM SPACE</td><td>Zs</td></tr>
<tr><td>2006</td><td>SIX-PER-EM SPACE</td><td>Zs</td></tr>
<tr><td>2007</td><td>FIGURE SPACE</td><td>Zs</td></tr>
<tr><td>2008</td><td>PUNCTUATION SPACE</td><td>Zs</td></tr>
<tr><td>2009</td><td>THIN SPACE</td><td>Zs</td></tr>
<tr><td>200A</td><td>HAIR SPACE</td><td>Zs</td></tr>
<tr><td>200B</td><td>ZERO WIDTH SPACE</td><td>Zs</td></tr>
<tr><td>2028</td><td>LINE SEPARATOR</td><td>Zl</td></tr>
<tr><td>2029</td><td>PARAGRAPH SEPARATOR</td><td>Zp</td></tr>
<tr><td>202F</td><td>NARROW NO-BREAK SPACE</td><td>Zs</td></tr>
<tr><td>3000</td><td>IDEOGRAPHIC SPACE</td><td>Zs</td></tr></table>

The ASCII whitespace characters are the first six characters in the
above list -- line feed, horizontal tabulation, vertical tabulation, form
feed, carriage return, and space. These are also exactly the characters
recognised by the Posix {{isspace()}} procedure. Latin-1 adds the no-break
space.

<constant>char-set:iso-control</constant>

The ISO control characters are the Unicode/Latin-1 characters in the ranges
[U+0000,U+001F] and [U+007F,U+009F].

ASCII restricts this set to the characters in the range [U+0000,U+001F]
plus the character U+007F.

Note that Unicode defines other control characters which do not belong to
this set (hence the qualifying prefix "iso-" in the name).

<constant>char-set:punctuation</constant>

In Unicode, a punctuation character is any character that has one of the
punctuation categories in the Unicode character database (Pc, Pd, Ps, Pe,
Pi, Pf, or Po.)

ASCII has 23 punctuation characters:


 !"#%&'()*,-./:;?@[\]_{}

Latin-1 adds six more:


<table>
<tr><td>00A1</td><td>INVERTED EXCLAMATION MARK</td></tr>
<tr><td>00AB</td><td>LEFT-POINTING DOUBLE ANGLE QUOTATION MARK</td></tr>
<tr><td>00AD</td><td>SOFT HYPHEN</td></tr>
<tr><td>00B7</td><td>MIDDLE DOT</td></tr>
<tr><td>00BB</td><td>RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK</td></tr>
<tr><td>00BF</td><td>INVERTED QUESTION MARK</td></tr></table>

Note that the nine ASCII characters {{$+<=>^`|~}} are ''not'' punctuation.
They are "symbols."


<constant>char-set:symbol</constant>

In Unicode, a symbol is any character that has one of the symbol categories
in the Unicode character database (Sm, Sc, Sk, or So). There are nine ASCII
symbol characters:


 $+<=>^`|~

Latin-1 adds 18 more:


<table>
<tr><td>00A2</td><td>CENT SIGN</td></tr>
<tr><td>00A3</td><td>POUND SIGN</td></tr>
<tr><td>00A4</td><td>CURRENCY SIGN</td></tr>
<tr><td>00A5</td><td>YEN SIGN</td></tr>
<tr><td>00A6</td><td>BROKEN BAR</td></tr>
<tr><td>00A7</td><td>SECTION SIGN</td></tr>
<tr><td>00A8</td><td>DIAERESIS</td></tr>
<tr><td>00A9</td><td>COPYRIGHT SIGN</td></tr>
<tr><td>00AC</td><td>NOT SIGN</td></tr>
<tr><td>00AE</td><td>REGISTERED SIGN</td></tr>
<tr><td>00AF</td><td>MACRON</td></tr>
<tr><td>00B0</td><td>DEGREE SIGN</td></tr>
<tr><td>00B1</td><td>PLUS-MINUS SIGN</td></tr>
<tr><td>00B4</td><td>ACUTE ACCENT</td></tr>
<tr><td>00B6</td><td>PILCROW SIGN</td></tr>
<tr><td>00B8</td><td>CEDILLA</td></tr>
<tr><td>00D7</td><td>MULTIPLICATION SIGN</td></tr>
<tr><td>00F7</td><td>DIVISION SIGN</td></tr></table>


<constant>char-set:blank</constant>

Blank chars are horizontal whitespace. In Unicode, a blank character is
either


* a character with the space separator category (Zs) in the Unicode character database. 
* U+0009 Horizontal tabulation (\t control-I) 

There are eighteen blank characters in Unicode 3.0:


<table>
<tr><td>0009</td><td>HORIZONTAL TABULATION</td><td>\t control-I</td></tr>
<tr><td>0020</td><td>SPACE</td><td>Zs</td></tr>
<tr><td>00A0</td><td>NO-BREAK SPACE</td><td>Zs</td></tr>
<tr><td>1680</td><td>OGHAM SPACE MARK</td><td>Zs</td></tr>
<tr><td>2000</td><td>EN QUAD</td><td>Zs</td></tr>
<tr><td>2001</td><td>EM QUAD</td><td>Zs</td></tr>
<tr><td>2002</td><td>EN SPACE</td><td>Zs</td></tr>
<tr><td>2003</td><td>EM SPACE</td><td>Zs</td></tr>
<tr><td>2004</td><td>THREE-PER-EM SPACE</td><td>Zs</td></tr>
<tr><td>2005</td><td>FOUR-PER-EM SPACE</td><td>Zs</td></tr>
<tr><td>2006</td><td>SIX-PER-EM SPACE</td><td>Zs</td></tr>
<tr><td>2007</td><td>FIGURE SPACE</td><td>Zs</td></tr>
<tr><td>2008</td><td>PUNCTUATION SPACE</td><td>Zs</td></tr>
<tr><td>2009</td><td>THIN SPACE</td><td>Zs</td></tr>
<tr><td>200A</td><td>HAIR SPACE</td><td>Zs</td></tr>
<tr><td>200B</td><td>ZERO WIDTH SPACE</td><td>Zs</td></tr>
<tr><td>202F</td><td>NARROW NO-BREAK SPACE</td><td>Zs</td></tr>
<tr><td>3000</td><td>IDEOGRAPHIC SPACE</td><td>Zs</td></tr></table>

The ASCII blank characters are the first two characters above -- horizontal
tab and space. Latin-1 adds the no-break space.

---
Previous: [[Unit srfi-4]]

Next: [[Unit srfi-18]]
