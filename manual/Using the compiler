[[tags: manual]]
[[toc:]]

== Using the compiler

The {{csc}} compiler driver provides a convenient interface to
the basic Scheme-to-C translator ({{chicken}}) and takes care
for compiling and linking the generated C files into executable
code. Enter

 csc -help

on the command line for a list of options.

=== Compiler command line format

 csc FILENAME-OR-OPTION

{{FILENAME}} is the pathname of the source file that is to
be compiled. A filename argument of {{-}} (a single dash) specifies that
the source text should be read from standard input.

==== Basic command-line options

; -analyze-only : Stop compilation after first analysis pass.

; -block : Enable block-compilation. When this option is specified, the compiler assumes that global variables are not modified outside this compilation-unit.  Specifically, toplevel bindings are not seen by {{eval}} and unused toplevel bindings are removed.

; -case-insensitive : Enables the reader to read symbols case insensitive. The default is to read case sensitive (in violation of R5RS).  This option registers the {{case-insensitive}} feature identifier.

; -check-syntax : Aborts compilation process after macro-expansion and syntax checks.

; -clustering : Combine groups of local procedures into dispatch-loops, if possible.

; -consult-inline-file FILENAME : load file with definitions for cross-module inlining generated by a previous compiler invocation via {{-emit-inline-file}}. Implies {{-inline}}.

; -debug MODES : Enables one or more compiler debugging modes. {{MODES}} is a string of characters that select debugging information about the compiler that will be printed to standard output. Use {{-debug h}} to see a list of available debugging options.

; -debug-level LEVEL : Selects amount of debug-information. {{LEVEL}} should be an integer.

     -debug-level 0             is equivalent to -no-trace -no-lambda-info
     -debug-level 1             is equivalent to -no-trace
     -debug-level 2             is equivalent to -scrutinize

; -disable-interrupts : Equivalent to the {{(disable-interrupts)}} declaration. No interrupt-checks are generated for compiled programs.

; -disable-stack-overflow-checks : Disables detection of stack overflows. This is equivalent to running the compiled executable with the {{-:o}} runtime option.

; -dynamic : This option should be used when compiling files intended to be loaded dynamically into a running Scheme program.

; -epilogue FILENAME : Includes the file named {{FILENAME}} at the end of the compiled source file. The include-path is not searched. This option may be given multiple times.

; -emit-all-import-libraries : emit import libraries for all modules defined in the current compulation unit (see also: {{-emit-import-library}}).

; -emit-external-prototypes-first : Emit prototypes for callbacks defined with {{define-external}} before any other foreign declarations. This is sometimes useful, when C/C++ code embedded into the a Scheme program has to access the callbacks. By default the prototypes are emitted after foreign declarations.

; -emit-import-library MODULE : Specifies that an import library named {{MODULE.import.scm}} for the named module should be generated (equivalent to using the {{emit-import-library}} declaration).

; -emit-inline-file FILENAME : Write procedures that can be globally inlined in internal form to {{FILENAME}}, if global inlining is enabled. Implies {{-inline -local}}. If the inline-file would be empty (because no procedure would be inlinable) no file is generated and any existing inline-file with that name is deleted.

; -emit-type-file FILENAME : Write type-information for declarations of user-defined and globally visible variables to a file of the given name. The generated file is suitable for use with the {{-types}} option.

; -explicit-use : Disables automatic use of the units {{library, eval}} and {{expand}}. Use this option if compiling a library unit instead of an application unit.

; -extend FILENAME : Loads a Scheme source file or compiled Scheme program (on systems that support it) before compilation commences. This feature can be used to extend the compiler.  This option may be given multiple times. The file is also searched in the current include path and in the extension-repository.

; -feature SYMBOL : Registers {{SYMBOL}} to be a valid feature identifier for {{cond-expand}}. Multiple symbols may be given, if comma-separated.

; -fixnum-arithmetic : Equivalent to {{(fixnum-arithmetic)}} declaration. Assume all mathematical operations use small integer arguments.

; -heap-size NUMBER : Sets a fixed heap size of the generated executable to {{NUMBER}} bytes. The parameter may be followed by a  {{M}} ({{m}}) or {{K}} ({{k}}) suffix which stand for mega- and kilobytes, respectively.  The default heap size is 5 kilobytes. Note that only half of it is in use at every given time.

; -help : Print a summary of available options and the format of the command line parameters and exit the compiler.

; -ignore-repository : Do not load any extensions from the repository (treat repository as empty). Also do not consult compiled (only interpreted) import libraries in {{import}} forms.

; -include-path PATHNAME : Specifies an additional search path for files included via the {{include}} special form. This option may be given multiple times. If the environment variable {{CHICKEN_INCLUDE_PATH}} is set, it should contain a list of alternative include pathnames separated by {{;}}.

; -inline : Enable procedure inlining for known procedures of a size below the threshold (which can be set through the {{-inline-limit}} option).

; -inline-global : Enable cross-module inlining (in addition to local inlining). Implies {{-inline}}. For more information, see also [[Declarations]].

; -inline-limit THRESHOLD : Sets the maximum size of a potentially inlinable procedure. The default threshold is {{20}}.

; -keyword-style STYLE : Enables alternative keyword syntax, where {{STYLE}} may be either {{prefix}} (as in Common Lisp, e.g. :keyword), {{suffix}} (as in DSSSL, e.g. keyword:) or {{none}}. Any other value is ignored. The default is {{suffix}}.

; -keep-shadowed-macros : Do not remove macro definitions with the same name as assigned toplevel variables (the default is to remove the macro definition).

; -local : Assume toplevel variables defined in the current compilation unit are not externally modified. This gives the compiler more opportunities for inlining. Note that this may result in counter-intuitive and non-standard behaviour: an asssignment to an exported toplevel variable executed in a different compilation unit or in evaluated code will possibly not be seen by code executing in the current compilation unit.

; -lfa2 : Does an additional lightweight flow-analysis pass on the fully optimized program to remove more type checks.

; -module : wraps the compiled code in an implicit module named {{main}}, importing the {{scheme}} and {{chicken}} modules.

; -no-argc-checks : disable argument count checks

; -no-bound-checks : disable bound variable checks

; -no-feature SYMBOL : Disables the predefined feature-identifier {{SYMBOL}}. Multiple symbols may be given, if comma-separated.

; -no-lambda-info : Don't emit additional information for each {{lambda}} expression (currently the argument-list, after alpha-conversion/renaming).

; -no-module-registration : Do not generate module-registration code in the compiled code. This is only needed if you want to use an import library that is generated by other means (manually, for example).

; -no-parentheses-synonyms : Disables list delimiter synonyms, [..] and {...} for (...).

; -no-procedure-checks : disable procedure call checks

; -no-procedure-checks-for-usual-bindings :  disable procedure call checks only for usual bindings

; -no-procedure-checks-for-toplevel-bindings :  disable bound and procedure call checks for calls to procedures referenced through a toplevel variable.

; -no-symbol-escape : Disables support for escaped symbols, the |...| form.

; -no-trace : Disable generation of tracing information. If a compiled executable should halt due to a runtime error, then a list of the name and the line-number (if available) of the last procedure calls is printed, unless {{-no-trace}} is specified. With this option the generated code is slightly faster.

; -no-warnings : Disable generation of compiler warnings.

; -nursery NUMBER :
; -stack-size NUMBER : Sets the size of the first heap-generation of the generated executable to {{NUMBER}} bytes. The parameter may be followed by a {{M}} ({{m}}) or {{K}} ({{k}}) suffix.  The default stack-size depends on the target platform.

; -optimize-leaf-routines : Enable leaf routine optimization.

; -optimize-level LEVEL : Enables certain sets of optimization options. {{LEVEL}} should be an integer.

     -optimize-level 0          is equivalent to -no-usual-integrations -no-compiler-syntax
     -optimize-level 1          is equivalent to -optimize-leaf-routines
     -optimize-level 2          is equivalent to -optimize-leaf-routines -inline
     -optimize-level 3          is equivalent to -optimize-leaf-routines -local -inline -inline-global -specialize
     -optimize-level 4          is equivalent to -optimize-leaf-routines -local -inline -inline-global -specialize -unsafe
     -optimize-level 5          is equivalent to -optimize-leaf-routines -block -inline -inline-global -specialize -unsafe -disable-interrupts -no-trace -no-lambda-info -clustering -lfa2

; -output-file FILENAME : Specifies the pathname of the generated C file. Default is {{FILENAME.c}}.

; -postlude EXPRESSIONS : Add {{EXPRESSIONS}} after all other toplevel expressions in the compiled file.  This option may be given multiple times. Processing of this option takes place after processing of {{-epilogue}}.

; -prelude EXPRESSIONS : Add {{EXPRESSIONS}} before all other toplevel expressions in the compiled file.  This option may be given multiple times. Processing of this option takes place before processing of {{-prologue}}.

; -profile : 
; -accumulate-profile : Instruments the source code to count procedure calls and execution times. After the program terminates (either via an explicit {{exit}} or implicitly), profiling statistics are written to a file named {{PROFILE.<randomnumber>}}. Each line of the generated file contains a list with the procedure name, the number of calls and the time spent executing it. Use the {{chicken-profile}} program to display the profiling information in a more user-friendly form. Enter {{chicken-profile -help}} at the command line to get a list of available options. The {{-accumulate-profile}} option is similar to {{-profile}}, but the resulting profile information will be appended to any existing {{PROFILE}} file. {{chicken-profile}} will merge and sum up the accumulated timing information, if several entries for the same procedure calls exist. Only profiling information for global procedures will be collected.  See the {{-:p}} option under [[#runtime-options|"Runtime options"]] below for statistical profiling support.

; -profile-name FILENAME : Specifies name of the generated profile information (which defaults to {{PROFILE.<randomnumber>}}. Implies {{-profile}}.

; -prologue FILENAME : Includes the file named {{FILENAME}} at the start of the compiled source file.  The include-path is not searched. This option may be given multiple times.

; -r5rs-syntax : Disables the CHICKEN extensions to R5RS syntax. Does not disable [[Non-standard read syntax|non-standard read syntax]].

; -raw : Disables the generation of any implicit code that uses the Scheme libraries (that is all runtime system files besides {{runtime.c}} and {{chicken.h}}).

; -require-extension NAME : Loads the extension {{NAME}} before the compilation process commences. This is identical to adding {{(require-extension NAME)}} at the start of the compiled program. If {{-uses NAME}} is also given on the command line, then any occurrences of {{-require-extension NAME}} are replaced with {{(declare (uses NAME))}}. Multiple names may be given and should be separated by commas.

; -setup-mode : When locating extension, search the current directory first. By default, extensions are located first in the ''extension repository'', where {{chicken-install}} stores compiled extensions and their associated metadata.

; -specialize : Enable simple flow-analysis for doing some type-directed optimizations.

; -strict-types : Assume that the type of variables is not changed by assignments. This gives more type-information during specialization, but violating this assumption will result in unsafe and incorrectly behaving code.

; -types FILENAME : load additional type database from {{FILENAME}}. Type-definitions in {{FILENAME}} will override previous type-definitions.

; -compile-syntax : Makes macros also available at run-time. By default macros are not available at run-time.

; -to-stdout : Write compiled code to standard output instead of creating a {{.c}} file.

; -unit NAME : Compile this file as a library unit. Equivalent to {{-prelude "(declare (unit NAME))"}}

; -unsafe : Disable runtime safety checks.

; -uses NAME : Use definitions from the library unit {{NAME}}. This is equivalent to {{-prelude "(declare (uses NAME))"}}. Multiple arguments may be given, separated by {{,}}.

; -no-usual-integrations : Specifies that standard procedures and certain internal procedures may be redefined, and can not be inlined. This is equivalent to declaring {{(not usual-integrations)}}.

; -version : Prints the version and some copyright information and exit the compiler.

; -verbose : enables output of notes that are not necessarily warnings but might be of interest.

The environment variable {{CHICKEN_OPTIONS}} can be set to a string
with default command-line options for the compiler.

==== Further options

Enter 

  csc -help

to see a list of all supported options and short aliases to basic options. 

=== Runtime options

After successful compilation a C source file is generated and can be
compiled with a C compiler. Executables generated with CHICKEN (and the
compiler itself) accept a small set of runtime options:

; {{-:?}} : Shows a list of the available runtime options and exits the program.

; {{-:aNUMBER}} : Specifies the length of the buffer for recording a trace of the last invoked procedures. Defaults to 16.

; {{-:b}} : Enter a read-eval-print-loop when an error is encountered.

; {{-:B}} : Sounds a bell (ASCII 7) on every major garbage collection.

; {{-:c}} : Forces console mode. Currently this is only used in the interpreter ({{csi}}) to force output of the {{#;N>}} prompt even if stdin is not a terminal (for example if running in an {{emacs}} buffer under Windows).

; {{-:d}} : Prints some debug-information at runtime.

; {{-:D}} : Prints some more debug-information at runtime.

; {{-:g}} : Prints information about garbage-collection.

; {{-:G}} : Force GUI mode (show error messages in dialog box, suitable for platform).

; {{-:H}} : Before terminating, dump heap usage to stderr.

; {{-:fNUMBER}} : Specifies the maximal number of currently pending finalizers before finalization is forced.

; {{-:hNUMBER}} : Specifies fixed heap size

; {{-:hgPERCENTAGE}} : Sets the growth rate of the heap in percent. If the heap is exhausted, then it will grow by {{PERCENTAGE}}. The default is 200.

; {{-:hiNUMBER}} : Specifies the initial heap size

; {{-:hmNUMBER}} : Specifies a maximal heap size. The default is (2GB - 15).

; {{-:hsPERCENTAGE}} : Sets the shrink rate of the heap in percent. If no more than a quarter of {{PERCENTAGE}} of the heap is used, then it will shrink to {{PERCENTAGE}}. The default is 50.  Note: If you want to make sure that the heap never shrinks, specify a value of {{0}}.  (this can be useful in situations where an optimal heap-size is known in advance). 

; {{-:o}} : Disables detection of stack overflows at run-time.

; {{-:p}} : Enable collection of statistics for profiling purposes and write to PROFILE.{{pid}} on exit.  This functions at a granularity defined by the trace information in the binary and libraries: each traced function will show up in the output.  See the {{-profile}} compiler option for instrumentation-based profiling.  The {{PROFILE.pid}} format is compatible with the format generated by instrumentation-based profiling.

; {{-:PFREQUENCY}} : Same as {{-:p}} but set the sampling frequency in microseconds (default is 10000 microseconds or every 10 milliseconds).

; {{-:r}} : Writes trace output to stderr. This option has no effect with in files compiled with the {{-no-trace}} options.

; {{-:sNUMBER}} : Specifies stack size.

; {{-:tNUMBER}} : Specifies symbol table size.

; {{-:w}} : Enables garbage collection of unused symbols. By default unused and unbound symbols are not garbage collected.

; {{-:x}} : Raises uncaught exceptions of separately spawned threads in primordial thread. By default uncaught exceptions in separate threads are not handled, unless the primordial one explicitly joins them. When warnings are enabled (the default) and {{-:x}} is not given, a warning will be shown, though.

Runtime argument values should be given as integers, optionally followed
by a unit modifier for kilobytes (suffixed with {{K}} or {{k}}),
megabytes (suffixed with {{M}} or {{m}}), or gigabytes (suffixed with
{{G}} or {{g}}).

Runtime options may be combined, like {{-:dc}}, but everything following
an argument is ignored. So {{-:wh64m}} is OK, but {{-:h64mw}} will not
enable GC of unused symbols.

=== Examples

==== A simple example (with one source file)

To compile a Scheme program (assuming a UNIX-like environment) consisting of a single source file, perform the following steps.

===== Writing your source file

In this example we will assume your source file is called {{foo.scm}}:

<enscript highlight=scheme>
;;; foo.scm

(define (fac n)
  (if (zero? n)
      1
      (* n (fac (- n 1))) ) )

(write (fac 10))
(newline)
</enscript>

===== Compiling your program

Compile the file {{foo.scm}}:

 % csc foo.scm

This will produce the {{foo}} executable:

 % ls
 foo  foo.scm

===== Running your program

To run your newly compiled executable use:

 % ./foo
 3628800


==== An example with multiple files

If multiple bodies of Scheme code are to be combined into a single
executable, then we have to compile each file and link the resulting
object files together with the runtime system.

Let's consider an example where your program consists of multiple source files.

===== Writing your source files

The declarations in these files specify which of the compiled files is the main
module, and which is the library module. An executable can only have
one main module, since a program has only a single entry-point. In this
case {{foo.scm}} is the main module, because it doesn't have a
{{unit}} declaration:

<enscript highlight=scheme>
;;; foo.scm

; The declaration marks this source file as dependant on the symbols provided
; by the bar unit:
(declare (uses bar))

(write (fac 10)) (newline)
</enscript>

{{bar.scm}} will be our library:

<enscript highlight=scheme>
;;; bar.scm

; The declaration marks this source file as the bar unit.  The names of the
; units and your files don't need to match.
(declare (unit bar))

(define (fac n)
  (if (zero? n)
      1
      (* n (fac (- n 1))) ) )
</enscript>

===== Compiling and running your program

You should compile your two files with the following commands:

 % csc -c bar.scm
 % csc -c foo.scm

That should produce two files, {{bar.o}} and {{foo.o}}.
They contain the code from your source files in compiled form.

To link your compiled files use the following command:

 % csc foo.o bar.o -o foo

This should produce the {{foo}} executable, which you can run just as in the previous example.
At this point you can also erase the {{*.o}} files.

You could avoid one step and link the two files just as {{foo.scm}} is compiled:

 % csc -c bar.scm
 % csc foo.scm bar.o -o foo

Note that if you want to distribute your program, you might want it to
follow the GNU Coding Standards.  One relatively easy way to achieve
this is to use Autoconf and Automake, two tools made for this specific
purpose. 

=== Extending the compiler

The compiler supplies a couple of hooks to add user-level passes to the
compilation process. Before compilation commences any Scheme source files
or compiled code specified using the {{-extend}} option are loaded
and evaluated.  The parameters {{user-options-pass, user-read-pass,
user-preprocessor-pass, user-pass}} and {{user-post-analysis-pass}} can be set
to procedures that are called to perform certain compilation passes
instead of the usual processing (for more information about parameters
see: [[Supported language]].

<parameter>user-options-pass</parameter>

Holds a procedure that will be called with a list of command-line arguments and should return two values: the source filename and the actual list of options, where compiler switches have their leading {{-}} (hyphen) removed and are converted to symbols.  Note that this parameter is invoked '''before''' processing of the {{-extend}} option, and so can only be changed in compiled user passes.

<parameter>user-read-pass</parameter>

Holds a procedure of three arguments. The first argument is a list of strings with the code passed to the compiler via {{-prelude}} options. The second argument is a list of source files including any files specified by {{-prologue}} and {{-epilogue}}. The third argument is a list of strings specified using {{-postlude}} options. The procedure should return a list of toplevel Scheme expressions.

<parameter>user-preprocessor-pass</parameter>

Holds a procedure of one argument. This procedure is applied to each toplevel expression in the source file '''before''' macro-expansion. The result is macro-expanded and compiled in place of the original expression.

<parameter>user-pass</parameter>

Holds a procedure of one argument. This procedure is applied to each toplevel expression '''after''' macro-expansion.  The result of the procedure is then compiled in place of the original expression. 

<parameter>user-post-analysis-pass</parameter>

Holds a procedure that will be called after every performed program analysis pass. The procedure (when defined) will be called with seven arguments: a symbol indicating the analysis pass, the program database, the current node graph, a getter and a setter-procedure which can be used to access and manipulate the program database, which holds various information about the compiled program, a pass iteration count, and an analysis continuation flag. The getter procedure should be called with two arguments: a symbol representing the binding for which information should be retrieved, and a symbol that specifies the database-entry. The current value of the database entry will be returned or {{#f}}, if no such entry is available. The setter procedure is called with three arguments: the symbol and key and the new value. The pass iteration count currently is meaningful only for the 'opt pass. The analysis continuation flag will be {{#f}} for the last 'opt pass. For information about the contents of the program database contact the author.

Loaded code (via the {{-extend}} option) has access to the library
units {{extras, srfi-1, srfi-4, utils, regex}} and the pattern matching macros. 
Multithreading is not available.

Note that the macroexpansion/canonicalization phase of the compiler adds
certain forms to the source program.  These extra expressions are not
seen by {{user-preprocessor-pass}} but by {{user-pass}}.

=== Distributing compiled C files

It is relatively easy to create distributions of Scheme projects that
have been compiled to C.  The runtime system of CHICKEN consists of only
three handcoded C files ({{runtime.c}} and {{chicken.h}}), plus
the file {{chicken-config.h}}, which is generated by the build process. All
other modules of the runtime system and the extension libraries are just
compiled Scheme code.The following example shows a minimal application, which
should run without changes on the most frequent operating systems, like Windows,
Linux or FreeBSD (Static binaries are NOT supported on Mac OS X):


Let's take a simple example.

<enscript highlight=scheme>
; hello.scm

(print "Hello, world!")
</enscript>

  % csc -t hello.scm -optimize-level 3 -output-file hello.c

Compiled to C, we get {{hello.c}}. We need the files {{chicken.h}},
{{chicken-config.h}}, {{build-version.c}}, {{buildtag.h}} and
{{runtime.c}}, which contain the basic runtime system, plus the five
basic library files {{library.c}}, {{eval.c}}, {{expand.c}},
{{modules.c}} and {{build-version.c}} which contain the same
functionality as the library linked into a plain CHICKEN-compiled
application, or which is available by default in the interpreter,
{{csi}}:


  % cd /tmp
  % echo '(print "Hello World.")' > hello.scm
  % cp $CHICKEN_BUILD/runtime.c  .
  % cp $CHICKEN_BUILD/library.c  .
  % cp $CHICKEN_BUILD/eval.c     .
  % cp $CHICKEN_BUILD/extras.c   .
  % cp $CHICKEN_BUILD/expand.c   .
  % cp $CHICKEN_BUILD/modules.c  .
  % cp $CHICKEN_BUILD/build-version.c  .
  % cp $CHICKEN_BUILD/chicken.h  .
  % cp $CHICKEN_BUILD/chicken-config.h  .
  % cp $CHICKEN_BUILD/buildtag.h  .
  % gcc -static -Os -fomit-frame-pointer -DHAVE_CHICKEN_CONFIG_H runtime.c build-version.c \
     library.c eval.c expand.c modules.c hello.c -o hello -lm

Now we have all files together, and can create an tarball containing all the files:

 % tar cf hello.tar hello.c runtime.c build-version.c library.c eval.c extras.c \
   expand.c modules.c chicken.h chicken-config.h
 % gzip hello.tar

This is naturally rather simplistic. Things like enabling dynamic
loading and selecting supported features of the host system would need
more configuration- and build-time support. All this can be addressed
using more elaborate build-scripts, makefiles or by using
autoconf/automake.

The {{chicken-config.h}} file may contain wrong settings for your
deployment target. Especially when the architecture is different.
In that case you will have to adjust the values as needed.

Note also that the size of the application can still be reduced by removing
{{eval}} and compiling {{hello.scm}} with the {{-explicit-use}} option.

For more information, study the CHICKEN source code and/or ask on the CHICKEN
mailing list.

---
Previous: [[Basic mode of operation]]

Next: [[Using the interpreter]]
